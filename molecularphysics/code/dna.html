<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.175.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.175.0/examples/jsm/"
      }
    }
</script>

<canvas id="myCanvas" width="600" height="600" style="border: none;"></canvas>
<script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    const vector = THREE.Vector3;
    const color = THREE.Color;

    const scene = new THREE.Scene();
    scene.background = new color(0x191919);

    const canvas = document.getElementById('myCanvas');
    canvas.focus();
    const canvasWidth = canvas.getAttribute('width');
    const canvasHeight = canvas.getAttribute('height');

    const camera = new THREE.PerspectiveCamera(75, canvasWidth/canvasHeight, 0.1, 1000);
    camera.position.z = 35;

    const renderer = new THREE.WebGLRenderer( {antialias: true, canvas: canvas} );
    renderer.setSize( canvasWidth, canvasHeight );
    renderer.shadowMap.enabled = true;

    const light1 = new THREE.DirectionalLight(0xffffff, 1);
    light1.position.set(12, 12, 12);
    light1.castShadow = true;
    scene.add(light1);
    const light2 = new THREE.DirectionalLight(0xffffff, 1);
    light2.position.set(-12, 12, -12);
    light2.castShadow = true;
    scene.add(light2);

    const controls = new OrbitControls(camera, canvas);
    controls.target.set(0, 0, 0);
    controls.update();

    class Dna {
        static bondGeometry = new THREE.CylinderGeometry(0.3, 0.3, 10, 32);

        constructor() {
            this.dna = new THREE.Object3D();
            let lastLeftWorld = null;
            let lastRightWorld = null;
            for (let i = 0; i <= 20; i++) {
                const lastPositions = this.createNucleotidePair(i, lastLeftWorld, lastRightWorld);
                lastLeftWorld = lastPositions[0];
                lastRightWorld = lastPositions[1];
            }
            this.dna.position.y = -20;
            scene.add(this.dna);
        }

        createNucleotidePair(i, lastLeftWorld, lastRightWorld) {
            const cylinder = new THREE.Mesh(Dna.bondGeometry, Dna.bondMaterial);
            cylinder.rotation.z = 90 * Math.PI / 180;
            cylinder.position.x = 0;
            let {ballRight, ballLeft} = this.nucleotides(i);

            const bondBetweenBalls = this.createBondBetween(ballLeft.position, ballRight.position, new color(0x2e50ac));
            const row = this.addBondToDna(bondBetweenBalls, ballRight, ballLeft, i);

            const {
                currentLeftWorld,
                currentRightWorld
            } = this.createPhosphateBackboneBonds(row, ballLeft, ballRight, lastLeftWorld, lastRightWorld);

            return [currentLeftWorld, currentRightWorld];
        }

        addBondToDna(bondBetweenBalls, ballRight, ballLeft, i) {
            const row = new THREE.Object3D();
            row.add(bondBetweenBalls);
            row.add(ballRight);
            row.add(ballLeft);
            row.position.y = i * 2;
            row.rotation.y = 30 * i * Math.PI / 180;
            this.dna.add(row);
            return row;
        }

        createPhosphateBackboneBonds(row, ballLeft, ballRight, lastLeftWorld, lastRightWorld) {
            row.updateMatrixWorld(true);
            const currentLeftWorld = new vector();
            const currentRightWorld = new vector();
            ballLeft.getWorldPosition(currentLeftWorld);
            ballRight.getWorldPosition(currentRightWorld);

            if (lastLeftWorld && lastRightWorld) {
                const leftBackbone = this.createBondBetween(lastLeftWorld, currentLeftWorld, new color(0xff00ff), 0.15);
                const rightBackbone = this.createBondBetween(lastRightWorld, currentRightWorld, new color(0x00ffff), 0.15);
                this.dna.add(leftBackbone);
                this.dna.add(rightBackbone);
            }
            return {currentLeftWorld, currentRightWorld};
        }

        createBall(position, colour, radius=1.2, metallic=false) {
            const colouredMaterial = new THREE.MeshPhysicalMaterial({
                color: colour,
                metalness: metallic ? 0.8 : 0.1,
                roughness: metallic ? 0.2 : 0.7,
                clearcoat: metallic ? 0.8 : 0.3,
                clearcoatRoughness: 0.2,
                envMapIntensity: 1.0,
                wireframe: false
            });
            const moleculeGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const mesh = new THREE.Mesh(moleculeGeometry, colouredMaterial);
            mesh.position.set(position.x, position.y, position.z);
            return mesh;
        }

        nucleotides(i) {
            let ballRight, ballLeft;
            if (i % 4 === 0) {
                ballLeft = this.createBall(new vector(-5, 0, 0), new color(0x0000ff));
                ballRight = this.createBall(new vector(6, 0, 0), new color(0xffff00));
            } else if (i % 4 === 1) {
                ballLeft = this.createBall(new vector(-5, 0, 0), new color(0xff0000));
                ballRight = this.createBall(new vector(6, 0, 0), new color(0x00ff00));
            } else if (i % 4 === 2) {
                ballLeft = this.createBall(new vector(-5, 0, 0), new color(0xffff00));
                ballRight = this.createBall(new vector(6, 0, 0), new color(0x0000ff));
            } else {
                ballLeft = this.createBall(new vector(-5, 0, 0), new color(0x00ff00));
                ballRight = this.createBall(new vector(6, 0, 0), new color(0xff0000));
            }
            return {ballRight, ballLeft};
        }

        createBondBetween(pointA, pointB, colour, radius=0.2) {
            const direction = new vector().subVectors(pointB, pointA);
            const length = direction.length();
            const midPoint = new vector().addVectors(pointA, pointB).multiplyScalar(0.5);
            const bondGeometry = new THREE.CylinderGeometry(radius, radius, length, 16);
            const bondMaterial = new THREE.MeshLambertMaterial({
                color: colour,
                emissive: colour,
                emissiveIntensity: 0.4
            });
            const bond = new THREE.Mesh(bondGeometry, bondMaterial);

            // Orient the bond to face between the points
            bond.position.copy(midPoint);
            bond.quaternion.setFromUnitVectors(
                new vector(0, 1, 0), // default cylinder orientation
                direction.clone().normalize()
            );

            return bond;
        }

        rotateY() {
            this.dna.rotation.y += 0.01;
        }
    }

    const dna = new Dna();
    function render() {
        requestAnimationFrame(render);
        dna.rotateY();
        renderer.render(scene, camera);
    }

    render();
</script>