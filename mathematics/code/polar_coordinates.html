<style>
    canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
    }

    #container {
        position: relative;
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        aspect-ratio: 1 / 1;
    }

    #gui-container {
        margin-top: 0.5em;
        background: #1a1a1a;
    }
</style>

<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<div id="container">
    <canvas id="myCanvas"></canvas><br/>
</div>
<div id="gui-container"></div>

<script type="module">
    import * as THREE from "three";
    import { Axes, Plot3D, StandardAxesAnnotations, MatlabAxesLayout }
        from 'https://www.hendrikse.name/science/js/components-library.js';
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";

    const canvasContainer = document.getElementById("container");
    const canvas = document.getElementById("myCanvas");

    const scene = new THREE.Scene();
    const worldGroup = new THREE.Group();
    scene.add(worldGroup);

    const radius = 2;
    const params = {
        theta: 45,
        phi: 45
    };

    class Arrow extends THREE.Group {
        constructor(position, direction, color=0xff0000, length=0.6) {
            super();
            this.arrow = new THREE.ArrowHelper(direction, position, length, color);
            this.add(this.arrow);
        }

        moveTo = (newPosition) => this.arrow.position.copy(newPosition);
        pointAlong = (newDirectionVector) => this.arrow.setDirection(newDirectionVector);
    }

    class TangentVectors extends THREE.Group {
        constructor(radius, theta=params.theta, phi=params.phi) {
            super();
            const radialDirection = this.#radialDirection(radius, phi, theta);
            this.radialArrow = new Arrow(this.#positionOnSphere(radius, phi, theta), radialDirection, 0x00ff00);

            const thetaDirection = new THREE.Vector3(radialDirection.z, 0, -radialDirection.x).normalize();
            this.thetaArrow = new Arrow(this.#positionOnSphere(radius, phi, theta), thetaDirection, 0xff0000);

            const phiDirection = thetaDirection.clone().cross(radialDirection).normalize();
            this.phiArrow = new Arrow(this.#positionOnSphere(radius, phi, theta), phiDirection, 0x00ffff);

            const radialLineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, radius, 0),
                this.#positionOnSphere(radius, phi, theta)
            ]);
            this.radialLine = new THREE.Line(radialLineGeometry, new THREE.LineBasicMaterial({ color: 0x00ff00 }));

            this.add(this.radialArrow, this.thetaArrow, this.phiArrow, this.radialLine);
        }

        #positionOnSphere(radius, phiDeg, thetaDeg) {
            const theta = THREE.MathUtils.degToRad(phiDeg);
            const phi   = THREE.MathUtils.degToRad(thetaDeg);

            const position = Axes.toCartesian(radius, theta, phi);
            return new THREE.Vector3(position.x, position.y + radius, position.z);
        }

        #radialDirection(radius, phiDeg, thetaDeg) {
            const theta = THREE.MathUtils.degToRad(phiDeg);   // polar angle
            const phi   = THREE.MathUtils.degToRad(thetaDeg); // azimuth

            return Axes.toCartesian(radius, theta, phi).clone().normalize();
        }

        update(radius, phi, theta) {
            const radialDirection = this.#radialDirection(radius, phi, theta);
            this.radialArrow.moveTo(this.#positionOnSphere(radius, phi, theta));
            this.radialArrow.pointAlong(radialDirection);

            const thetaDir = new THREE.Vector3(radialDirection.z, 0, -radialDirection.x).normalize();
            this.thetaArrow.moveTo(this.#positionOnSphere(radius, phi, theta));
            this.thetaArrow.pointAlong(thetaDir);

            const phiDir = thetaDir.clone().cross(radialDirection).normalize();
            this.phiArrow.moveTo(this.#positionOnSphere(radius, phi, theta));
            this.phiArrow.pointAlong(phiDir);

            this.radialLine.geometry.setFromPoints(
                [new THREE.Vector3(0, radius, 0), this.#positionOnSphere(radius, phi, theta)]);
        }
    }

    const tangentVectors = new TangentVectors(radius);
    worldGroup.add(tangentVectors);
    class ControlsGui {
        constructor() {
            const gui = new GUI({width: 300, autoPlace: false});
            gui.add(params, "theta", 0, 360, 0.1)
                .name("θ (theta)")
                .onChange(value => tangentVectors.update(radius, params.phi, value));
            gui.add(params, "phi", 0, 180, 0.1)
                .name("φ (phi)")
                .onChange(value => tangentVectors.update(radius, value, params.theta));
        }
    }

    const axes = new Axes(worldGroup);
    axes.setLayout(new MatlabAxesLayout(radius * 2, 10));
    const annotations = new StandardAxesAnnotations(canvasContainer, radius * 2, 10, false);
    axes.setAnnotations(annotations);
    annotations.show();

    const plot3D = new Plot3D(canvas, scene, axes);
    const bbox = new THREE.Box3();
    bbox.setFromObject( worldGroup );
    plot3D.fitToBoundingBox(bbox, {padding: 1.1, translationY: -2});

    const resolution = 50;
    const geometry = new THREE.SphereGeometry( radius, resolution, resolution );
    const material = new THREE.MeshStandardMaterial( { side:THREE.DoubleSide, color: 0xffff00, transparent: true, opacity: 0.5 } );
    const sphere = new THREE.Mesh( geometry, material );
    sphere.position.set(0, radius, 0);
    worldGroup.add( sphere );

    const gui = new ControlsGui();

    function animate() {
        requestAnimationFrame(animate);
        plot3D.render();
    }
    animate();
</script>
