<!--
  -- https://physics.bu.edu/~duffy/HTML5/brownian_motion.html
  -->

<canvas class="applicationCanvas2D" id="brownianCanvas" width="500" height="500"></canvas>
<div class="buttonRow">
    <button id="play">Play</button>
    <button id="pause">Pause</button>
    <button id="reset">Reset</button>
</div>
<p style="clear: both;"></p>
<div class="buttonRow">Molecules:&nbsp;
    <button id="show">Show</button>
    <button id="hide">Hide</button>
    <button id="add">Add</button>
</div>
<p style="clear: both;"></p>
<div id="tempSlider">
    <label for="tempValue">
        Cold <input type="range" id="tempValue" min="0.01"
                                 max="1.0" value=".5" step="0.01" oninput="showTempValue(this.value)" onchange="showTempValue(this.value)"> Hot
    </label>
</div>

<script>
    const brownianCanvas = document.getElementById("brownianCanvas");
    const context = brownianCanvas.getContext("2d");

    const Array2D = (r, c, initialValue) => [...Array(r)].map(_ => Array(c).fill(initialValue));
    const simTitle = 'Brownian motion';
    const ballRadius = 5;
    const nBalls = 301;
    const overlap = Array2D(nBalls, nBalls, false);
    const oldOverlap = Array2D(nBalls, nBalls, true);
    const boxHeight = 400;
    const boxWidth = 400;
    const centerX = brownianCanvas.clientWidth  * .5;
    const centerY = 250;
    const nPath = 500000;
    const dust = new Array(nPath);
    
    let index = -1;
    let runFlag = true;
    let time = 0;
    let numBalls = 200;
    let showMolecules = true;

    const playButton = document.getElementById("play");
    playButton.addEventListener("click", () => play());
    const pauseButton = document.getElementById("pause");
    pauseButton.addEventListener("click", () => pause());
    const resetButton = document.getElementById("reset");
    resetButton.addEventListener("click", () => reset());
    const showButton = document.getElementById("show");
    showButton.addEventListener("click", () => showMolecules = true);
    const hideButton = document.getElementById("hide");
    hideButton.addEventListener("click", () => showMolecules = false);
    const addButton = document.getElementById("add");
    addButton.addEventListener("click", () => addBalls());

    const showTempValue = (newTempValue) => speedFactor = Math.sqrt(Number(newTempValue));

    function play() {
        window.clearTimeout(timer);
        runFlag = true;
        animate();
    }

    function pause() {
        window.clearTimeout(timer);
        runFlag = false;
    }

    function addBalls() {
        numBalls = 250;
        for (let i = 200; i < 250; i++) {
            ball[i].x = (centerX + 0.48 * boxWidth - ballRadius);
            ball[i].y = (centerY + 0.48 * boxWidth - ballRadius);
        }

        for (let i = 0; i < numBalls; i++)
            for (let j = 200; j< nBalls; j++)
                oldOverlap[i][j] = true;
    }

    function reset() {
        window.clearTimeout(timer);
        index = -1;
        numBalls = 200;
        for (let i = 0; i < numBalls; i++) {
            ball[i].x = centerX;
            ball[i].y = centerY;
        }
        ball[0].velX = -1.0 + 2.0 * Math.random();
        ball[0].velY = -1.0 + 2.0 * Math.random();

        for (let i = 0; i < numBalls; i++)
            for (let j = 0; j< nBalls; j++)
                oldOverlap[i][j] = true;
        pushIndex = -1;
        runFlag = true;
    }

    class Ball {
        constructor(x, y, radius, color) {
            this.x = x;
            this.y = y;
            this.velX = -1.0 + 2.0 * Math.random();
            this.velY = -1.0 + 2.0 * Math.random();
            this.radius = radius;
            this.color = color;
        }

        distanceSquaredTo(otherBall) {
            const distX = otherBall.x - this.x;
            const distY = otherBall.y - this.y;
            return distX * distX + distY * distY;
        }

        distanceTo = (otherBall) => Math.sqrt(this.distanceSquaredTo(otherBall));

        limitTo(left, right, top, bottom) {
            if (this.x > right)  this.velX = -Math.abs(this.velX);
            if (this.x < left)   this.velX =  Math.abs(this.velX);
            if (this.y > top)    this.velY = -Math.abs(this.velY);
            if (this.y < bottom) this.velY =  Math.abs(this.velY);
        }

        collideWith(otherBall) {
            const vxi = this.velX;
            const vyi = this.velY;
            const vxj = otherBall.velX;
            const vyj = otherBall.velY;
            const distance = this.distanceTo(otherBall);
            const cosTheta = (otherBall.y - this.y) / distance;
            const sinTheta = (otherBall.x - this.x) / distance;
            this.velX = vxi + sinTheta * ( -vxi * sinTheta + vxj * sinTheta - vyi * cosTheta + vyj * cosTheta);
            this.velY = vyi + cosTheta * ( -vyi * cosTheta + vyj * cosTheta - vxi * sinTheta + vxj * sinTheta);
            otherBall.velX = vxj + vxi - this.velX;
            otherBall.velY = vyj + vyi - this.velY;
        }

        draw(visible) {
            if (!visible) return;

            context.fillStyle = this.color;
            context.strokeStyle = this.color;
            context.beginPath();
            context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);
            context.fill();
        }

        move() {
            this.x += speedFactor * this.velX;
            this.y += speedFactor * this.velY;
            const left = centerX - 0.5 * boxWidth +  this.radius;
            const right = centerX + 0.5 * boxWidth -  this.radius
            const top = centerY + 0.5 * boxHeight - this.radius;
            const bottom = centerY - 0.5 * boxHeight + this.radius;
            this.limitTo(left, right, top, bottom);
        }

        isCollidingWith = (otherBall) => this.distanceSquaredTo(otherBall) < (2 * otherBall.radius * 2 * this.radius);
    }

    let timer;
    let ball = new Array(nBalls + 1);
    for (let i = 0; i <= nBalls; i++)
        ball[i] = new Ball(centerX, centerY, ballRadius, "yellow");

    ball[0].color = "red";
    ball[0].radius = 20;
    for (let i = 200; i < 250; i++)
        ball[i].color = "cyan";
    
    let speedFactor = 1;
    let pushIndex = -1;
    
    for (let i = 0; i < nPath; i++)
        dust[i] = {
            x: centerX,
            y: centerY
        };

    function handleCollisionBetween(i, j) {
        if (overlap[i][j] && !oldOverlap[i][j]) ball[i].collideWith(ball[j]);
        oldOverlap[i][j] = overlap[i][j];
    }

    function drawDustTrail() {
        if (pushIndex <= -1) return;

        dust[pushIndex].x = ball[0].x;
        dust[pushIndex].y = ball[0].y;
        context.beginPath();
        context.strokeStyle = "purple";
        context.moveTo(dust[0].x,dust[0].y);
        for (let i = 1; i <= pushIndex; i++)
            context.lineTo(dust[i].x,dust[i].y);
        context.stroke();
        pushIndex = pushIndex + 1;
    }

    function redrawCanvas() {
        context.clearRect(0, 0, brownianCanvas.clientWidth, brownianCanvas.clientHeight);

        // set background color for the entire thing
        context.fillStyle = "#232323";
        context.fillRect(0, 0, brownianCanvas.clientWidth, brownianCanvas.clientHeight);

        // set background color for the box of gas
        context.fillStyle = "#131313";
        context.fillRect(centerX - 0.5 * boxWidth, centerY - 0.5 * boxHeight, boxWidth, boxHeight);
        
        // graph title
        context.font = 'bold 18pt Calibri';
        context.fillStyle = 'green';
        context.textAlign = 'center';
        context.fillText(simTitle, (brownianCanvas.clientWidth) * .5, 30);
    }

    function drawMotion() {
        if (time >= 50) runFlag = false;
        if (!runFlag) return;

        redrawCanvas();
        index++;
        if (index > 400 && pushIndex === -1) pushIndex = 0; // delay before start drawing trail

        for (let i = 0; i < numBalls - 1; i++)
            for (let j = i + 1; j < numBalls; j++)
                overlap[i][j] = ball[i].isCollidingWith(ball[j]);

        for (let i = 0; i < numBalls - 1; i++)
            for (let j = i + 1; j < numBalls; j++)
                handleCollisionBetween(i, j);

        for (let i = numBalls - 1; i >= 0; i--) {
            ball[i].move();
            ball[i].draw(showMolecules);
        }
        ball[0].draw(true); // Make sure the big ball is always shown
        drawDustTrail();
    }

    function animate() {
        if (!runFlag) return;
        for (let i = 0; i < 5; i++)
            drawMotion();
        requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
</script>
