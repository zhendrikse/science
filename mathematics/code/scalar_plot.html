<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<div class="canvasWrapper" id="scalarContainer">
    <canvas class="applicationCanvas" id="scalarCanvas"></canvas><br/>
</div>
<div id="gui-container"></div>

<script type="module">
    import { Range, AxesParameters, ThreeJsUtils, AxesController, Plot3DView }
        from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";
    import {  Scene, Color, Group, SphereGeometry, MeshStandardMaterial, Vector3, Mesh, Box3 } from "three";

    const canvasContainer = document.getElementById("scalarContainer");
    const canvas = document.getElementById("scalarCanvas");

    const scene = new Scene();
    scene.background = new Color(0x131313);
    const worldGroup = new Group();
    scene.add(worldGroup);

    const params = {
        axesParameters: new AxesParameters({axisLabels: false}),
        opacity: 0.3,
        radius: 0.1
    };

    const axesController = new AxesController({
        parentGroup: worldGroup,
        canvasContainer,
        axesParameters: params.axesParameters,
        scene
    });

    class ControlsGui {
        constructor() {
            const gui = new GUI({width: 300, autoPlace: false});

            gui.add(params, "opacity", 0, 1, .01).name("Opacity").onChange(value => field.setOpacity(value));
            gui.add(params, "radius", 0, 1, .01).name("Radius").onFinishChange(value => field.setRadius(value));

            const axesFolder = gui.addFolder("Axes");
            axesFolder.add(params.axesParameters, 'frame')
                .name("Frame").onChange(value => axesController.updateSettings());
            axesFolder.add(params.axesParameters, 'gridPlanes')
                .name("Layout").onChange(value => axesController.updateSettings());
            axesFolder.add(params.axesParameters, 'annotations')
                .name("Annotations").onChange(value => axesController.updateSettings());
            axesFolder.close();

            document.getElementById("gui-container").appendChild(gui.domElement);
        }
    }

    class Scalar {
        constructor(position, radius, opacity, value) {
            this.position = position;
            this.value = value;
            const geometry = new SphereGeometry(radius, 12, 12);
            const material = new MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: opacity
            });
            this.sphere = new Mesh(geometry, material);
            this.sphere.position.copy(position);
        }

        setColor(color) { this.sphere.material.color.set(color); }
        setOpacity(value) { this.sphere.material.opacity = value; }
        setRadius(radius) {
            this.sphere.geometry.dispose();
            this.sphere.geometry = new SphereGeometry(radius, 12, 12);
        }
    }

    class ScalarField {
        constructor(range, func) {
            this.scalars = [];
            this.opacity = 0.3;

            for (const x of range)
                for (const y of range)
                    for (const z of range) {
                        const position = new Vector3(x, y, z);
                        const value = func(position);
                        const scalar = new Scalar(position, range.stepSize *.25, this.opacity, value);
                        scalar.setColor(this._colorFor(value));
                        this.scalars.push(scalar);
                    }
        }

        _colorFor(value) {
            const t = Math.log1p(value * 10);

            const color = new Color();
            color.setHSL(0.66 * (1 - t), 1.0, 0.5);
            return color;
        }
        setOpacity(v) { this.opacity = v; this.scalars.forEach(s => s.setOpacity(v)); }
        setRadius(r) { this.scalars.forEach(s => s.setRadius(r * .25)); }
    }

    class InstancedScalarField {
        constructor(range, func, {
            baseRadius = 0.1,
            opacity = 0.3
        } = {}) {

            this.range = range;
            this.func = func;
            this.opacity = opacity;
            this.baseRadius = baseRadius;

            // --- prepare sample points ---
            this.positions = [];
            for (const x of range)
                for (const y of range)
                    for (const z of range)
                        this.positions.push(new Vector3(x, y, z));

            this.count = this.positions.length;

            // --- shared geometry & material ---
            this.geometry = new SphereGeometry(1, 12, 12); // unit sphere
            this.material = new MeshStandardMaterial({
                transparent: true,
                opacity: opacity,
                depthWrite: false,
                vertexColors: true
            });

            this.mesh = new InstancedMesh(
                this.geometry,
                this.material,
                this.count
            );

            // --- per-instance color ---
            this.colors = new Float32Array(this.count * 3);
            this.mesh.instanceColor = new InstancedBufferAttribute(this.colors, 3);

            // --- reusable math objects ---
            this._dummyMatrix = new Matrix4();
            this._dummyQuaternion = new Quaternion();
            this._dummyScale = new Vector3();
            this._dummyColor = new Color();

            // --- initialize instances ---
            this.#initializeInstances();
        }

        #initializeInstances() {
            for (let i = 0; i < this.count; i++) {
                const pos = this.positions[i];
                const value = this.func(pos);

                // position + radius
                this._dummyScale.setScalar(this.baseRadius);
                this._dummyMatrix.compose(
                    pos,
                    this._dummyQuaternion,
                    this._dummyScale
                );
                this.mesh.setMatrixAt(i, this._dummyMatrix);

                // color
                this._dummyColor.copy(this._colorFor(value));
                this._dummyColor.toArray(this.colors, i * 3);
            }

            this.mesh.instanceMatrix.needsUpdate = true;
            this.mesh.instanceColor.needsUpdate = true;
        }

        // --- perceptueel betere kleurmapping ---
        _colorFor(value) {
            const t = MathUtils.clamp(value, 0, 1);
            const color = new Color();
            color.setHSL(0.66 * (1 - t), 1.0, 0.5);
            return color;
        }

        // ===================== API =====================

        setOpacity(v) {
            this.opacity = v;
            this.material.opacity = v;
        }

        setRadius(r) {
            this.baseRadius = r;

            for (let i = 0; i < this.count; i++) {
                const pos = this.positions[i];
                this._dummyScale.setScalar(r);

                this._dummyMatrix.compose(
                    pos,
                    this._dummyQuaternion,
                    this._dummyScale
                );
                this.mesh.setMatrixAt(i, this._dummyMatrix);
            }

            this.mesh.instanceMatrix.needsUpdate = true;
        }

        updateValues(time, valueFunc) {
            for (let i = 0; i < this.count; i++) {
                const pos = this.positions[i];
                const value = valueFunc(pos, time);

                this._dummyColor.copy(this._colorFor(value));
                this._dummyColor.toArray(this.colors, i * 3);
            }

            this.mesh.instanceColor.needsUpdate = true;
        }
    }


    // Temperature at center
    function temperatureAt(position, t) {
        const rSquared = position.lengthSq();
        const tEffective = Math.max(t, 0.01);
        const inv = 1 / Math.sqrt(4 * Math.PI * kappa * tEffective);
        return inv * Math.exp(-rSquared / (4 * kappa * tEffective));
    }

    // Temperature on edge
    // const source = new THREE.Vector3(3, 0, 0);
    // function temperatureAt(pos, t) {
    //     const r2 = pos.clone().sub(source).lengthSq();
    //     return Math.exp(-r2 / (4 * kappa * t));
    // }

    const field = new ScalarField(new Range(-3, 3, .4), position => Math.exp(-0.3 * position.lengthSq()));
    field.scalars.forEach(scalar => worldGroup.add(scalar.sphere));

    const boundingBox = new Box3();
    boundingBox.setFromObject( worldGroup );

    axesController.createFromBoundingBox(boundingBox);

    const plot3D = new Plot3DView(scene, canvas, boundingBox);
    plot3D.frame(ThreeJsUtils.scaleBox3(boundingBox, .9));
    const gui = new ControlsGui();

    // Resizing for mobile devices
    function resize() {
        ThreeJsUtils.resizeRendererToCanvas(plot3D.renderer, plot3D.camera);
        axesController.resize();
    }
    window.addEventListener("resize", resize);
    resize();

    let time = 0;
    const kappa = 0.3;

    function animate() {
        requestAnimationFrame(animate);

        time += 0.02;

        field.scalars.forEach((scalar) => {
            const T = temperatureAt(scalar.position, time + 0.05);
            scalar.setColor(field._colorFor(T));
        });

        axesController.render(plot3D.camera);
        plot3D.render();
    }
    animate();
</script>
