<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<canvas id="myCanvas" width="600" height="600"></canvas>
<h1>Graph</h1>
<canvas id="graphCanvas" width="600" height="300" style="background-color: #131313"></canvas>

<script type="module">
    import * as THREE from "three";
    import { Ball} from 'https://www.hendrikse.name/science/js/three-js-extensions.js';

    // --- Scene setup ---
    const canvas = document.getElementById("myCanvas");
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x131313);

    const g = 9.8; // gravitational constant

    const camera = new THREE.PerspectiveCamera(45, canvas.clientWidth/canvas.clientHeight, 0.1, 100);
    camera.position.set(15, 15, 30);
    camera.lookAt(0, 5, 0);

    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);

    scene.add(new THREE.HemisphereLight(0xffffff,0x222222,0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);
    renderer.shadowMap.enabled = true;
    dirLight.castShadow = true;


    // --- Curve for slinky spring ---
    class SpringCurve extends THREE.Curve {
        constructor(position, axis, coils=25, radius=0.4, waveAmp=0.05, wavePhase=0){
            super();
            this.start = position.clone();
            this.coils = coils;
            this.axis = axis;
            this.radius = radius;
            this.waveAmp = waveAmp;
            this.wavePhase = wavePhase;
        }

        updateAxis = (newAxis) => this.axis.copy(newAxis);

        getPoint(t){
            const length = this.axis.length();
            const angle = t * this.coils * Math.PI * 2;
            const x = Math.cos(angle) * this.radius;
            const y = Math.sin(angle) * this.radius;

            // Longitudinal wave across spring
            const z = t * length + this.waveAmp * Math.sin(Math.PI * t) * Math.sin(2 * Math.PI * t * 3 - this.wavePhase);

            const point = new THREE.Vector3(x, y, z);
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), this.axis.clone().normalize());
            point.applyQuaternion(quaternion);

            return point.add(this.start);
        }
    }

    export class SlinkySpring {
        constructor(parent, position, axis, {
            k=200,
            color=0x00ffff,
            coils=30,
            longitudinalOscillation=false,
            tubularSegments=400,
            radialSegments=12,
            radius=0.5,
            coilRadius=0.075
        } = {}) {
            this.longtudinalOscillation = longitudinalOscillation;
            this.radius = radius;
            this.curve = new SpringCurve(position, axis, coils, radius);
            this.tubularSegments = tubularSegments;
            this.radialSegments = radialSegments;
            this.coilRadius = coilRadius;
            this.restLength = axis.length();
            this.k = k;
            this.position = position;
            this.axis = axis;

            this.geometry = new THREE.TubeGeometry(this.curve, tubularSegments, coilRadius, radialSegments, false);
            const material = new THREE.MeshStandardMaterial({color: color, metalness:0.3, roughness:0.4});
            this.spring = new THREE.Mesh(this.geometry, material);
            parent.add(this.spring);
        }

        #regenerateTube() {
            this.spring.geometry.dispose();
            this.spring.geometry = new THREE.TubeGeometry(
                this.curve, this.tubularSegments, this.coilRadius, this.radialSegments, false
            );
        }

        updateAxis(newAxis) {
            this.axis = newAxis;
            this.curve.updateAxis(this.axis);
            this.longtudinalOscillation ?
                this.#updateWithLongitudinal() :
                this.#updateWithoutLongitudinal();
        }

        update = (time) => this.curve.wavePhase = time * 4;

        #updateWithoutLongitudinal() {
            this.#regenerateTube();
        }

        #updateWithLongitudinal(time) {
            // Longitudinal wave amplitude coupled to spring elongation
            const displacement = this.axis.y - this.curve.start.y;
            this.curve.waveAmp = Math.min(Math.abs(displacement) / 10, 0.3); // max amplitude 0.3
            this.#regenerateTube();
        }

        force = () => -this.k * this.displacement();
        displacement = () => this.restLength - this.axis.length();
    }

    // --- Plafond ---
    // const ceilingSize = 50;
    // const ceilingGeometry = new THREE.PlaneGeometry(ceilingSize, ceilingSize);
    // const ceilingMaterial = new THREE.MeshStandardMaterial({
    //     color: 0x8a8a8a,
    //     metalness: 0.05,
    //     roughness: 0.95,
    //     side: THREE.DoubleSide
    // });
    // ceilingMaterial.bumpScale = 0.05;
    //
    // const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    //
    // // horizontal plane
    // ceiling.rotation.x = Math.PI / 2;
    // ceiling.position.y = start.y;
    //
    // scene.add(ceiling);
    // ceiling.receiveShadow = true;

    // Constants and parameters



    // Spring
    const suspensionPoint = new THREE.Vector3(0, 15, 0);
    const axis = new THREE.Vector3(0, -10, 0);
    const slinky = new SlinkySpring(scene, suspensionPoint, axis, {k:200, length:15, longitudinalOscillation: true});

    // Ball
    const ballPosition = new THREE.Vector3(
        (Math.random() - 0.5) * 0.5,  // ±0.25 in X
        0,
        (Math.random() - 0.5) * 0.5   // ±0.25 in Z
    );
    const ball = new Ball(scene, ballPosition, 10);
    slinky.updateAxis(ball.position());

    // --- Mouse click & drag ---
    let dragging = false;
    let mouseY = 0;
    canvas.addEventListener('mousedown', e => {
        const rect = canvas.getBoundingClientRect();
        mouseY = ((e.clientY - rect.top) / rect.height) * 2 - 1; // niet exact nodig voor nu
        dragging = true;
    });
    canvas.addEventListener('mouseup', e => dragging = false);
    canvas.addEventListener('mousemove', e => {
        if(dragging){
            const rect = canvas.getBoundingClientRect();
            const x = ((e.clientX - rect.left)/rect.width - 0.5) * 20; // scale to scene
            const y = 10 - ((e.clientY - rect.top) / rect.height) * 20;
            ball.shiftTo(new THREE.Vector3(x, y, 0));
        }
    });

    const graphCanvas = document.getElementById("graphCanvas");
    const graphContext = graphCanvas.getContext("2d");

    const maxPoints = 300;
    const KE = [], PE = [], E  = [], Y = []; // kinetic, potential, and total energy, and position

    function drawGraph() {
        graphContext.clearRect(0,0,graphCanvas.width,graphCanvas.height);

        const scaleY = 0.1;  // pas aan
        const offsetY = graphCanvas.height * 0.9;

        function drawLine(data, color) {
            graphContext.beginPath();
            graphContext.strokeStyle = color;
            data.forEach((v,i)=>{
                const x = i * graphCanvas.width / maxPoints;
                const y = offsetY - v * scaleY;
                if(i===0) graphContext.moveTo(x,y);
                else graphContext.lineTo(x,y);
            });
            graphContext.stroke();
        }

        drawLine(KE, "red");      // kinetisch
        drawLine(PE, "lime");     // potentieel
        drawLine(E,  "cyan");    // totaal
        drawLine(Y, "yellow");     // position
    }

    function force(kHorizontal = 100) { // horizontal spring constant
        const forceX = -kHorizontal * ball.position().x;
        const forceY = slinky.force() - ball.mass * g;
        const forceZ = -kHorizontal * ball.position().z;
        return new THREE.Vector3(forceX, forceY, forceZ);
    }

    function updateGraphData() {
        const springExtension = slinky.displacement();
        const potentialSpring = 0.5 * slinky.k * springExtension * springExtension;
        const potentialGravity = ball.mass * g * ball.position().y;
        KE.push(ball.kineticEnergy());
        PE.push(potentialSpring + potentialGravity);
        E.push(ball.kineticEnergy() + potentialSpring + potentialGravity);
        Y.push((5 + ball.position().y) * 100); // scale
    }

    function shiftGraph() {
        if (Y.length > maxPoints) Y.shift();
        if (KE.length > maxPoints) {
            KE.shift();
            PE.shift();
            E.shift();
        }
    }

    const dt = 0.02;
    let time = 0;
    function animate(){
        requestAnimationFrame(animate);
        time += dt;
        if (!dragging) ball.updateWith(force(), dt);
        slinky.updateAxis(ball.position().sub(suspensionPoint.clone()));
        slinky.update(time); // Time parameter needed when longitudinal oscillation = true
        renderer.render(scene, camera);
        updateGraphData();
        shiftGraph();
        drawGraph();
    }

    animate();

    // --- interactive: spring hardening / softening ---
    window.addEventListener('keydown', e => {
        if(e.key==='ArrowUp') slinky.k +=20;
        if(e.key==='ArrowDown') slinky.k -=20;
        slinky.k = Math.max(20, slinky.k);
        console.log("k =", slinky.k);
    });
</script>

