<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<canvas class="applicationCanvas" id="quiverCanvas"></canvas><br/>

<script type="module">
    import * as THREE from "three";
    import { VectorField, Arrow, Vector, Ball}
        from 'https://www.hendrikse.name/science/js/three-js-extensions.js';

    const canvas = document.getElementById("quiverCanvas");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x131313);
    const worldGroup = new THREE.Group();
    scene.add(worldGroup);

    const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true
    });
    renderer.setPixelRatio(window.devicePixelRatio);

    const aspect = canvas.clientWidth / canvas.clientHeight;

    const x_max = 2,
        x_min = -x_max,
        y_max = 0.75 * x_max,
        y_min = -y_max;

    const camera = new THREE.OrthographicCamera(
        x_min, x_max,
        y_max, y_min,
        -10, 10
    );

    camera.position.set(0, 0, 5);
    camera.lookAt(0, 0, 0);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(3, 5, 4);
    scene.add(dir);

    function updateCamera() {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        const aspect = w / h;

        const viewHeight = y_max - y_min;
        const viewWidth  = viewHeight * aspect;

        camera.top    =  viewHeight / 2;
        camera.bottom = -viewHeight / 2;
        camera.right  =  viewWidth / 2;
        camera.left   = -viewWidth / 2;

        camera.updateProjectionMatrix();
    }

    class DemoVectorField extends VectorField {
        constructor() {
            super();
        }

        sample(position, radius=.75, a=new Vector(1, .5, 0), b=new Vector(-1, -.5, 0), c=new Vector(-1, .5, 0)) {
            if (a.x - radius <= position.x &&
                position.x <= a.x + radius &&
                a.y - radius <= position.y &&
                position.y <= a.y + radius)
            {
                const theta = Math.atan2((position.y - a.y), (position.x - a.x));
                return new Vector(-Math.sin(theta), Math.cos(theta), 0);
            } else if (b.x - radius <= position.x &&
                position.x <= b.x + radius &&
                b.y - radius <= position.y &&
                position.y <= b.y + radius)
            {
                const theta = Math.atan2((position.y - b.y), (position.x - b.x));
                return new Vector(-Math.cos(theta), -Math.sin(theta), 0);
            } else if (c.x - radius <= position.x &&
                position.x <= c.x + radius &&
                c.y - radius <= position.y &&
                position.y <= c.y + radius)
            {
                const theta = Math.atan2((position.y - c.y), (position.x - c.x));
                return new Vector(Math.cos(theta), Math.sin(theta), 0);
            } else if ((x_max - position.x <= 0.2 || position.x - x_min <= 0.2) &&
                (y_max - position.y <= 0.2 || position.y - y_min <= 0.2))
            {
                const vx = (x_max - position.x <= 0.2) ? -1 : 1;
                const vy = (y_max - position.y <= 0.2) ? -1 : 1;
                return new Vector(vx, vy, 0)
            } else if (x_max - position.x <= 0.2)
                return new Vector(0, 1, 0);
            else if (position.x - x_min <= 0.2)
                return new Vector(0, -1, 0);
            else if (y_max - position.y <= 0.2)
                return new Vector(-1, 0, 0);
            else if (position.y - y_min <= 0.2)
                return new Vector(1, 0, 0);
            else
                return new Vector(0.5, 1.5, 0);
        }
    }

    const vectorField = new DemoVectorField();
    const arrows = [];
    for (let x = x_min; x <= x_max; x += 0.25)
        for (let y = y_min; y <= y_max; y += 0.25) {
            const axis = vectorField.sample(new Vector(x, y, 0)).multiplyScalar(.2),
                shift = axis.clone().multiplyScalar(-0.1),
                position = new Vector(x, y, 0).add(shift),
                arrow = new Arrow(position, axis, {color: "yellow", opacity: 0, round: true, shaftWidth: 0.05});
            arrows.push(arrow);
            worldGroup.add(arrow);
        }

    const particles = [];
    for (let x = x_min; x <= x_max; x += 0.25)
        for (let y = y_min; y <= y_max; y += 0.25)
            particles.push(new Ball(worldGroup, new Vector(x, y, 0), {radius: 0.05, color: "orange"}));

    const source = new Ball(worldGroup, new Vector(-1, 0.5, 0), {radius: 0.25, opacity: 0.4, color: "red"});
    const sink = new Ball(worldGroup, new Vector(-1, -0.5, 0), {radius: 0.25, opacity: 0.4, color: "green"});
    const curl = new Ball(worldGroup, new Vector(1, 0.5, 0), {radius: 0.25, opacity: 0.4, color: "cyan"});

    function onResize() {
        const rect = canvas.getBoundingClientRect();

        const width  = Math.round(rect.width);
        const height = Math.round(rect.height);

        renderer.setSize(width, height, true); // <-- true is cruciaal

        const aspect = width / height;
        const viewHeight = y_max - y_min;
        const viewWidth  = viewHeight * aspect;

        camera.top    =  viewHeight / 1.75;
        camera.bottom = -viewHeight / 1.75;
        camera.right  =  viewWidth / 1.75;
        camera.left   = -viewWidth / 1.75;

        camera.updateProjectionMatrix();
    }


    window.addEventListener("resize", onResize);
    onResize();

    const dt = 0.0025,
        d_o = 0.0025;
    let time = 0,
        opacity = 0;

    function animate() {
        requestAnimationFrame(animate);

        time += dt;

        // update particles
        for (const particle of particles) {
            const pos = particle.position();
            const vel = vectorField.sample(pos);
            pos.addScaledVector(vel, dt);
            particle.shiftTo(pos);
        }

        // fading arrows
        if (opacity < 1 && time > 0.1) {
            opacity += d_o;
            for (const arrow of arrows)
                arrow.updateOpacity(opacity);
        }

        renderer.render(scene, camera);
    }

    animate();
</script>
