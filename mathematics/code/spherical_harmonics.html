<style>
    #surface-equation {
        position: absolute;
        margin-top: 10px;
        margin-left: 10px;
        width: 100%;
        max-width: 100%;
        font-size: 14px;
        color: yellow;
        z-index: 10;
    }

    #surface-equation .mjx-chtml {
        text-align: left;
        font-size: clamp(14px, 3.5vw, 10px);
        margin: 0 auto;
    }
</style>
<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<div id="surface-equation"></div>
<div class="canvasWrapper" id="complexPlotContainer">
    <canvas class="applicationCanvas" id="complexPlotCanvas"></canvas><br/>
</div>
<div id="gui-container"></div>

<script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.0/lib/browser/math.js" type="text/javascript"></script>

<script type="module">
    import { Scene, Color, Group, Mesh } from "three";
    import { AxesController, ThreeJsUtils, Plot3DView, AxesParameters }
        from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";
    import { Surface, SurfaceView, CurvatureContoursView, SurfaceSpecification, IsoparametricContoursView,
        LiteralStringBasedSurfaceDefinition, ViewParameters, ColorMapper, HeightColorMapper, ContourType  }
        from 'https://www.hendrikse.name/science/js/3d-surface-components.js';

    const canvasContainer = document.getElementById("complexPlotContainer");
    const canvas = document.getElementById("complexPlotCanvas");

    const scene = new Scene();
    scene.background = new Color(0x131313);
    const worldGroup = new Group();
    scene.add(worldGroup);

    export class BasicSurfaceView extends SurfaceView {
        constructor(parentGroup, surface, surfaceParameters) {
            super(parentGroup, surface);
            this._contours = null;
            this._contourType = surfaceParameters.contourParameters.contourType;
            this._colorMapper = null;
            this._colorMode = surfaceParameters.colorMode;

            this.geometry = surface.createGeometryWith(surfaceParameters.resolution);
            this.material = this.material(surfaceParameters.wireframe, surfaceParameters.opacity);
            this.mesh = new Mesh(this.geometry, this.material);
            this.group.add(this.mesh);

            this.#setContourMode(surfaceParameters.contourParameters);
            this.updateContours(surfaceParameters.contourParameters);
            this.#setColorMode(surfaceParameters);
            this.updateColor(surfaceParameters);

            this.updateOpacity(surfaceParameters.opacity);

            if (surfaceParameters.normals) this.addNormalsWith({});
        }

        #setContourMode(contourParameters) {
            this._contourType = contourParameters.contourType;
            switch (this._contourType) {
                case ContourType.NONE:
                    this._contours = null;
                    break;
                case ContourType.CURVATURE:
                    this._contours = new CurvatureContoursView(this.group, this.surface);
                    this.registerChild(this._contours);
                    break;
                case ContourType.ISO_PARAMETRIC:
                    this._contours = new IsoparametricContoursView(this.group, this.surface);
                    this.registerChild(this._contours);
                    break;
            }
        }

        #setColorMode(surfaceParameters) {
            this._colorMode = surfaceParameters.colorMode;
            switch (this._colorMode) {
                case ColorMapper.ColorMode.HEIGHT:
                    this._colorMapper = new HeightColorMapper({ useBaseColor: false });
                    break;
                case ColorMapper.ColorMode.MEAN:
                    this._colorMapper = new CurvatureColorMapper(this.surface);
                    break;
                case ColorMapper.ColorMode.K1:
                case ColorMapper.ColorMode.K2:
                    this._colorMapper = new PrincipalCurvatureColorMapper(this.surface, { which: mode, scale: 3.0 });
                    break;
                case ColorMapper.ColorMode.GAUSSIAN:
                    this._colorMapper =
                        new GaussianCurvatureColorMapper(this.surface, {
                            scale: 3.0 // Scale determines how "fast" the color saturates. For sphere/torus -> [1 .. 3]
                        });
                    break;
                case ColorMapper.ColorMode.BASE:
                default:
                    this._colorMapper = new HeightColorMapper({ baseColor: this.baseColor, useBaseColor: true});
            }
        }

        updateContours(contourParameters) {
            this._contours?.clear();

            if (contourParameters.contourType !== this._contourType)
                this.#setContourMode(contourParameters);

            this._contours?.buildWith(contourParameters);
        }

        updateColor(surfaceParameters) {
            if (this._colorMode !== surfaceParameters.colorMode)
                this.#setColorMode(surfaceParameters);

            this._colorMapper.apply(this.geometry);
        }

        updateOpacity = (value) => this.material.opacity = value;

        resampleWith(resolution) {
            this.geometry.dispose();
            this.geometry = this.surface.createGeometryWith(resolution);
            this.mesh.geometry = this.geometry;
            this.colorMapper.apply(this.geometry);
        }

        toggleWireframe = (value) => this.material.wireframe = value;
    }

    class ControlsGui {
        constructor() {
            const gui = new GUI({width: 300, autoPlace: false});
            this.#createContourFolder(gui);
            this.#createAxesFolder(gui);
            document.getElementById("gui-container").appendChild(gui.domElement);
        }

        #createAxesFolder(parentFolder) {
            const axesFolder = parentFolder.addFolder("Axes");
            const dummyToggle = {gridPlanes: true};
            axesFolder.add(axesParameters, 'frame')
                .name("Frame").onChange(value => axesController.updateSettings());
            axesFolder.add(dummyToggle, 'gridPlanes')
                .name("Layout").onChange(value => {
                axesParameters.xyPlane = value;
                axesParameters.xzPlane = value;
                axesParameters.yzPlane = value;
                axesController.updateSettings();
            });
            axesFolder.add(axesParameters, 'annotations')
                .name("Annotations").onChange(value => axesController.updateSettings());
            axesFolder.close();
        }

        #createContourFolder(folder) {
            const contourFolder = folder.addFolder("Contours");
            contourFolder.add(surfaceParams.contourParameters, "contourType", Object.values(ContourType))
                .name("Contour type")
                .onChange(value => surfaceController.updateContours(surfaceParams.contourParameters));
            contourFolder.add(surfaceParams.contourParameters, "uCount", 1, 50, 1)
                .name("U contours")
                .onFinishChange(value => surfaceController.updateContours(surfaceParams.contourParameters));
            contourFolder.add(surfaceParams.contourParameters, "vCount", 1, 50, 1)
                .name("V contours")
                .onFinishChange(value => surfaceController.updateContours(surfaceParams.contourParameters));
            contourFolder.close();
        }
    }

    class SurfaceController {
        constructor(surfaceData, surfaceParameters) {
            const surfaceDefinition = new LiteralStringBasedSurfaceDefinition(new SurfaceSpecification(surfaceData));
            this._surface = new BasicSurfaceView(worldGroup, new Surface(surfaceDefinition), surfaceParameters);

            this.updateContours(surfaceParameters.contourParameters);
            this.updateColors(surfaceParameters);
        }

        updateColors = (surfaceParameters) => this._surface.updateColor(surfaceParameters);
        updateContours = (contourParameters) => this._surface.updateContours(contourParameters);
        surfaceBoundingBox = () => this._surface.boundingBox();
    }


    const axesParameters = new AxesParameters();
    const surfaceParams = new ViewParameters();

    const surfaceData = {
        parametrization: {
            xFn: "(sin(4 * u)^4 + cos(4 * u)^4 + sin(4 * phi)^4 + cos(4 * phi)^4) * sin(u) * cos(v)",
            yFn: "(sin(4 * u)^4 + cos(4 * u)^4 + sin(4 * phi)^4 + cos(4 * phi)^4) * cos(u)",
            zFn: "(sin(4 * u)^4 + cos(4 * u)^4 + sin(4 * phi)^4 + cos(4 * phi)^4) * sin(u) * sin(v)"
        },
        intervals: [["-pi", "pi"], ["0", "pi"]]
    };

    const axesController = new AxesController({
        parentGroup: worldGroup,
        canvasContainer: canvasContainer,
        axesParameters: axesParameters,
        scene: scene
    });
    const gui = new ControlsGui();
    const surfaceController = new SurfaceController(surfaceData, surfaceParams);

    // Scale scene according to current surface
    axesController.createFromBoundingBox(surfaceController.surfaceBoundingBox());
    const plot3D = new Plot3DView(scene, canvas, surfaceController.surfaceBoundingBox());
    plot3D.frame(ThreeJsUtils.scaleBox3(surfaceController.surfaceBoundingBox(), .9));

    // Resizing for mobile devices
    function resize() {
        ThreeJsUtils.resizeRendererToCanvas(plot3D.renderer, plot3D.camera);
        axesController.resize();
    }
    window.addEventListener("resize", resize);
    resize();

    function animate() {
        requestAnimationFrame(animate);
        plot3D.render();
        axesController.render(plot3D.camera);
    }
    animate();
</script>
