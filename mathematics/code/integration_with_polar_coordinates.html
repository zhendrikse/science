<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<div class="titleDiv" id="integral-title"></div>
<div class="canvasWrapper" id="container">
    <canvas class="applicationCanvas" id="integrationCanvas"></canvas><br/>
</div>
<div class="guiContainer" id="gui-container"></div>

<script type="module">
    import * as THREE from "three";
    import { Plot3D } from 'https://www.hendrikse.name/science/js/3d-surface-components.js';
    import { Axes, MatlabAxesLayout, MatlabAnnotations, AxesParameters }
        from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";

    const scene = new THREE.Scene();
    const worldGroup = new THREE.Group();
    scene.add(worldGroup);

    const canvasContainer = document.getElementById("container");
    const canvas = document.getElementById("integrationCanvas");

    const params = {
        axesParameters: new AxesParameters({xyPlane: false, yzPlane: false}),
        thetaMin: 0,
        thetaMax: 180,
        phiMin: 0,
        phiMax: 360,
        opacity: 0.35
    };

    class ControlsGui {
        constructor(axesLayout, annotations) {
            const gui = new GUI({width: 300, autoPlace: false});

            gui.add(params, "thetaMin", 0, 180, 1)
                .name("θ_min")
                .onChange(value => { updateVisibility(); updateIntegral(); });

            gui.add(params, "thetaMax", 0, 180, 1)
                .name("θ_max)")
                .onChange(value => { updateVisibility(); updateIntegral(); });

            gui.add(params, "phiMin", 0, 360, 1)
                .name("φ_min")
                .onChange(value => { updateVisibility(); updateIntegral(); });

            gui.add(params, "phiMax", 0, 360, 1)
                .name("φ_max")
                .onChange(value => { updateVisibility(); updateIntegral(); });

            gui.add(params, "opacity", 0, 1, .01)
                .name("Opacity")
                .onChange(value => { cells.forEach(cell => cell.material.opacity = parseFloat(value)); });

            const axesFolder = gui.addFolder("Axes");
            axesFolder.add(params.axesParameters, 'axesLines')
                .name("Axes").onChange(value => value ? axesLayout.showAxes() : axesLayout.hideAxes());
            axesFolder.add(params.axesParameters, 'axesLabels')
                .name("Axes labels").onChange(value => annotations.visible = value);
            axesFolder.add(params.axesParameters, 'xyPlane')
                .name("XY plane").onChange(value => value ? axesLayout.showXY() : axesLayout.hideXY());
            axesFolder.add(params.axesParameters, 'xzPlane')
                .name("XZ plane").onChange(value => value ? axesLayout.showXZ() : axesLayout.hideXZ());
            axesFolder.add(params.axesParameters, 'yzPlane')
                .name("YZ plane").onChange(value => value ? axesLayout.showYZ() : axesLayout.hideYZ());
            axesFolder.close();

            document
                .getElementById("gui-container")
                .appendChild(gui.domElement);
        }
    }

    // Axes
    const axes = new Axes();
    worldGroup.add(axes);
    const axesLayout = new MatlabAxesLayout(2.2, 10);
    const annotations = new MatlabAnnotations(canvasContainer, 2.2, 10);
    axes.setLayout(axesLayout);
    axes.setAnnotations(annotations);
    annotations.visible = true;

    const plot3D = new Plot3D(canvas, scene, axes);
    const bbox = new THREE.Box3();
    bbox.setFromObject( worldGroup );
    plot3D.fitToBoundingBox(bbox, {padding: 1.0, translationY: -1.0});
    const gui = new ControlsGui(axesLayout, annotations);

    const R = 1, da = 0.05;
    const f = (theta, phi) => theta * theta * (phi - Math.PI) * (phi - Math.PI);
    const cells = [];
    let values = [];

    function createCell(theta, phi) {
        const val = f(theta, phi);
        values.push(val);

        const mesh = new THREE.Mesh(
            new THREE.BoxGeometry(da, da, da),
            new THREE.MeshPhongMaterial({ transparent:true, opacity:params.opacity })
        );
        const position = Axes.toCartesian(R, theta, phi);
        mesh.position.copy(new THREE.Vector3(position.x, position.z + R, position.y));
        mesh.userData = {theta:theta, phi:phi, val};
        scene.add(mesh);
        cells.push(mesh);
    }

    for (let theta = 0; theta <= Math.PI; theta += da)
        for (let phi = 0; phi <= 2 * Math.PI; phi += da)
            createCell(theta, phi);


    const minF = Math.min(...values), maxF = Math.max(...values);
    cells.forEach(cell => {
        const t = (cell.userData.val - minF) / (maxF - minF);
        cell.material.color.setRGB(1 - t, t, 0);
    });

    function updateVisibility() {
        cells.forEach(cell => {
            const t = cell.userData.theta, p = cell.userData.phi;
            cell.visible = (
                t >= THREE.MathUtils.degToRad(params.thetaMin) &&
                t <= THREE.MathUtils.degToRad(params.thetaMax) &&
                p >= THREE.MathUtils.degToRad(params.phiMin) &&
                p <= THREE.MathUtils.degToRad(params.phiMax)
            );
        });
    }

    function integrate() {
        let sum = 0;
        cells.forEach(cell => { if (cell.visible) sum += cell.userData.val * Math.sin(cell.userData.theta); });
        return sum * R * R * da * da;
    }

    const updateIntegral = () =>
        document.getElementById("integral-title").textContent = "Integral evaluates to: " + integrate().toFixed(2);

    function animate() {
        requestAnimationFrame(animate);
        plot3D.render();
    }

    updateVisibility();
    updateIntegral();
    animate();

</script>

