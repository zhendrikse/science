<style>
    canvas {
        background: #131313;
        display: block;
        width: 100%;
        aspect-ratio: 19 / 12;
        max-width: 800px;
        margin: auto;
    }
</style>

<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<canvas class="applicationCanvas" id="planetsCanvas" style="background: #131313; aspect-ratio: 19 / 12;"></canvas><br/>
<div class="guiContainer" id="gui-container"></div>

<script type="module">
    import { Group, SphereGeometry, MeshPhongMaterial, Mesh, TextureLoader, Color,
        Scene, PerspectiveCamera, Vector3, WebGLRenderer, AmbientLight, PointLight,
        RingGeometry, DoubleSide, Quaternion } from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { ThreeJsUtils, SkyDome, Trail } from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm";

    const planetsCanvas = document.getElementById('planetsCanvas');
    planetsCanvas.focus();
    console.clear();

    const textureLoader = new TextureLoader();
    textureLoader.setCrossOrigin("anonymous");

    let dt = 1;

    const AU = 1.496 * 1E11;   // astronomical unit
    const EARTH_SEMI_MAJOR_AXIS = 149598261.;

    const PLANET_SCALE = 0.25E7;  // meters → render units (radius), planet sizes are shrunk by this factor
    const SUN_SCALE = 100 * PLANET_SCALE;
    const ORBIT_SCALE  = 40;    // additional orbit compression factor for nice visual representation
    const DISTANCE_SCALE = AU / ORBIT_SCALE;
    const toRenderUnits = (vector) => vector.clone().multiplyScalar(1000 / DISTANCE_SCALE);

    const planetaryScene = new Scene();
    // --- CAMERA ---
    const planetCamera = new PerspectiveCamera(60, 19/20, .1, 5000);
    planetCamera.position.set(60, 20, 60);
    planetCamera.lookAt(0, 0, 0);

    const planetRenderer = new WebGLRenderer( {antialias: true, canvas: planetsCanvas, alpha: false} );
    planetRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    planetRenderer.shadowMap.enabled = false;
    planetRenderer.setAnimationLoop( animate );

    // Resizing for mobile devices
    ThreeJsUtils.resizeRendererToCanvas(planetRenderer, planetCamera);
    window.addEventListener('resize', () => {
        ThreeJsUtils.resizeRendererToCanvas(planetRenderer, planetCamera);
    });

    const controls = new OrbitControls(planetCamera, planetsCanvas);
    controls.minDistance = 20;
    controls.maxDistance = 800;
    controls.target.set(0, 0, 0);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    const skyDome = new SkyDome({skyRadius: 4500, glowStarCount: 500});
    planetaryScene.add(skyDome);

    // Abstract base class for celestial bodies, hence should _not_ be instantiated directly!
    //const TEXTURES_PATH = "https://www.hendrikse.name/science/astrophysics/code/textures/";
    const TEXTURES_PATH = "textures/";
    class CelestialBody extends Group {
        constructor(bodyData, scale, {bumpScale=0.005, identicalBumpMap=false, orbitPointsCount=10000} = {}) {
            super();
            this._orbitPointsCount = orbitPointsCount;
            this._name = bodyData.name;
            this._radius = bodyData.radius;
            this._mass = bodyData.mass;
            this._tilt = bodyData.tilt;
            this._timescale = 1;
            this._spin = bodyData.spin;

            const geometry = new SphereGeometry(bodyData.radius / scale, 32, 32);
            const mesh = new Mesh(geometry, this._material(bumpScale, identicalBumpMap));
            this.add(mesh);

            this._tmpAxis = new Vector3();
            this._tmpQuat = new Quaternion();
            this._trailAccumulator = 0;
            this._trailStep = 1; // 1 unity of time
            this._trail = null;
            this._coordinates = [];
        }

        get tilt() { return this._tilt; }
        get radius() { return this._radius; }
        get mass() { return this._mass; }

        _orbitIndex(t) { return Math.floor(t / this._timescale) % this._coordinates.length; }

        _linSpace(start, stop, num) {
            const result = [];
            const step = (stop - start) / (num - 1);

            for (let i = 0; i < num - 1; i++)
                result.push(start + i * step);

            result.push(stop); // include last point as well
            return result;
        }

        // Newton-Raphson to calculate elliptic orbit
        _orbit(meanAnomaly, eccentricity, a, inclination, ascension, acc=1.e-2) {
            // nPoints = number of orbit coordinates generated (affects temporal accuracy - dt(real)=365.25*86400/n (in seconds))
            const nPoints = this._orbitPointsCount;
            const range = this._linSpace(meanAnomaly, 2 * Math.PI + meanAnomaly, nPoints);

            let eccAnom = range.slice();
            let eccAnomOld = new Array(nPoints);

            let maxDiff = Infinity;

            while (maxDiff > acc) {
                maxDiff = 0;
                eccAnomOld = eccAnom.slice(); // copy array

                // Newton–Raphson step
                for (let i = 0; i < nPoints; i++) {
                    const f = eccAnomOld[i] - eccentricity * Math.sin(eccAnomOld[i]) - range[i];
                    const fPrime = 1 - eccentricity * Math.cos(eccAnomOld[i]);
                    eccAnom[i] = eccAnomOld[i] - f / fPrime;
                    maxDiff = Math.max(maxDiff, Math.abs(eccAnom[i] - eccAnomOld[i]));
                }
            }

            const points = [];
            for (let i = 0; i < nPoints; i++) {
                const theta = 2 * Math.atan2(
                    Math.sqrt(1 + eccentricity) * Math.sin(eccAnom[i] / 2),
                    Math.sqrt(1 - eccentricity) * Math.cos(eccAnom[i] / 2)
                );

                const r = a * (1 - eccentricity * Math.cos(eccAnom[i]));
                const thetaAsc = theta - ascension;

                const x = (Math.cos(ascension) * Math.cos(thetaAsc) -
                    Math.sin(ascension) *
                    Math.sin(thetaAsc) *
                    Math.cos(inclination));

                const z = (Math.sin(ascension) * Math.cos(thetaAsc) +
                    Math.cos(ascension) *
                    Math.sin(thetaAsc) *
                    Math.cos(inclination));

                const y = Math.sin(theta - ascension) * Math.sin(inclination);

                points.push(new Vector3(x, y, z).multiplyScalar(r));
            }

            return points;
        }

        _material(bumpScale, identicalBumpMap) { throw new Error("Abstract class: implement material!"); }

        _updateTrail(dt) {
            if (!this._trail) return;
            this._trailAccumulator += dt;
            if (this._trailAccumulator >= this._trailStep) {
                this._trail.addPoint(this.getWorldPosition(new Vector3()));
                this._trailAccumulator = 0;
            }
        }

        updateRotation(t) {
            // 1. tilt-quaternion (rotatie van XZ plane → echte as)
            const tiltQuat = new Quaternion();
            tiltQuat.setFromAxisAngle(new Vector3(0, 0, 1), this._tilt);

            // 2. spin-quaternion rond lokale Y
            const spinQuat = new Quaternion();
            spinQuat.setFromAxisAngle(new Vector3(0, 1, 0), this._spin * t);

            // 3. combineer tilt + spin
            this.quaternion.copy(tiltQuat).multiply(spinQuat);
        }

        enableTrail({ maxPoints = 1000, color = 0xffff00 } = {}) {
            this._trail = new Trail({ maxPoints, color });
            this._trailAccumulator = 0;

            if (this.parent)
                this.parent.add(this._trail._line);
        }

        disposeTrail() {
            if (!this._trail) return;
            if (this._trail._line) {
                if (this._trail._line.geometry)
                    this._trail._line.geometry.dispose();
                if (this._trail._line.material)
                    this._trail._line.material.dispose();
                this.remove(this._trail._line);
            }
            this._trail = null;
        }
    }

    class Planet extends CelestialBody {
        constructor(planetData, {bumpScale=0.005, identicalBumpMap=false} = {}) {
            super(planetData, PLANET_SCALE, {bumpScale: bumpScale, identicalBumpMap: identicalBumpMap});
            this._timescale = (planetData.a / EARTH_SEMI_MAJOR_AXIS) ** 1.5; // rotation period w.r.t. Earth

            // create orbit coordinates list for the planet
            this._coordinates = this._orbit(
                planetData.mean_anomaly,
                planetData.e,
                planetData.a,
                planetData.inclination,
                planetData.right_ascension
            );
        }

        _material(bumpScale, identicalBumpMap) {
            const bumpMap = TEXTURES_PATH + this._name + (identicalBumpMap ? "map.jpg" : "bump.jpg");
            return new MeshPhongMaterial({
                map: textureLoader.load(`${TEXTURES_PATH}` + this._name + "map.jpg"),
                bumpMap: textureLoader.load(bumpMap),
                bumpScale: bumpScale,
                shininess: 0
            });
        }

        update(t, dt) {
            this._updateTrail(dt);
            this.updateRotation(t);
        }
    }

    class Satellite extends CelestialBody {
        constructor(moonData, planet, scale) {
            super(moonData, scale);
            this._planet = planet;
            this._angle = 0;
            this._a = moonData.a; // semi-major axis
            this._e = moonData.e;

            this._timescale = moonData.period / 365.25;  // rotation period w.r.t Earth
            this._lock = moonData.tidal_lock;

            this._coordinates = this._orbit(
                moonData.mean_anomaly,
                this._e,
                this._a,
                planet.tilt +
                moonData.inclination,
                moonData.right_ascension);  // create orbit coordinates list for the moon

            this.#centerMoonsOrbitAroundOrigin();
        }

        #centerMoonsOrbitAroundOrigin() {
            const center = new Vector3();
            this._coordinates.forEach(position => center.add(position));
            center.divideScalar(this._coordinates.length);
            this._coordinates.forEach(position => position.sub(center));
        }

        update(t, dt) {
            this._updateTrail(dt);
            if (this._lock) {
                const planetWorldPos = this._planet.getWorldPosition(new Vector3());
                this.lookAt(planetWorldPos);
                // Correct fixed phase fase-offset if needed (texture-orientation)
                this.rotateY(Math.PI); // of rotateZ, afhankelijk van je texture
            } else
                this.updateRotation(t); // gewone spin
        }
    }

    class PlanetMoonSystem extends Group {
        constructor(planet, moons = []) {
            super();
            this._planet = planet;
            this._moons = moons;

            this.add(planet);
            moons.forEach(moon => this.add(moon));

            this._coordinates = planet._coordinates;
        }

        get mass() {
            let M = this._planet.mass;
            for (const moon of this._moons)
                M += moon.mass;
            return M;
        }

        update(t, dt) {
            // 1. barycentric position (sun-centric)
            const baryPosition = this._coordinates[this._planet._orbitIndex(t)].clone();

            // 2. total mass
            const M = this.mass;

            // 3. barycentric correction
            const correction = new Vector3();
            for (const moon of this._moons) {
                const r = moon._coordinates[moon._orbitIndex(t)];
                correction.add(r.clone().multiplyScalar(moon.mass / M));
            }

            // 4. planet position
            this._planet.position.copy(toRenderUnits(baryPosition.clone().sub(correction)));

            // 5. moon positions
            for (const moon of this._moons) {
                const r = moon._coordinates[moon._orbitIndex(t)];
                moon.position.copy(toRenderUnits(baryPosition.clone().add(r)));
            }

            // 6. rotations
            this._planet.update(t, dt);
            for (const moon of this._moons)
                moon.update(t, dt);
        }
    }

    class Sun extends CelestialBody {
        constructor(bodyData, {bumpScale=0.05, identicalBumpMap=true}) {
            super(bodyData, SUN_SCALE, {bumpScale: bumpScale, identicalBumpMap: identicalBumpMap});
        }

        _material(bumpScale, identicalBumpMap) {
            return new MeshPhongMaterial({
                map: textureLoader.load(`${TEXTURES_PATH}sunmap.jpg`),
                bumpMap: textureLoader.load(`${TEXTURES_PATH}sunmap.jpg`),
                emissive: new Color(0xffcc66),
                bumpScale: bumpScale,
                emissiveIntensity: 1.0
            });
        }
    }

    class Moon extends Satellite {
        static DATA = {
            "a": 384399 * 50.,
            "e": 0.0549,
            "inclination": (-23.4 + 5.145) * Math.PI / 180.,
            "right_ascension": -Math.PI / 2.,
            "mean_anomaly": 0.,
            "radius": 1737400,
            "mass": 7.349e+22,  // kg
            "spin": 2 * Math.PI / 708.7341666667,
            "tilt": 0.11641346110802178, // rad
            'period': 27.321, // days
            "tidal_lock": true
        }

        constructor(planet) {
            super(Moon.DATA, planet, PLANET_SCALE);
        }

        _material(bumpScale, identicalBumpMap) {
            return new MeshPhongMaterial({
                map: textureLoader.load(`${TEXTURES_PATH}moonmap1k.jpg`),
                bumpMap: textureLoader.load(`${TEXTURES_PATH}moonbump1k.jpg`),
                bumpScale: 0.05,
                specular: new Color(0x333333),
                emissive: new Color(0x112244),
                emissiveIntensity: 0.05,
                shininess: 3
            });
        }
    }

    class Earth extends Planet {
        constructor(planetData) {
            super(planetData);
            this._name = planetData.name;
            this._timescale = 1; // rotation period w.r.t. Earth

            // create orbit coordinates list for the planet
            this._coordinates = this._orbit(
                planetData.mean_anomaly,
                planetData.e,
                planetData.a,
                planetData.inclination,
                planetData.right_ascension
            );
        }

        _material(bumpScale, identicalBumpMap) {
            return new MeshPhongMaterial({
                map: textureLoader.load(`${TEXTURES_PATH}earthmap1k.jpg`),
                bumpMap: textureLoader.load(`${TEXTURES_PATH}earthbump1k.jpg`),
                bumpScale: 0.05,
                specularMap: textureLoader.load(`${TEXTURES_PATH}earthspec1k.jpg`),
                specular: new Color(0x333333),
                emissive: new Color(0x112244),
                emissiveIntensity: 0.05,
                shininess: 3
            });
        }
    }

    class Saturn extends Planet {
        constructor(planetData) {
            super(planetData, {bumpScale: 0.05, identicalBumpMap: true});

            const innerRingRadius = 1.11 * 60268000;
            const outerRingRadius = 2.9 * 60268000;
            const ringMesh = this.#createRings(
                innerRingRadius / PLANET_SCALE,
                outerRingRadius / PLANET_SCALE);
            this.add(ringMesh);
        }

        #createRings(innerRadius, outerRadius) {
            const geometry = new RingGeometry(innerRadius, outerRadius, 128);
            const texture = new TextureLoader().load(`${TEXTURES_PATH}saturnringcolor.jpg`);
            const material = new MeshPhongMaterial({
                map: texture,
                side: DoubleSide,
                transparent: true,
                opacity: 0.85
            });

            const rings = new Mesh(geometry, material);
            rings.rotation.x = Math.PI / 2; // Ring lies in XY plane → tilt to XZ
            this.rotation.z = this._tilt; // Axial tilt (set only once!)
            return rings;
        }
    }

    class ControlsGui {
        constructor() {
            const controls = new GUI({width: "100%", autoPlace: false});
            document.getElementById("gui-container").appendChild(controls.domElement);

            const settings = {
                dt: 1
            };

            controls.add(settings, 'dt', 0.01, 10, 0.01).name("Time Step (dt)").onChange(value => {
                dt = value;
            });
        }
    }

    const solarSystemGroup = new Group();
    planetaryScene.add(solarSystemGroup);

    const sun = new Sun({
        "radius": 696300000.0,
        "mass": 1.9885440000000002e+30,
        "spin": 3600 * 2.8653290845717256e-06,
        "tilt": 0.1265363707695889
    }, {bumpScale: 0.05, identicalBumpMap: true});
    sun.position.set(0, 0, 0);
    solarSystemGroup.add(sun);
    const sunLight = new PointLight(0xffffff, 2, 0, .1); // intense, no max distance
    sunLight.position.set(0, 0, 0);
    planetaryScene.add(sunLight);
    planetaryScene.add(new AmbientLight(0xffffff, 0.2));

    const earth = new Earth({
        "name": "earth",
        "a": EARTH_SEMI_MAJOR_AXIS,
        "e": 0.01671123,
        "inclination": 0.,
        "right_ascension": 0.,
        "mean_anomaly": 6.2398515744,
        "radius": 6371010, // meters
        "mass": 5.97219e+24,
        "spin": 2 * Math.PI / 24.,
        "tilt": 23 * Math.PI / 180
    });
    const mercury = new Planet({
        "name": "mercury",
        'a': 57909050.,
        'e': 0.205630,
        'inclination': 7 * Math.PI / 180.,
        'right_ascension': 0.8436854966,
        'mean_anomaly': 3.0507657193,
        'radius': 2439.7 * 1e3,
        "mass": 3.302e+23,
        'tilt': 0.1 * Math.PI / 180.,
        "spin": 2 * Math.PI / 4222.6
    }, {bumpScale: 0.005});
    const venus = new Planet({
        "name": "venus",
        'a': 108208000.,
        'e': 0.0067,
        'inclination': 3.39 * Math.PI / 180.,
        'right_ascension': 1.3381895772,
        'mean_anomaly': 0.8746717546,
        'radius': 6051.8 * 1e3,
        "mass": 4.8685e+23,
        'tilt': 177 * Math.PI / 180.,
        'spin':  -2 * Math.PI / 2802.
    }, {bumpScale: 0.005});
    const mars = new Planet({
        "name": "mars",
        'a': 227939100.,
        'e': 0.093315,
        'inclination': 1.85 * Math.PI / 180.,
        'right_ascension': 0.8676591934,
        'mean_anomaly': 0.3378329113,
        'radius': 3393.5 * 1e3,
        "mass": 6.4185e+23,
        'tilt': 25 * Math.PI / 180.,
        'spin': 2 * Math.PI / 24.66
    }, {bumpScale: 0.05});
    const jupiter = new Planet({
        "name": "jupiter",
        'a': 778547200.,
        'e': 0.048775,
        'inclination': 1.31 * Math.PI / 180.,
        'right_ascension': 1.7504400393,
        'mean_anomaly': 0.3284360586,
        'radius': 71400. * 1e3,
        "mass": 1.89813e+27,
        'tilt': 3 * Math.PI / 180.,
        'spin': 2 * Math.PI / 9.93
    }, {bumpScale: 0.02, identicalBumpMap: true});
    const saturn = new Saturn({
        "name": "saturn",
        'a': 1433449370.,
        'e': 0.055723219,
        'inclination': 2.49 * Math.PI / 180.,
        'right_ascension': 1.98,
        'mean_anomaly': 5.5911055356,
        'radius': 60000. * 1e3,
        "mass": 5.68319e+26,
        'tilt': 27 * Math.PI / 180.,
        'spin': 2 * Math.PI / 10.66
    });

    const moon = new Moon(earth);

    const earthMoonSystem = new PlanetMoonSystem(earth, [moon]);
    solarSystemGroup.add(earthMoonSystem);
    earthMoonSystem.update(0, 1); // set initial position
    earth.enableTrail({maxPoints: 450, color: 0x00bbff});

    const noMoonsMercury = new PlanetMoonSystem(mercury);
    solarSystemGroup.add(noMoonsMercury);
    noMoonsMercury.update(0, 1);
    mercury.enableTrail({maxPoints: 230, color: 0xaaff00});

    const noMoonsVenus = new PlanetMoonSystem(venus);
    solarSystemGroup.add(noMoonsVenus);
    noMoonsVenus.update(0, 1);
    venus.enableTrail({maxPoints: 300, color: 0xff0000});

    const marsWithMoons = new PlanetMoonSystem(mars);
    solarSystemGroup.add(marsWithMoons);
    marsWithMoons.update(0, 1);
    mars.enableTrail({color: 0xffaa00});

    const jupiterWithMoons = new PlanetMoonSystem(jupiter)
    solarSystemGroup.add(jupiterWithMoons);
    jupiterWithMoons.update(0, 1);
    jupiter.enableTrail({color: 0xdddddd});

    const saturnWithMoons = new PlanetMoonSystem(saturn)
    solarSystemGroup.add(saturnWithMoons);
    saturnWithMoons.update(0, 1);
    saturn.enableTrail({color: 0xdd00dd});

    const solarSystem = [
        earthMoonSystem,
        noMoonsMercury,
        noMoonsVenus,
        marsWithMoons,
        jupiterWithMoons,
        saturnWithMoons
    ];

    // controls.target.copy(sun.getWorldPosition(new Vector3()));
    controls.target.copy(earth.getWorldPosition(new Vector3()));
    controls.update();
    new ControlsGui();

    let lastTime = 0;
    const frameRate = 20;
    let t = 0;
    function animate(time) {
        if (time - lastTime < 1000 / frameRate) return;
        lastTime = time;

        solarSystem.forEach(body => body.update(t, dt));
        t += dt;

        skyDome.update(time * .001, planetCamera);
        planetRenderer.render(planetaryScene, planetCamera);
    }

</script>