<div class="canvasWrapper2D" id="canvas-wrapper">
    <canvas class="applicationCanvas2D" id="fractalsCanvas"></canvas>
</div>
<table>
    <tr>
        <td><input type="radio" id="kochSnowflake"/><label for="kochSnowflake">&nbsp;Koch snowflake ‚ùÑÔ∏è</label></td>
        <td><label for="cesaroFractal"><input type="radio" id="cesaroFractal"/>&nbsp;Cesaro fractal üèõÔ∏è</label></td>
    </tr>
    <tr>
        <td><input type="radio" id="sierpinskiTriangle"/><label for="sierpinskiTriangle">&nbsp;Sierpinski triangle ‚ö†Ô∏è</label></td>
        <td><input type="radio" id="tSquareFractal"/><label for="tSquareFractal">&nbsp;T-square fractal üî∂</label></td>
    </tr>
    <tr>
        <td><input type="radio" id="dragonCurve"/><label for="dragonCurve">&nbsp;Dragon curve üê¶‚Äçüî•</label></td>
        <td>&nbsp;</td>
    </tr>
</table>

<script type="module">
    import { Pixel, PixelImage, Colors } from 'https://www.hendrikse.name/science/js/pixel-image.js';

    let canvas = document.getElementById("fractalsCanvas");
    let context = canvas.getContext("2d");

    const radioButtons = new Map();
    radioButtons.set("kochSnowflake", drawSnowflake);
    radioButtons.set("cesaroFractal", drawCesaro);
    radioButtons.set("dragonCurve", drawDragonCurve);
    radioButtons.set("sierpinskiTriangle", drawSierpinskiTriangle);
    radioButtons.set("tSquareFractal", drawTSquare);

    function hsvToRgb(h, s, v) {
        let r, g, b;
        let i = Math.floor(h * 6);
        let f = h * 6 - i;
        let p = v * (1 - s);
        let q = v * (1 - f * s);
        let t = v * (1 - (1 - f) * s);

        switch (i % 6) {
            case 0: r = v, g = t, b = p; break;
            case 1: r = q, g = v, b = p; break;
            case 2: r = p, g = v, b = t; break;
            case 3: r = p, g = q, b = v; break;
            case 4: r = t, g = p, b = v; break;
            case 5: r = v, g = p, b = q; break;
        }

        return [Math.round(r), Math.round(g), Math.round(b)];
    }

    class TurtleRenderer {
        constructor(image, margin = 0.05) {
            this.image = image;
            this.margin = margin; // 5% marge
            this.reset();
        }

        reset() {
            this.pixels = [];
            this.penstates = [];
            this.minX = Infinity;
            this.maxX = -Infinity;
            this.minY = Infinity;
            this.maxY = -Infinity;
        }

        plot(x, y, color=Colors.CYAN, draw=true) {
            this.pixels.push(new Pixel(x, y, color));
            this.penstates.push(draw);
            this.minX = Math.min(this.minX, x);
            this.maxX = Math.max(this.maxX, x);
            this.minY = Math.min(this.minY, y);
            this.maxY = Math.max(this.maxY, y);
        }

        transform(pixel) {
            const fractalW = this.maxX - this.minX || 1;
            const fractalH = this.maxY - this.minY || 1;

            const scale = Math.min(
                this.image.width / fractalW,
                this.image.height / fractalH
            ) * (1 - this.margin * 2);

            const offsetX = this.image.width / 2 - (this.minX + fractalW / 2) * scale;
            const offsetY = this.image.height / 2 - (this.minY + fractalH / 2) * scale;

            return new Pixel(pixel.x * scale + offsetX, this.image.height - (pixel.y * scale + offsetY), pixel.color);
        }

        drawPaths(lineWidth=2) {
            for (let i = 1; i < this.pixels.length; i++) {
                if (!this.penstates[i]) continue;
                const fromPixel = this.transform(this.pixels[i - 1]);
                const toPixel = this.transform(this.pixels[i]);
                this.image.drawLine(fromPixel, toPixel, lineWidth);
            }
        }

        render = (context) => this.image.render(context);
    }

    class Turtle {
        static PenState = Object.freeze({
            UP: [1, 0, 0],
            DOWN: [0, 1, 0]
        });

        constructor(renderer, penState=Turtle.PenState.UP, color=Colors.YELLOW) {
            this.currentColor = color;
            this.penState = penState;
            this.angle = 0;
            this.x = 0;
            this.y = 0;
            this.renderer = renderer;
        }

        degreeToRadians = (angle) => angle * Math.PI / 180;
        right= (angle) => this.angle += this.degreeToRadians(angle);
        left = (angle) => this.angle -= this.degreeToRadians(angle);
        backward = (distance) => this.forward(-distance);
        penDown= () => this.penState = Turtle.PenState.DOWN;
        penUp = () => this.penState = Turtle.PenState.UP;
        draw = (lineWidth = 2) => this.renderer.drawPaths(lineWidth);
        render = (context) => this.renderer.render(context);

        forward(distance) {
            const newX = this.x + distance * Math.cos(this.angle);
            const newY = this.y + distance * Math.sin(this.angle);
            this.goto(newX, newY);
        }

        color(color) {
            this.currentColor = color;
        }

        goto(x, y) {
            this.renderer.plot(x, y, this.currentColor, this.penState === Turtle.PenState.DOWN);
            this.x = x;
            this.y = y;
        }
    }

    function kochSnowflake(turtle, length, depth) {
        if (depth === 0)
            turtle.forward(length);
        else {
            length /= 3.0;
            kochSnowflake(turtle, length, depth - 1);
            turtle.left(60);
            kochSnowflake(turtle, length, depth - 1);
            turtle.right(120);
            kochSnowflake(turtle, length, depth - 1);
            turtle.left(60);
            kochSnowflake(turtle, length, depth - 1);
        }
    }

    function drawSnowflake(turtle) {
        turtle.goto(-150, 90)
        turtle.penDown()
        turtle.color(Colors.YELLOW);
        for (let i = 0; i < 3; i++)
            kochSnowflake(turtle, 300, 4);
        turtle.right(120);
    }

    function cesaroFractal(turtle, depth, length) {
        if (depth === 0)
            turtle.forward(length);
        else {
            const angles = [85, -170, 85, 0]
            for (let index = 0; index < angles.length; index++) {
                cesaroFractal(turtle, depth - 1, length / 3);
                turtle.left(angles[index]);
            }
        }
    }

    function drawCesaro(turtle) {
        turtle.goto(10, 300);
        turtle.penDown();
        turtle.color(Colors.GREEN);
        cesaroFractal(turtle, 6, 4000);
    }

    function dragonCurve(n) {
        if (n === 0) {
            return [[0, 0], [1, 0]];
        } else {
            const prevPoints = dragonCurve(n - 1);
            const newPoints = [];
            for (let i = 0; i < prevPoints.length - 1; i++) {
                const [x1, y1] = prevPoints[i];
                const [x2, y2] = prevPoints[i + 1];
                const dx = x2 - x1;
                const dy = y2 - y1;

                let new_dx, new_dy;
                if (i % 2 === 0) {
                    new_dx = dy;
                    new_dy = -dx;
                } else {
                    new_dx = -dy;
                    new_dy = dx;
                }

                const new_x = x1 + dx / 2 + new_dx / 2;
                const new_y = y1 + dy / 2 + new_dy / 2;

                newPoints.push([x1, y1], [new_x, new_y]);
            }
            newPoints.push(prevPoints[prevPoints.length - 1]);
            return newPoints;
        }
    }

    function drawDragonCurve(turtle) {
        const points = dragonCurve(12);
        const scale = 400;
        const offsetX = canvas.width / 4.5;
        const offsetY = canvas.height / 1.5;

        // Put turtle on first point without drawing
        const [x0, y0] = points[0];
        turtle.penUp();
        turtle.goto(x0 * scale + offsetX, y0 * scale + offsetY);

        // Next plot all other points with color
        turtle.penDown();
        for (let i = 1; i < points.length; i++) {
            const [x, y] = points[i];
            turtle.color(hsvToRgb(i / points.length, 1, 1));
            turtle.goto(x * scale + offsetX, y * scale + offsetY);
        }
    }

    function tSquare(turtle, n, x, y, w) {
        if (n !== 0) {
            turtle.color(hsvToRgb(w * .5, 1, 1));
            turtle.goto(x, y);
            turtle.penDown();
            turtle.goto(x + w, y);
            turtle.goto(x + w, y + w);
            turtle.goto(x, y + w);
            turtle.goto(x, y);
            turtle.penUp();
            const new_w = w / 3
            tSquare(turtle, n - 1, x + new_w, y + new_w, new_w)
            tSquare(turtle, n - 1, x + new_w, y + new_w * 5, new_w)
            tSquare(turtle, n - 1, x + new_w * 5, y + new_w * 5, new_w)
            tSquare(turtle, n - 1, x + new_w * 5, y + new_w, new_w)
        }
    }

    function drawTSquare(turtle) {
        const n = 7;
        const w = 2**n;
        turtle.color(Colors.RED);
        turtle.penUp();
        turtle.goto(0, 0);
        tSquare(turtle, n, 0, 0, w);
    }

    function sierpinskiTriangle(turtle, length, depth) {
        if (depth === 0)
            for (let i = 0; i < 3; i++) {
                turtle.forward(length);
                turtle.left(120);
            } else {
            sierpinskiTriangle(turtle, length / 2, depth - 1);
            turtle.forward(length / 2);
            sierpinskiTriangle(turtle, length / 2, depth - 1);
            turtle.backward(length / 2);
            turtle.left(60);
            turtle.forward(length / 2);
            turtle.right(60);
            sierpinskiTriangle(turtle, length / 2, depth - 1);
            turtle.left(60);
            turtle.backward(length / 2);
            turtle.right(60);
        }
    }

    function drawSierpinskiTriangle(turtle) {
        turtle.goto(50, 375);
        turtle.penDown();
        sierpinskiTriangle(turtle, 400, 5);
    }

    function resetButtons() {
        for (const [key, value] of radioButtons)
            document.getElementById(key).checked = false;
    }

    function redraw() {
        const turtle = createTurtle();
        currentFractal(turtle);
        turtle.draw();
        turtle.render(context);
    }

    function resizeCanvas() {
        const wrapper = document.getElementById("canvas-wrapper");
        const rect = wrapper.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;

        canvas.width  = Math.floor(rect.width * dpr);
        canvas.height = Math.floor(rect.height * dpr);

        canvas.style.width  = rect.width + "px";
        canvas.style.height = rect.height + "px";

        redraw();
    }

    let currentFractal = drawDragonCurve;

    const createTurtle = () =>
        new Turtle(new TurtleRenderer(new PixelImage(context.canvas.width, context.canvas.height)));

    for (const [key, value] of radioButtons)
        document.getElementById(key).onclick = function() {
            resetButtons();
            this.checked = true;
            currentFractal = value;
            redraw();
        };

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas(); // initial draw
    document.getElementById("dragonCurve").checked = true;

</script>

