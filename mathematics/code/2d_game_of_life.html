<style>
    .canvas-wrapper {
        position: relative;
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        aspect-ratio: 1 / 1;
    }

    .game-of-life-canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
    }
    table {
        width: 100%;
        border: none;
        max-width: 800px;
        margin: 0 auto;
    }
    td {
        white-space: nowrap;
        border: none;
    }
</style>
<div class="canvas-wrapper" id="canvas-wrapper">
    <canvas class="game-of-life-canvas" id="gameOfLifeCanvas"></canvas>
</div>

<script type="module">
    import { Pixel, PixelImage, Colors } from 'https://www.hendrikse.name/science/js/pixel-image.js';

    const canvas = document.getElementById("gameOfLifeCanvas");
    const display = canvas.getContext("2d");

    window.addEventListener("resize", () => {
        resizeCanvas();
        initGameOfLife();
    });

    canvas.focus();

    function resizeCanvas() {
        const wrapper = document.getElementById("canvas-wrapper");
        const size = wrapper.clientWidth;
        const dpr = window.devicePixelRatio || 1;

        canvas.width  = Math.floor(size * dpr);
        canvas.height = Math.floor(size * dpr);

        canvas.style.width  = size + "px";
        canvas.style.height = size + "px";
    }

    class Game {
        constructor(cells) {
            this._cells = cells;
        }

        next_generation() {
            let new_cells = [];
            for (let row = 0; row < this.height(); row++)
                new_cells.push(this.next_row_generation(row));
            return new Game(new_cells);
        }

        next_row_generation(row) {
            let result = [];
            for (let i = 0; i < this.width(); i++)
                result.push(
                    this.cell_at(row, i)
                        .next_generation(this.neighbours_for(row, i))
                );
            return result;
        }

        neighbours_for(row, column) {
            let neighbours = [
                this.cell_at(row - 1, column - 1),
                this.cell_at(row - 1, column),
                this.cell_at(row - 1, column + 1),
                this.cell_at(row,     column - 1),
                this.cell_at(row,     column + 1),
                this.cell_at(row + 1, column - 1),
                this.cell_at(row + 1, column),
                this.cell_at(row + 1, column + 1),
            ];
            return without_nones(neighbours);
        }

        cell_at(row, column) {
            if (column < 0) return null;
            if (column >= this.width()) return null;
            if (row < 0) return null;
            if (row >= this.height()) return null;
            return this._cells[row][column];
        }

        width() {
            return this._cells[0].length;
        }

        height() {
            return this._cells.length;
        }
    }


    function without_nones(list_) {
        let filtered_list = [];
        for (let item of list_)
            if (item !== null)
                filtered_list.push(item);

        return filtered_list;
    }


    class Cell {
        constructor(alive) {
            this._alive = alive;
        }

        next_generation(neighbours) {
            if (this.is_alive())
                return this._next_generation_when_alive(neighbours);
            return this._next_generation_when_dead(neighbours);
        }

        _next_generation_when_dead(neighbours) {
            return living(neighbours).length === 3
                ? living_cell()
                : dead_cell();
        }

        _next_generation_when_alive(neighbours) {
            const n = living(neighbours).length;
            return (n === 2 || n === 3)
                ? living_cell()
                : dead_cell();
        }

        is_alive() {
            return this._alive;
        }
    }


    function living(neighbours) {
        let living_neighbours = [];
        for (let neighbour of neighbours)
            if (neighbour.is_alive())
                living_neighbours.push(neighbour);
        return living_neighbours;
    }

    function dead_cell() {
        return new Cell(false);
    }

    function living_cell() {
        return new Cell(true);
    }

    let dimension_x;
    let dimension_y;
    let game;
    let image;

    function initGameOfLife() {
        const pixelSize = 1;

        dimension_x = Math.floor(canvas.width  / pixelSize);
        dimension_y = Math.floor(canvas.height / pixelSize);

        // Create cells
        let cells = [];
        for (let x = 0; x < dimension_x; x++) {
            let row = [];
            for (let y = 0; y < dimension_y; y++)
                row.push(Math.random() < 0.5 ? dead_cell() : living_cell());
            cells.push(row);
        }

        game = new Game(cells);
        image = new PixelImage(
            dimension_x,
            dimension_y,
            pixelSize,
            Colors.BLACK
        );
    }

    function render_game(game, image) {
        for (let x = 0; x < image.dimX(); x++)
            for (let y = 0; y < image.dimY(); y++)
                image.setColour(new Pixel(x, y, game.cell_at(x, y).is_alive() ? Colors.GREEN: Colors.BLACK));
    }

    const frame_rate = 10; // generations per second
    let lastTime = 0;
    resizeCanvas();
    initGameOfLife();

    function loop(timestamp) {
        if (timestamp - lastTime > 1000 / frame_rate) {
            game = game.next_generation();
            render_game(game, image);
            image.render(display);
            lastTime = timestamp;
        }
        requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);



</script>

