<style>
    canvas {
        background: #131313;
        display: block;
        width: 100%;
        aspect-ratio: 19 / 12;
        max-width: 800px;
        margin: auto;
    }
</style>

<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<canvas class="applicationCanvas" id="planetsCanvas" style="aspect-ratio: 19 / 12;"></canvas><br/>
<div class="guiContainer" id="gui-container"></div>

<script type="module">
    import { Group, SphereGeometry, MeshPhongMaterial, Mesh, TextureLoader, Color,
        Scene, PerspectiveCamera, Vector3, WebGLRenderer, AmbientLight, PointLight} from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { ThreeJsUtils, SkyDome, Trail } from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm";

    const planetsCanvas = document.getElementById('planetsCanvas');
    planetsCanvas.focus();
    console.clear();

    const textureLoader = new TextureLoader();
    textureLoader.setCrossOrigin("anonymous");

    const AU = 1.496 * 1E11;   // astronomical unit
    const EARTH_SEMI_MAJOR_AXIS = 149598261.;

    const PLANET_SCALE = 0.25E7;  // meters → render units (radius), planet sizes are shrunk by this factor
    const SUN_SCALE = 100 * PLANET_SCALE;
    const ORBIT_SCALE  = 40;    // additional orbit compression factor for nice visual representation
    const DISTANCE_SCALE = AU / ORBIT_SCALE;
    const toRenderUnits = (vector) => vector.clone().multiplyScalar(1000 / DISTANCE_SCALE);

    const planetaryScene = new Scene();
    // --- CAMERA ---
    const planetCamera = new PerspectiveCamera(60, 19/20, .1, 3000);
    // planetCamera.position.set(100, 50, 150);
    planetCamera.position.set(50, 50, 50);
    planetCamera.lookAt(0, 0, 0);

    const planetRenderer = new WebGLRenderer( {antialias: true, canvas: planetsCanvas, alpha: true} );
    planetRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    planetRenderer.shadowMap.enabled = false;
    planetRenderer.setAnimationLoop( animate );

    // Resizing for mobile devices
    ThreeJsUtils.resizeRendererToCanvas(planetRenderer, planetCamera);
    window.addEventListener('resize', () => {
        ThreeJsUtils.resizeRendererToCanvas(planetRenderer, planetCamera);
    });

    const controls = new OrbitControls(planetCamera, planetsCanvas);
    controls.minDistance = 20;
    controls.maxDistance = 800;
    controls.target.set(0, 0, 0);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    const skyDome = new SkyDome({skyRadius: 2500, glowStarCount: 500});
    planetaryScene.add(skyDome);

    // Abstract base class for celestial bodies, hence should _not_ be instantiated directly!
    class CelestialBody extends Group {
        constructor(bodyData, scale, texturePath = "https://www.hendrikse.name/science/astrophysics/code/textures/") {
            super();
            this._name = bodyData.name;
            this._radius = bodyData.radius;
            this._omega = bodyData.omega;
            this._mass = bodyData.mass;
            this._timescale = 1;
            this._spin = 365.25 * 24 * bodyData.omega;

            const geometry = new SphereGeometry(bodyData.radius / scale, 32, 32);
            const mesh = new Mesh(geometry, this._material(texturePath));
            this.add(mesh);

            this.rotation.z = bodyData.tilt; // Axial tilt (set only once!)
            this._deferredTrail = false;
            this._trail = null;
            this._coordinates = [];
        }

        get tilt() { return this.rotation.z; }
        get radius() { return this._radius; }
        get mass() { return this._mass; }

        _orbitIndex(t) { return Math.floor(t / this._timescale) % this._coordinates.length; }

        _linSpace(start, stop, num) {
            const result = [];
            const step = (stop - start) / (num - 1);

            for (let i = 0; i < num - 1; i++)
                result.push(start + i * step);

            result.push(stop); // include last point as well
            return result;
        }

        // Newton-Raphson to calculate elliptic orbit
        _orbit(meanAnomaly, eccentricity, a, inclination, ascension, nPoints=10000, acc=1.e-2) {
            // nPoints = number of orbit coordinates generated (affects temporal accuracy - dt(real)=365.25*86400/n (in seconds))
            const range = this._linSpace(meanAnomaly, 2 * Math.PI + meanAnomaly, nPoints);

            let eccAnom = range.slice();
            let eccAnomOld = new Array(nPoints);

            let maxDiff = Infinity;

            while (maxDiff > acc) {
                maxDiff = 0;
                eccAnomOld = eccAnom.slice(); // copy array

                // Newton–Raphson step
                for (let i = 0; i < nPoints; i++) {
                    const f = eccAnomOld[i] - eccentricity * Math.sin(eccAnomOld[i]) - range[i];
                    const fPrime = 1 - eccentricity * Math.cos(eccAnomOld[i]);
                    eccAnom[i] = eccAnomOld[i] - f / fPrime;
                    maxDiff = Math.max(maxDiff, Math.abs(eccAnom[i] - eccAnomOld[i]));
                }
            }

            const points = [];
            for (let i = 0; i < nPoints; i++) {
                const theta = 2 * Math.atan2(
                    Math.sqrt(1 + eccentricity) * Math.sin(eccAnom[i] / 2),
                    Math.sqrt(1 - eccentricity) * Math.cos(eccAnom[i] / 2)
                );

                const r = a * (1 - eccentricity * Math.cos(eccAnom[i]));
                const thetaAsc = theta - ascension;

                const x = (Math.cos(ascension) * Math.cos(thetaAsc) -
                    Math.sin(ascension) *
                    Math.sin(thetaAsc) *
                    Math.cos(inclination));

                const z = (Math.sin(ascension) * Math.cos(thetaAsc) +
                    Math.cos(ascension) *
                    Math.sin(thetaAsc) *
                    Math.cos(inclination));

                const y = Math.sin(theta - ascension) * Math.sin(inclination);

                points.push(new Vector3(x, y, z).multiplyScalar(r));
            }

            return points;
        }

        _material(texturePath) { throw new Error("Abstract class: implement material!"); }

        update() {
            if (this._trail)
                this._trail.addPoint(this.getWorldPosition(new Vector3()));
        }

        attachDeferredTrail() {
            if (this._deferredTrail && this.parent && this._trail) {
                this.parent.add(this._trail._line);
                this._deferredTrail = false;
            }
        }

        enableTrail({ maxPoints = 1000, color=0xffff00 } = {}) {
            this._trail = new Trail({ maxPoints, color });
            if (this.parent)
                this.parent.add(this._trail._line);
            else
                this._deferredTrail = true;
        }

        disposeTrail() {
            if (!this._trail) return;
            if (this._trail._line) {
                if (this._trail._line.geometry)
                    this._trail._line.geometry.dispose();
                if (this._trail._line.material)
                    this._trail._line.material.dispose();
                this.remove(this._trail._line);
            }
            this._trail = null;
        }
    }

    class Planet extends CelestialBody {
        constructor(planetData) {
            super(planetData, PLANET_SCALE);
            this._timescale = (planetData.a / EARTH_SEMI_MAJOR_AXIS) ** 1.5; // rotation period w.r.t. Earth

            // create orbit coordinates list for the planet
            this._coordinates = this._orbit(
                planetData.mean_anomaly,
                planetData.e,
                planetData.a,
                planetData.inclination,
                planetData.right_ascension
            );
        }

        _material(texturePath) {
            return new MeshPhongMaterial({
                map: textureLoader.load(`${texturePath}` + this._name + "map.jpg"),
                bumpMap: textureLoader.load(`${texturePath}` + this._name + "bump.jpg"),
                bumpScale: 0.005,
                shininess: 0
            });
        }

        update(t, dt) {
            super.update(); // for trail
            this.rotation.y += this._omega * 3600 * 24 * 365.25 * dt / this._coordinates.length;
        }
    }

    class Satellite extends CelestialBody {
        constructor(moonData, planet, scale) {
            super(moonData, scale);
            this._planet = planet;
            this._angle = 0;
            this._a = moonData.a; // semi-major axis
            this._e = moonData.e;

            this._timescale = moonData.period / 365.25;  // rotation period w.r.t Earth
            this._lock = moonData.tidal_lock;

            this._coordinates = this._orbit(
                moonData.mean_anomaly,
                this._e,
                this._a,
                planet.tilt +
                moonData.inclination,
                moonData.right_ascension);  // create orbit coordinates list for the moon

            this.#centerMoonsOrbitAroundOrigin();
        }

        #centerMoonsOrbitAroundOrigin() {
            const center = new Vector3();
            this._coordinates.forEach(position => center.add(position));
            center.divideScalar(this._coordinates.length);
            this._coordinates.forEach(position => position.sub(center));
        }

        update(t, dt) {
            super.update(); // for trail, if enabled
            if (this._lock) {
                const planetWorldPos = this._planet.getWorldPosition(new Vector3());
                this.lookAt(planetWorldPos);

                // Corrigeer vaste fase-offset (textuur-oriëntatie)
                this.rotateY(Math.PI); // of rotateZ, afhankelijk van je texture
            }

        }
    }

    class PlanetMoonSystem extends Group {
        constructor(planet, moons = []) {
            super();
            this._planet = planet;
            this._moons = moons;

            this.add(planet);
            moons.forEach(moon => this.add(moon));

            this._coordinates = planet._coordinates;
        }

        get mass() {
            let M = this._planet.mass;
            for (const moon of this._moons)
                M += moon.mass;
            return M;
        }

        update(t, dt) {
            // 1. barycentric position (sun-centric)
            const baryPosition = this._coordinates[this._planet._orbitIndex(t)].clone();

            // 2. total mass
            const M = this.mass;

            // 3. barycentric correction
            const correction = new Vector3();
            for (const moon of this._moons) {
                const r = moon._coordinates[moon._orbitIndex(t)];
                correction.add(r.clone().multiplyScalar(moon.mass / M));
            }

            // 4. planet position
            this._planet.position.copy(toRenderUnits(baryPosition.clone().sub(correction)));

            // 5. moon positions
            for (const moon of this._moons) {
                const r = moon._coordinates[moon._orbitIndex(t)];
                moon.position.copy(toRenderUnits(baryPosition.clone().add(r)));
            }

            // 6. rotations
            this._planet.update(t, dt);
            for (const moon of this._moons)
                moon.update(t, dt);
        }
    }

    class Sun extends CelestialBody {
        static DATA = {
            "radius": 696300000.0,
            "mass": 1.9885440000000002e+30,
            "omega": 2.8653290845717256e-06,
            "tilt": 0.1265363707695889
        }

        constructor() {
            super(Sun.DATA, SUN_SCALE);
        }

        _material(texturePath) {
            return new MeshPhongMaterial({
                map: textureLoader.load(`${texturePath}sunmap.jpg`),
                emissive: new Color(0xffcc66),
                emissiveIntensity: 1.0
            });
        }
    }

    class Moon extends Satellite {
        static DATA = {
            "a": 384399 * 50.,
            "e": 0.0549,
            "inclination": (-23.4 + 5.145) * Math.PI / 180.,
            "right_ascension": -Math.PI / 2.,
            "mean_anomaly": 0.,
            "radius": 1737400,
            "mass": 7.349e+22,  // kg
            "omega": 2.6617072234847306e-06, // rad/s
            "tilt": 0.11641346110802178, // rad
            'period': 27.321, // days
            "tidal_lock": true
        }

        constructor(planet) {
            super(Moon.DATA, planet, PLANET_SCALE);
        }

        _material(texturePath) {
            return new MeshPhongMaterial({
                map: textureLoader.load(`${texturePath}moonmap1k.jpg`),
                bumpMap: textureLoader.load(`${texturePath}moonbump1k.jpg`),
                bumpScale: 0.05,
                specular: new Color(0x333333),
                emissive: new Color(0x112244),
                emissiveIntensity: 0.05,
                shininess: 3
            });
        }
    }

    class Earth extends CelestialBody {
        constructor(planetData) {
            super(planetData, PLANET_SCALE);
            this._name = planetData.name;
            this._timescale = 1; // rotation period w.r.t. Earth

            // create orbit coordinates list for the planet
            this._coordinates = this._orbit(
                planetData.mean_anomaly,
                planetData.e,
                planetData.a,
                planetData.inclination,
                planetData.right_ascension
            );
        }

        update(t, dt) {
            super.update(); // for trail
            this.rotation.y += this._omega * 3600 * 24 * 365.25 * dt / this._coordinates.length;
        }

        _material(texturePath) {
            return new MeshPhongMaterial({
                map: textureLoader.load(`${texturePath}earthmap1k.jpg`),
                bumpMap: textureLoader.load(`${texturePath}earthbump1k.jpg`),
                bumpScale: 0.05,
                specularMap: textureLoader.load(`${texturePath}earthspec1k.jpg`),
                specular: new Color(0x333333),
                emissive: new Color(0x112244),
                emissiveIntensity: 0.05,
                shininess: 3
            });
        }
    }

    class ControlsGui {
        constructor() {
            const controls = new GUI({width: "100%", autoPlace: false});
            document.getElementById("gui-container").appendChild(controls.domElement);

            const settings = {
                dt: 5
            };

            controls.add(settings, 'dt', 0.01, 50, 0.01).name("Time Step (dt)").onChange(value => {
                dt = value;
            });
        }
    }

    const solarSystemGroup = new Group();
    planetaryScene.add(solarSystemGroup);

    const sun = new Sun();
    sun.position.set(0, 0, 0);
    solarSystemGroup.add(sun);
    const sunLight = new PointLight(0xffffff, 2, 0, .1); // intense, no max distance
    sunLight.position.set(0, 0, 0);
    planetaryScene.add(sunLight);
    planetaryScene.add(new AmbientLight(0xffffff, 0.2));

    const earth = new Earth({
        "name": "earth",
        "a": EARTH_SEMI_MAJOR_AXIS,
        "e": 0.01671123,
        "inclination": 0.,
        "right_ascension": 0.,
        "mean_anomaly": 6.2398515744,
        "radius": 6371010, // meters
        "mass": 5.97219e+24,
        "omega": 7.292115e-05, // rad/s
        "tilt": 0.40927970959267024 // radians
    });
    const mercury = new Planet({
        "name": "mercury",
        'a': 57909050.,
        'e': 0.205630,
        'inclination': 7 * Math.PI / 180.,
        'right_ascension': 0.8436854966,
        'mean_anomaly': 3.0507657193,
        'radius': 2439.7 * 1e3,
        "mass": 3.302e+23,
        'tilt': 0.1 * Math.PI / 180.,
        "omega": 4.1332945421494e-07
    });
    const venus = new Planet({
        "name": "venus",
        'a': 108208000.,
        'e': 0.0067,
        'inclination': 3.39 * Math.PI / 180.,
        'right_ascension': 1.3381895772,
        'mean_anomaly': 0.8746717546,
        'radius': 6051.8 * 1e3,
        "mass": 4.8685e+23,
        'tilt': 177 * Math.PI / 180.,
        'omega': 6.2289229172353e-07
    })
    const moon = new Moon(earth);

    const earthMoonSystem = new PlanetMoonSystem(earth, [moon]);
    solarSystemGroup.add(earthMoonSystem);
    earthMoonSystem.update(0, 1); // set initial position
    earth.enableTrail({color: 0x00bbff});

    const noMoonsMercury = new PlanetMoonSystem(mercury);
    solarSystemGroup.add(noMoonsMercury);
    noMoonsMercury.update(0, 1);
    mercury.enableTrail({color: 0xffaa00});

    const noMoonsVenus = new PlanetMoonSystem(venus);
    solarSystemGroup.add(noMoonsVenus);
    noMoonsVenus.update(0, 1);
    venus.enableTrail({color: 0xff0000});

    const solarSystem = [
        earthMoonSystem,
        noMoonsMercury,
        noMoonsVenus
    ];

    controls.target.copy(sun.getWorldPosition(new Vector3()));
    controls.update();
    new ControlsGui();

    let lastTime = 0;
    const frameRate = 20;
    let dt = 10;
    let t = 0;
    function animate(time) {
        if (time - lastTime < 1000 / frameRate) return;
        lastTime = time;

        solarSystem.forEach(body => body.update(t, dt));
        t += dt;

        skyDome.update(time * .001, planetCamera);
        planetRenderer.render(planetaryScene, planetCamera);
    }

</script>