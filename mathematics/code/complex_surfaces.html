<style>
    .applicationCanvas {
        display: block;
        background-color: #131313;
        width: 100%;
        max-width: 800px;
        aspect-ratio: 1 / 1;
        margin: auto;
    }

    .canvasWrapper {
        position: relative;
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        aspect-ratio: 1 / 1;
    }

    .guiContainer {
        margin-top: 0.5em;
        background: #1a1a1a;
    }

</style>

<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<div class="canvasWrapper" id="complexPlotContainer">
    <canvas class="applicationCanvas" id="complexPlotCanvas"></canvas><br/>
</div>
<div id="gui-container"></div>

<script type="module">
    import * as THREE from "three";
    import { Spherical, Sphere, PerspectiveCamera, WebGLRenderer, HemisphereLight, DirectionalLight, Vector3,
        MathUtils, BufferGeometry, Mesh} from "three";
    // import { Axes, AxesParameters, MatlabAnnotations, MatlabAxesLayout, Plot3D, Interval }
    import { Interval, ThreeJsUtils }
        from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";
    import { SurfaceDefinition, ColorMapper, SurfaceView }
        from 'https://www.hendrikse.name/science/js/3d-surface-components.js';
    import { CSS2DRenderer, CSS2DObject } from "three/addons/renderers/CSS2DRenderer";
    import {OrbitControls} from "three/addons/controls/OrbitControls.js";

    const canvasContainer = document.getElementById("complexPlotContainer");
    const canvas = document.getElementById("complexPlotCanvas");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x131313);
    const worldGroup = new THREE.Group();
    scene.add(worldGroup);

    export class AxesView extends THREE.Group {
        static Type = Object.freeze({
            CLASSICAL: "classical",
            MATLAB: "MatLab"
        });

        constructor() {
            super();
            this._layout = null;
            this._annotations = null;
        }

        #disposeLayout() {
            if (this._layout) {
                this._layout.traverse(object => {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) object.material.dispose();
                });
                this.remove(this._layout);
                this._layout = null;
            }
        }

        #disposeAnnotations() {
            if (this._annotations) {
                this._annotations._labels.forEach(label => this._annotations.remove(label));
                if (this._annotations._renderer?.domElement?.parentNode)
                    this._annotations._renderer.domElement.parentNode.removeChild(this._annotations._renderer.domElement);
                this._annotations = null;
            }
        }

        dispose() {
            this.#disposeLayout();
            this.#disposeAnnotations();
            this.clear();
        }

        static toCartesian(radius, theta, phi) {
            return new THREE.Vector3(
                radius * Math.sin(theta) * Math.cos(phi),
                radius * Math.sin(theta) * Math.sin(phi),
                radius * Math.cos(theta)
            );
        }

        setLayout(layout) {
            this._layout?.dispose?.();
            this._layout = layout;
            this.add(layout);
        }

        setAnnotations(annotations) {
            this._annotations?.dispose?.();
            this._annotations = annotations;
            this.add(annotations);
        }

        get annotations() { return this._annotations; }
        get layout() { return this._layout; }

        render(scene, camera) {
            this._annotations.render(scene, camera);
        }

        boundingBox() {
            const axesBoundingBox = new THREE.Box3();
            axesBoundingBox.setFromObject(this);
            return axesBoundingBox;
        }
    }

    export class AxesParameters {
        constructor({
                        layoutType = AxesView.Type.MATLAB,
                        divisions = 10,
                        axes = true,
                        gridPlanes = true,
                        annotations = true,
                        xyPlane = true,
                        xzPlane = true,
                        yzPlane = true,
                        axisLabels = ["X", "Y", "Z"]
                    } = {}) {
            this.layoutType = layoutType;
            this.divisions = divisions;
            this.axes = axes;
            this.gridPlanes = gridPlanes;
            this.annotations = annotations;
            this.xyPlane = xyPlane;
            this.xzPlane = xzPlane;
            this.yzPlane = yzPlane;
            this.axisLabels = axisLabels;
        }
    }

    class AxesAnnotation extends THREE.Group {
        constructor(container) {
            super();
            this._renderer = new CSS2DRenderer();
            this._renderer.domElement.style.position = "absolute";
            this._renderer.domElement.style.top = 0;
            this._renderer.domElement.style.left = 0;
            this._renderer.domElement.style.width = "100%";
            this._renderer.domElement.style.height = "100%";
            this._renderer.domElement.style.pointerEvents = "none"; // do not process mouse events
            this._renderer.domElement.style.zIndex = "5"; // on top of canvas

            this._labels = [];

            container.appendChild(this._renderer.domElement);
            this.#resize(container);
        }

        #resize(container) {
            this._renderer.setSize(container.clientWidth, container.clientHeight);
        }

        createLabel(text, pos, color = "yellow", fontSize = "16px") {
            const div = document.createElement("div");
            div.textContent = text;
            div.style.color = color;
            div.style.fontSize = fontSize;

            const label = new CSS2DObject(div);
            label.position.copy(pos);
            return label;
        }

        render(scene, camera) {
            this._renderer.render(scene, camera);
        }
    }

    class AxesLayout extends THREE.Group {
        constructor(size, divisions) {
            super();
            this._size = size;
            this._divisions = divisions;
            this._axes = null; // to be created in concrete subclasses
        }

        createPlane(color, rotate, gridPos, planePos) {
            const grid = new THREE.GridHelper(
                this._size,
                this._divisions,
                0x333333,
                0x333333
            );

            const plane = new THREE.Mesh(
                new THREE.PlaneGeometry(this._size, this._size),
                new THREE.MeshPhongMaterial({
                    color,
                    transparent: true,
                    opacity: 0.1,
                    depthWrite: false,
                    side: THREE.DoubleSide
                })
            );

            grid.position.copy(new THREE.Vector3(gridPos[0], gridPos[1], gridPos[2]).multiplyScalar(.5 * this._size));
            plane.position.copy(new THREE.Vector3(planePos[0], planePos[1], planePos[2]).multiplyScalar(.5 * this._size));

            rotate(grid);
            rotate(plane);

            return [grid, plane];
        }

        get divisions() { return this._divisions; }
        get size() { return this._size; }
        get axes() { return this._axes; }

        showXY() { this.xyGrid.visible = true; this.xyPlane.visible = true; }
        hideXY() { this.xyGrid.visible = false; this.xyPlane.visible = false; }
        showXZ() { this.xzGrid.visible = true; this.xzPlane.visible = true; }
        hideXZ() { this.xzGrid.visible = false; this.xzPlane.visible = false; }
        showYZ() { this.yzGrid.visible = true; this.yzPlane.visible = true; }
        hideYZ() { this.yzGrid.visible = false; this.yzPlane.visible = false; }
        show() { this.showXY(); this.showXZ(); this.showYZ(); }
        hide() { this.hideXY(); this.hideXZ(); this.hideYZ(); }
    }

    class ClassicalAxesLayout extends AxesLayout {
        constructor(size, divisions) {
            super(size, divisions);

            const eps = 0.025;
            this._axes = new THREE.AxesHelper(size * .5);
            this._axes.position.set(eps, eps, eps);

            const [xyGrid, xzPlane] = this.createPlane(0x4444ff, v => v.rotateX(Math.PI / 2), [0, 0, 0], [0, 0, 0]);
            const [xzGrid, yzPlane] = this.createPlane(0x44ff44, v => v.rotateY(Math.PI / 2), [0, 0, 0], [0, 0, 0]);
            const [yzGrid, xyPlane] = this.createPlane(0xff4444, v => v.rotateZ(Math.PI / 2), [0, 0, 0], [0, 0, 0]);
            this.xyGrid = xyGrid;
            this.xyPlane = xyPlane;
            this.yzGrid = yzGrid;
            this.yzPlane = yzPlane;
            this.xzGrid = xzGrid;
            this.xzPlane = xzPlane;
            this.add(this._axes, this.xyGrid, this.xyPlane, this.xzGrid, this.xzPlane, this.yzPlane, this.yzGrid);
        }
    }

    class MatlabAxesLayout extends AxesLayout {
        constructor(size, divisions) {
            super(size, divisions);

            const eps = 0.025;
            this._axes = new THREE.AxesHelper(size);
            this._axes.position.set(-0.5 * size + eps, eps, -0.5 * size + eps);

            const [xyGrid, xzPlane] = this.createPlane(0x4444ff, v => v.rotateX(Math.PI / 2), [0, 1, -1], [0, 0, 0]);
            const [xzGrid, yzPlane] = this.createPlane(0x44ff44, v => v.rotateY(Math.PI / 2), [0, 0, 0], [-1, 1, 0]);
            const [yzGrid, xyPlane] = this.createPlane(0xff4444, v => v.rotateZ(Math.PI / 2), [-1, 1, 0], [0, 1, -1]);
            this.xyGrid = xyGrid;
            this.xyPlane = xyPlane;
            this.yzGrid = yzGrid;
            this.yzPlane = yzPlane;
            this.xzGrid = xzGrid;
            this.xzPlane = xzPlane;
            this.add(this._axes, this.xyGrid, this.xyPlane, this.xzGrid, this.xzPlane, this.yzPlane, this.yzGrid);
        }
    }

    class ClassicalAnnotations extends AxesAnnotation {
        constructor(container, axesLayout, axisLabels=["X", "Y", "Z"]) {
            super(container);

            const size = axesLayout.size;
            const step = size / axesLayout.divisions;
            for (let v = -size * .5 ; v <= size * .5; v += step)
                this._labels.push(
                    this.createLabel(v.toFixed(1), new Vector3(v, 0, 0.525 * size)),
                    this.createLabel(v.toFixed(1), new Vector3(0.525 * size, 0, v)));
            for (let v = 0 ; v <= size * .5; v += step)
                this._labels.push(this.createLabel(v.toFixed(1), new Vector3(0, v, 0)));

            this._labels.push(
                this.createLabel(axisLabels[0], new Vector3(0.575 * size, 0, 0), "red", "20px"),
                this.createLabel(axisLabels[1], new Vector3(0, 0.575 * size, 0), "green", "20px"),
                this.createLabel(axisLabels[2], new Vector3(0, 0, 0.575 * size), "blue", "20px"));

            this._labels.forEach(label => this.add(label));
        }
    }

    class MatlabAnnotations extends AxesAnnotation {
        constructor(container, axesLayout, axisLabels=["X", "Y", "Z"]) {
            super(container);

            const size = axesLayout.size;
            const step = (2 * size) / axesLayout.divisions;
            for (let v = 0 ; v <= size; v += step)
                this._labels.push(
                    this.createLabel(v.toFixed(1), new Vector3(v - 0.5 * size, 0, 0.525 * size)),
                    this.createLabel(v.toFixed(1), new Vector3(-0.525 * size, v, 0.5 * size)),
                    this.createLabel(v.toFixed(1), new Vector3(0.525 * size, 0, v - 0.5 * size)));

            this._labels.push(
                this.createLabel(axisLabels[0], new Vector3(0.65 * size, 0, -0.5 * size), "red", "20px"),
                this.createLabel(axisLabels[1], new Vector3(-0.5 * size, 1.1 * size, -0.5 * size), "green", "20px"),
                this.createLabel(axisLabels[2], new Vector3(-0.5 * size, 0, 0.65 * size), "blue", "20px"));

            this._labels.forEach(label => this.add(label));
        }
    }

    export class Plot3DView {
        constructor(canvas, canvasContainer, scene, axesBoundingBox, axesParameters) {
            this._scene = scene;
            this._canvas = canvas;
            this._axesParameters = axesParameters;
            this._canvasContainer = canvasContainer;
            this._axes = this.#createAxes(axesBoundingBox);
            this._scene.add(this.axes);
            this._camera = new PerspectiveCamera(45, 1, 0.1, 100);
            this._renderer = new WebGLRenderer({ antialias: true, canvas });
            this._spherical = new Spherical();
            this._target = new Vector3();

            // Resizing for mobile devices
            ThreeJsUtils.resizeRendererToCanvas(this._renderer, this._camera);
            window.addEventListener("resize", () => this.#resize());

            this._controls = new OrbitControls(this._camera, canvas);
            this._controls.enableDamping = true;
            this._controls.dampingFactor = 0.08;
            //this.controls.screenSpacePanning = false;
            //this.controls.maxPolarAngle = Math.PI * 0.95;

            this.#setupLights();
            this.#resize();
            this.#frame(axesBoundingBox);
            this.applyAxesParameters();
        }

        #resize() {
            ThreeJsUtils.resizeRendererToCanvas(this._renderer, this._camera);
            this.axes?._annotations._renderer.setSize(
                this._canvasContainer.clientWidth,
                this._canvasContainer.clientHeight
            );
        }

        #setupLights() {
            this._scene.add(
                new HemisphereLight(0xffffff, 0xeeeeee, 0.6),
                new DirectionalLight(0xffffff, 0.9)
            );
        }

        #createAxes(boundingBox) {
            const sizeVec = boundingBox.getSize(new Vector3());
            const maxSize = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);

            const layout = this._axesParameters.layoutType === AxesView.Type.MATLAB ?
                new MatlabAxesLayout(maxSize, this._axesParameters.divisions) :
                new ClassicalAxesLayout(maxSize, this._axesParameters.divisions);

            const annotations = (this._axesParameters.layoutType === AxesView.Type.MATLAB ) ?
                new MatlabAnnotations(this._canvasContainer, layout, this._axesParameters.axisLabels) :
                new ClassicalAnnotations(this._canvasContainer, layout, this._axesParameters.axisLabels);

            const axes = new AxesView();
            axes.setLayout(layout);
            axes.setAnnotations(annotations);
            return axes;
        }

        applyAxesParameters() {
            const { axes, gridPlanes, annotations } = this._axesParameters;
            this._axes.layout.axes.visible = axes;
            this._axes.annotations.visible = annotations;
            gridPlanes ? this._axes.layout.show() : this._axes.layout.hide();
        }

        get axes() { return this._axes; }

        #frame(boundingBox) {
            const sphere = boundingBox.getBoundingSphere(new Sphere());
            this._target.copy(sphere.center);

            const fov = THREE.MathUtils.degToRad(this._camera.fov);
            const distance = sphere.radius / Math.sin(fov / 2);

            const direction = new Vector3(1, 1, 1).normalize();

            this._spherical.setFromVector3(
                direction.clone().multiplyScalar(distance)
            );

            this._spherical.radius *= 1.15; // padding

            this.#applyCamera();
        }

        #applyCamera() {
            const offset = new Vector3().setFromSpherical(this._spherical);

            this._camera.position
                .copy(this._target)
                .add(offset);

            this._camera.near = this._spherical.radius * 0.02;
            this._camera.far  = this._spherical.radius * 10;
            this._camera.updateProjectionMatrix();

            this._controls.target.copy(this._target);
            this._controls.update();
        }

        updateAxes(newBoundingBox) {
            this._axes.dispose();
            this._scene.remove(this._axes);
            this._axes = this.#createAxes(newBoundingBox);
            this._scene.add(this._axes);
            this.#frame(this._axes.boundingBox());
            this.applyAxesParameters();
        }

        tiltY(deltaDegrees) {
            const delta = MathUtils.degToRad(deltaDegrees);

            this._spherical.phi = MathUtils.clamp(
                this._spherical.phi + delta,
                0.1,                 // prevent over the pole rotation
                Math.PI - 0.1
            );

            this.#applyCamera();
            this._controls.target.copy(this._target);
            this._controls.update();
            this._controls.saveState();
        }

        render() {
            this._controls.update();
            this._renderer.render(this._scene, this._camera);
            this._axes.render(this._scene, this._camera);
        }
    }

    export class ComplexNumber {
        constructor(re, im) {
            this._re = re
            this._im = im
        }

        get re() { return this._re; }
        get im() { return this._im; }

        phase = () => Math.atan2(this.im, this.re);
        abs = () => Math.sqrt(this.re * this.re + this.im * this.im);
    }

    export class MathWrapper {
        constructor() {
            this.complex = this._complex;
            this.add = this._add;
            this.subtract = this._subtract;
            this.multiply = this._multiply;
            this.divide = this._divide;
            this.sqrt = this._sqrt;
            this.log = this._log;
            this.exp = this._exp;
            this.sin = this._sin;
            this.cos = this._cos;
        }

        _complex = (re, im) => new ComplexNumber(re, im);
        _add = (z1, z2) => new ComplexNumber(z1.re + z2.re, z1.im + z2.im);
        _subtract = (z1, z2) => new ComplexNumber(z1.re - z2.re, z1.im - z2.im);
        _log = (z) => new ComplexNumber(Math.log(z.abs()), Math.atan2(z.im, z.re));
        _exp = (z) => new ComplexNumber(Math.exp(z.re) * Math.cos(z.im), Math.exp(z.re) * Math.sin(z.im))
        _sin = (z) => {
            const i_z = this.multiply(z, new ComplexNumber(0, 1));
            const min_i_z = this.multiply(z, new ComplexNumber(0, -1));
            return this.multiply(new ComplexNumber(0, -.5), this.exp(this.subtract(i_z, min_i_z)));
        }
        _cos = (z) => {
            const i_z = this.multiply(z, new ComplexNumber(0, 1));
            const min_i_z = this.multiply(z, new ComplexNumber(0, -1));
            return this.multiply(new ComplexNumber(.5, 0), this.exp(this.add(i_z, min_i_z)));
        }
        _multiply = (z1, z2) => new ComplexNumber(z1.re * z2.re - z1.im * z2.im, z1.im * z2.re + z1.re * z2.im);

        _divide = (z1, z2) => {
            const denominator = z2.re * z2.re + z2.im * z2.im;
            const re = z1.re * z2.re + z1.im * z2.im;
            const im = z1.im * z2.re - z1.re * z2.im;
            return new ComplexNumber(re / denominator, im / denominator);
        }
        _sqrt = (z) => {
            const factor = Math.sqrt((z.abs() + z.re) / 2);
            return new ComplexNumber(factor, factor * (z.im / Math.abs(z.im)));
        }
    }

    export class ComplexColorMapper extends ColorMapper {
        apply(geometry) {
            const phaseAttr   = geometry.attributes.phase;
            const modulusAttr = geometry.attributes.modulus;

            if (!phaseAttr || !modulusAttr)
                throw new Error("Geometry needs phase and modulus attributes");

            const count = phaseAttr.count;

            let colorAttr = geometry.attributes.color;
            if (!colorAttr) {
                colorAttr = new THREE.BufferAttribute(
                    new Float32Array(count * 3), 3
                );
                geometry.setAttribute("color", colorAttr);
            }

            // --- determine modulus range ---
            let mMin = Infinity, mMax = -Infinity;
            for (let i = 0; i < count; i++) {
                const m = modulusAttr.getX(i);
                if (m < mMin) mMin = m;
                if (m > mMax) mMax = m;
            }

            const color = new THREE.Color();

            for (let i = 0; i < count; i++) {
                const phase = phaseAttr.getX(i);
                const m     = modulusAttr.getX(i);

                // --- phase ‚Üí hue ---
                const hue = ((phase + Math.PI) / (2 * Math.PI) + 1) % 1;

                // --- modulus ‚Üí brightness ---
                const t = (m - mMin) / (mMax - mMin);
                color.setHSL(hue, 1.0, 0.25 + 0.5 * t);

                colorAttr.array[3*i]     = color.r;
                colorAttr.array[3*i + 1] = color.g;
                colorAttr.array[3*i + 2] = color.b;
            }

            colorAttr.needsUpdate = true;
        }
    }

    export class ComplexSurfaceView extends SurfaceView {
        constructor(parentGroup, surface, {showWireframe=false, resolution=100, baseColor="#4f6"} = {}) {
            super(parentGroup, surface);
            this.baseColor = baseColor;
            this.geometry = surface.createGeometryWith(resolution);
            this.material = this.material(showWireframe, 1);
            this.colorMapper = new ComplexColorMapper();
            this.mesh = new Mesh(this.geometry, this.material);
            this.group.add(this.mesh);
            this.colorMapper.apply(this.geometry);
        }

        selectableObject = () => this.mesh;
    }

    export class ComplexParametricGeometry extends BufferGeometry {
        constructor(definition, slices, stacks) {
            super();

            const vertices = [];
            const phases   = [];
            const indices  = [];
            const moduli   = [];
            for (let i = 0; i <= slices; i++) {
                const u = i / slices;

                for (let j = 0; j <= stacks; j++) {
                    const v = j / stacks;

                    const target = new Vector3();
                    const phase = definition.sample(u, v, target);
                    vertices.push(target.x, target.y, target.z);
                    moduli.push(target.y);
                    phases.push(phase);
                }
            }

            for (let i = 0; i < slices; i++)
                for (let j = 0; j < stacks; j++) {
                    const a = i * (stacks + 1) + j;
                    const b = a + stacks + 1;
                    const c = b + 1;
                    const d = a + 1;

                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }

            this.setIndex(indices);
            this.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
            this.setAttribute("phase", new THREE.Float32BufferAttribute(phases, 1));
            this.setAttribute("modulus", new THREE.Float32BufferAttribute(moduli, 1));

            this.computeVertexNormals();
        }
    }

    export class ComplexSurfaceDefinition extends SurfaceDefinition {
        constructor(specification) {
            super();
            this._specification = specification;
        }

        sample(u, v, target) {
            const re = this._specification.reInterval.scaleUnitParameter(u);
            const im = this._specification.imInterval.scaleUnitParameter(v);
            const z = new ComplexNumber(re, im);
            const value = this._specification.func(z);
            target.set(re, Math.log1p(value.abs()), im); // Log scale for complex functions
            return value.phase();
        }

        get specification() { return this._specification; }
    }

    export class ComplexSurfaceSpecification {
        constructor(func, reInterval, imInterval, latexString, textString) {
            this.func = func;
            this.reInterval = reInterval;
            this.imInterval = imInterval;
            this.latexString = latexString;
            this.textString = textString;
        }
    }

    /**
     * Using this class, a ComplexSurfaceView can be realized.
     */
    export class ComplexSurface {
        constructor(surfaceDefinition) {
            this._definition = surfaceDefinition;
        }

        createGeometryWith(resolution) {
            return new ComplexParametricGeometry(
                this._definition,
                resolution,
                resolution
            );
        }

        definition() { return this._definition; }
    }


    const math = new MathWrapper();
    const zSquaredPlusTwo = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.add(math.multiply(z, z), math.complex(2, 0)),
        new Interval(-2, 2),
        new Interval(-2, 2),
        "$\\psi(z) = \\big(z^2 + 2\\big)$",
        "z * z + 2"
    ));
    const zAbsSquared = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.multiply(z, new ComplexNumber(z.re, -z.im)),
        new Interval(-2, 2),
        new Interval(-2, 2),
        "$\\psi(z) = z\\bar{z}$",
        "z * z_bar"
    ));
    const zCubed = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.add(math.multiply(z, math.multiply(z, z)), new ComplexNumber(2, 0)),
        new Interval(-2, 2),
        new Interval(-2, 2),
        "$\\psi(z) = \\big(z^3 + 2\\big)$",
        "z * z * z + 2"
    ));
    const sqrtZ = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.sqrt(math.add(z, math.complex(0.0001, 0.0001))),
        new Interval(-1, 1),
        new Interval(-1, 1),
        "$\\psi(z) = \\sqrt(z)$",
        "sqrt(z)"
    ));
    const expZ = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.exp(math.multiply(z, z)),
        new Interval(-1, 1),
        new Interval(-1, 1),
        "$\\psi(z) = \\exp(z * z)$",
        "exp(z * z)"
    ));
    const logZ = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.log(math.add(z, math.complex(0.0001, 0.0001))),
        new Interval(-Math.PI, Math.PI),
        new Interval(-Math.PI, Math.PI),
        "$\\psi(z) = \\log(z)$",
        "log(z)"
    ));
    const sinZ = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.sin(z),
        new Interval(-Math.PI, Math.PI),
        new Interval(-Math.PI, Math.PI),
        "$\\psi(z) = \\sin(z)$",
        "sin(z)"
    ));
    const zPlusOneOverZMinusOne = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.divide(math.add(math.complex(1, 0), z), math.add(math.complex(-1, 0), z)),
        new Interval(-4, 4),
        new Interval(-4, 4),
        "$\\psi(z) = \\bigg(\\dfrac{z + 1}{z - 1} \\bigg)$",
        "(z + 1) / (z - 1)"
    ));
    const zPlusOneOverZ = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.add(z, math.divide(math.complex(1, 0), math.add(z, math.complex(0.01, 0)))),
        new Interval(-3, 3),
        new Interval(-3, 3),
        "$\\psi(z) = z + \\bigg(\\dfrac{1}{z}\\bigg)$",
        "z + 1 / z"
    ));
    const ComplexFunctions = Object.freeze({
        ZSquaredPlusTwo: zSquaredPlusTwo.specification.textString,
        ZAbsSquared: zAbsSquared.specification.textString,
        ZCubed: zCubed.specification.textString,
        SinZ: sinZ.specification.textString,
        logZ: logZ.specification.textString,
        expZ: expZ.specification.textString,
        sqrtZ: sqrtZ.specification.textString,
        ZPlusOneOverZMinusOne: zPlusOneOverZMinusOne.specification.textString,
        ZPlusOneOverZ: zPlusOneOverZ.specification.textString
    });
    class ControlsGui {
        constructor(plot, params) {
            const gui = new GUI({width: 300, autoPlace: false});
            gui.add(params, 'function', Object.values(ComplexFunctions))
                .name("F(z) = ")
                .onChange(value => {
                    surface.dispose();
                    switch (value) {
                        case zSquaredPlusTwo.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(zSquaredPlusTwo));
                            break;
                        case zAbsSquared.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(zAbsSquared));
                            break;
                        case zCubed.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(zCubed));
                            break;
                        case expZ.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(expZ));
                            break;
                        case logZ.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(logZ));
                            break;
                        case sqrtZ.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(sqrtZ));
                            break;
                        case sinZ.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(sinZ));
                            break;
                        case zPlusOneOverZMinusOne.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(zPlusOneOverZMinusOne));
                            break;
                        case zPlusOneOverZ.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(zPlusOneOverZ));
                            break;
                    }
                    plot.updateAxes(surface.boundingBox());
                    plot.tiltY(params.tilt);
                });
            gui.add({ tilt: params.tilt }, "tilt", -45, 45, 1)
                .onChange(v => {
                    plot.tiltY(v - params.tilt);
                    params.tilt = v;
                });

            const axesFolder = gui.addFolder("Axes");
            axesFolder.add(params.axesParameters, 'axes')
                .name("Axes").onChange(value => plot.applyAxesParameters());
            axesFolder.add(params.axesParameters, 'gridPlanes')
                .name("Layout").onChange(value => plot.applyAxesParameters());
            axesFolder.add(params.axesParameters, 'annotations')
                .name("Annotations").onChange(value => plot.applyAxesParameters());
            axesFolder.close();

            document.getElementById("gui-container").appendChild(gui.domElement);
        }
    }

    const params = {
        axesParameters: new AxesParameters({axisLabels: ["Re(z)", "log|z|", "Im(z)"]}),
        function: ComplexFunctions.ZSquaredPlusTwo,
        tilt: 15
    };

    let surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(zCubed), {showWireframe: false});
    const plot3D = new Plot3DView(canvas, canvasContainer, scene, surface.boundingBox(), params.axesParameters);
    plot3D.tiltY(params.tilt);
    const gui = new ControlsGui(plot3D, params);

    function animate() {
        requestAnimationFrame(animate);
        plot3D.render();
    }
    animate();
</script>

<!--
   -
   - POLEN AUTOMATISCH DETECTEREN
   -

Suggestie is van **simpel ‚Üí degelijk ‚Üí echt wiskundig correct**,
met concrete implementatie-idee√´n die passen bij deze code.

---

# 1Ô∏è‚É£ Praktisch & robuust: detecteer ‚Äúnumerieke explosie‚Äù

Dit is in de praktijk de **meest gebruikte methode** in visualisaties.

### Idee

Een pool herken je aan:

* |f(z)| wordt *extreem groot*
* of `NaN / Infinity`

### Implementatie (past 1-op-1 in `sample()`)

```js
const value = this._specification.func(z);

if (!Number.isFinite(value.re) ||
    !Number.isFinite(value.im)) {
    return { isPole: true };
}

const r = value.abs();
if (!Number.isFinite(r) || r > POLE_THRESHOLD) {
    return { isPole: true };
}
```

Of minimalistischer:

```js
const r = value.abs();
const isPole = !Number.isFinite(r) || r > 1e6;
```

### Wat je ermee doet

* geen vertex maken
* of hoogte afkappen
* of kleur satureren
* of gat maken

### ‚úîÔ∏è Voordelen

‚úîÔ∏è Simpel
‚úîÔ∏è Werkt voor *alle* functies
‚úîÔ∏è Geen kennis van formule nodig

### ‚ùå Nadelen

‚ùå Heuristisch
‚ùå Afhankelijk van schaal

‚û°Ô∏è **Voor jouw use-case: absoluut geschikt.**

---

# 2Ô∏è‚É£ Geometrisch: detecteer ‚Äúte grote gradi√´nt‚Äù

Polen zijn plekken waar de functie **heel snel verandert**.

### Idee

Vergelijk waarde met naburige samples:

```text
|f(z + Œ¥) - f(z)| >> |Œ¥|
```

### Implementatie (discreet)

Bijvoorbeeld in je grid:

```js
const r = value.abs();
const rRight = rightValue.abs();
const rUp    = upValue.abs();

const gradient =
    Math.max(
        Math.abs(r - rRight),
        Math.abs(r - rUp)
    );

const isPole = gradient > GRAD_THRESHOLD;
```

### ‚úîÔ∏è Voordelen

‚úîÔ∏è Schaallonafhankelijker
‚úîÔ∏è Detecteert ook ‚Äúbijna-polen‚Äù
‚úîÔ∏è Werkt goed voor `log`, `1/z`, `tan(z)`

### ‚ùå Nadelen

‚ùå Iets duurder
‚ùå Vereist naburige samples

üëâ Ideaal als **secundaire check**.

---

# 3Ô∏è‚É£ Wiskundig correct: analytische pooldetectie

Als je de functie **kent**, kun je het exact doen.

### Voorbeelden

#### `1 / f(z)`

Pool waar `f(z) = 0`

```js
if (Math.abs(denominator.abs()) < EPS) pole = true;
```

#### `log(f(z))`

Pool waar `f(z) = 0`

#### `tan(z)`

Polen waar `cos(z) = 0`

### Structuur die dit ondersteunt

```js
class ComplexSurfaceSpecification {
    constructor(func, reInterval, imInterval, poleTest=null) {
        this.func = func;
        this.poleTest = poleTest;
    }

    isPole(z) {
        return this.poleTest?.(z) ?? false;
    }
}
```

Gebruik:

```js
const spec = new ComplexSurfaceSpecification(
    z => math.log(z),
    reInterval,
    imInterval,
    z => z.abs() < 1e-3
);
```

### ‚úîÔ∏è Voordelen

‚úîÔ∏è Exact
‚úîÔ∏è Geen heuristiek
‚úîÔ∏è Wiskundig zuiver

### ‚ùå Nadelen

‚ùå Niet generiek
‚ùå Meer werk per functie

---

# 4Ô∏è‚É£ Topologisch correct: winding number / monodromie (geavanceerd)

Dit is *next level*, maar wel prachtig.

### Idee

Neem een klein kringetje rond een punt en kijk of:

```text
arg(f(z)) maakt een volledige winding
```

Dat betekent: **er zit een pool of nul binnen**.

### Discrete aanpak

```js
let winding = 0;
for (let k = 0; k < N; k++) {
    winding += phase[k+1] - phase[k];
}
const isPole = Math.abs(winding) > Math.PI;
```

üìå Dit gebruik je zelden realtime, maar:

* geweldig voor analyse
* geweldig voor automatische detectie

---

# üß© Hoe ik dit in jouw code zou integreren

### Stap 1 ‚Äî Breid `sample()` uit

```js
sample(u, v, target) {
    const z = ...
    const value = this.specification.func(z);
    const r = value.abs();

    const isPole =
        !Number.isFinite(r) ||
        r > this.specification.poleThreshold;

    return { value, isPole };
}
```

### Stap 2 ‚Äî Geometrie beslist

```js
if (sample.isPole) {
    target.set(NaN, NaN, NaN);
} else {
    target.set(re, heightMapper(r), im);
}
```

### Stap 3 ‚Äî Optioneel visueel accent

* rood
* transparant
* gat
* spike

---

# üèÅ Mijn concrete aanbeveling voor jou

Voor **jouw huidige project**:

ü•á **Numerieke explosie + log-height**

```js
const r = value.abs();
const isPole = !Number.isFinite(r) || r > 1e4;
const y = Math.log1p(Math.min(r, 1e4));
```

ü•à Optioneel: gradi√´ntcheck

ü•â Optioneel: analytische `poleTest` per functie

---

Als je wilt, kan ik:

* een `PoleDetector` class maken
* poolgebieden als heatmap tonen
* automatisch gaten *smooth* laten aflopen
* of poles in de GUI zichtbaar maken

Maar inhoudelijk:
üëâ **zo detecteer je polen robuust √©n verantwoord.**

-->