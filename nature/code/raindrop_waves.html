<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.175.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.175.0/examples/jsm/"
      }
    }
</script>

<canvas id="myCanvas" width="600" height="400" style="border: none;"></canvas><br/>
<p style="clear: both;"></p>
<label for="raindropSlider">Rain intensity: <input type="range" min="0" max="100" value="20" class="slider"
                                                   id="raindropSlider"/></label>

<script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    const Array2D = (r, c, value = 0) => [...Array(r)].map(_ => Array(c).fill(value));
    const vector = THREE.Vector3;
    const scene = new THREE.Scene();

    const canvas = document.getElementById('myCanvas');
    canvas.focus();
    const canvasWidth = canvas.getAttribute('width');
    const canvasHeight = canvas.getAttribute('height');

    //
    // Simulation constants
    //
    const dim_x = 400;
    const dim_y = 300;
    const dh = 1;  // spatial step width
    const dt = 1; //  time step width
    const c = 0.5  // The "original" wave propagation speed
    const wavePropagationVelocity = ((c * dt) / dh) ** 2;
    let raindropFrequency = 20 / 1000;

    const u = [Array2D(dim_x, dim_y), Array2D(dim_x, dim_y), Array2D(dim_x, dim_y)];  // The 3D simulation grid
    const alpha = Array2D(dim_x, dim_y, wavePropagationVelocity)

    //
    // Class definitions
    //
    class Surface {
        constructor() {
            this.colors = [Array2D(dim_x, dim_y), Array2D(dim_x, dim_y), Array2D(dim_x, dim_y)];

            this.geometry = new THREE.PlaneGeometry(2, 2, dim_x, dim_y).toNonIndexed();
            const material = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide });

            const colours = [];
            const position = this.geometry.attributes.position;
            const numVertices = position.count;
            for (let i = 0; i < numVertices; i++)
                colours.push(0, 0, 0);
            this.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colours, 3));

            this.surface = new THREE.Mesh(this.geometry, material);
            scene.add(this.surface);

        }

        colorSegmentAt(x, y, colorAsVector) {
            // Each quad has 2 triangles (6 vertices)
            const quadIndex = y * dim_x + x;
            const vertexStart = quadIndex * 6;

            const colors = this.geometry.attributes.color.array;
            for (let i = 0; i < 6; i++) {
                const vertexIndex = vertexStart + i;
                colors[vertexIndex * 3 + 0] = colorAsVector.x;
                colors[vertexIndex * 3 + 1] = colorAsVector.y;
                colors[vertexIndex * 3 + 2] = colorAsVector.z;
            }

            this.geometry.attributes.color.needsUpdate = true;
        }

        update() {
            for (let i = 0; i < dim_x; i++)
                for (let j = 0; j < dim_y; j++)
                    for (let k = 0; k < 3; k++) {
                        this.colors[k][i][j] = (u[k][i][j] + 128) / 255;
                        if (this.colors[k][i][j] < 0)
                            this.colors[k][i][j] = 0;
                        if (this.colors[k][i][j] > 1)
                            this.colors[k][i][j] = 1;
                    }

            this.updatePixelsWithNewColors();
        }

        updatePixelsWithNewColors() {
            for (let x = 0; x < dim_x; x++)
                for (let y = 0; y < dim_y; y++)
                    this.colorSegmentAt(x, y, new vector(
                        this.colors[0][x][y] * .15,
                        this.colors[1][x][y] * .3,
                        this.colors[2][x][y]));
        }

        rotateX(angle) {
            this.surface.rotateX(angle);
        }

        translate(translationVector) {
            this.surface.position.copy(translationVector);
        }
    }

    // Set up scene
    const camera = initCamera();
    const controls = new OrbitControls(camera, canvas);
    const renderer = createRenderer();
    lights();
    const surface = new Surface();
    surface.rotateX(-Math.PI / 6);
    surface.translate(new vector(0, -.5, 0));

    //
    // GUI controls
    //
    const slider = document.getElementById("raindropSlider");
    slider.oninput = function () {
        raindropFrequency = this.value / 1000;
    }

    function initCamera() {
        const camera = new THREE.PerspectiveCamera(70, canvasWidth / canvasHeight, 1, 10);
        camera.position.set(0, 0, 1);
        return camera;
    }

    function lights() {
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 1, 1);
        scene.add(light);
    }

    function createRenderer() {
        const renderer = new THREE.WebGLRenderer({antialias: true, canvas: canvas});
        renderer.setClearColor(0x191919, 1);
        renderer.setSize(canvasWidth, canvasHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        return renderer;
    }

    function centralFiniteDifferenceMethodTimestep() {
        for (let i = 0; i < dim_x; i++)
            for (let j = 0; j < dim_y; j++) {
                u[2][i][j] = u[1][i][j];
                u[1][i][j] = u[0][i][j];
            }

        for (let c = 1; c < dim_x - 1; c++)
            for (let r = 1; r < dim_y - 1; r++) {
                u[0][c][r] = alpha[c][r] * (u[1][c - 1][r] + u[1][c + 1][r] + u[1][c][r - 1] + u[1][c][r + 1] - 4 * u[1][c][r]);
                u[0][c][r] += 2 * u[1][c][r] - u[2][c][r];
            }

        // Not part of the wave equation, but we need to remove energy from the system.
        // The boundary conditions are closed. Energy cannot leave and the simulation keeps adding energy.
        for (let i = 1; i < dim_x - 1; i++)
            for (let j = 1; j < dim_y - 1; j++)
                u[0][i][j] *= 0.995;
    }

    function placeRaindrops() {
        if (Math.random() > raindropFrequency)
            return;

        const x = Math.floor(5 + Math.random() * (dim_x - 10))
        const y = Math.floor(5 + Math.random() * (dim_y - 10))

        for (let i = x - 2; i < x + 2; i++)
            for (let j = y - 2; j < y + 2; j++)
                u[0][i][j] = 120 * Math.exp(-((i - x) ** 2 + (j - y) ** 2) / 10);
    }

    function update_pixels() {
        placeRaindrops();
        centralFiniteDifferenceMethodTimestep();
        surface.update();
    }

    function animate() {
        requestAnimationFrame(animate);
        update_pixels();
        renderer.render(scene, camera);
    }

    animate(0);

</script>
