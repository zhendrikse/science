<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<canvas id="myCanvas" class="applicationCanvas" style="aspect-ratio: 2 / 1; width: 100%"></canvas>
<canvas id="graphCanvas" style="aspect-ratio: 3 / 1; margin: 0; width: 100%;"></canvas>

<script type="module">
    import { Group, Vector3, Scene, Color, PerspectiveCamera, WebGLRenderer, HemisphereLight, DirectionalLight } from "three";
    import { Spring, Ball, Graph } from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import {OrbitControls} from "three/addons/controls/OrbitControls.js";

    // --- Scene setup ---
    const canvas = document.getElementById("myCanvas");
    const scene = new Scene();

    const g = 9.8; // gravitational constant

    const camera = new PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 100);
    camera.position.set(0, 10, 30);

    const renderer = new WebGLRenderer({canvas, antialias:true, alpha: true});
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);

    scene.add(new HemisphereLight(0xffffff, 0x222222, 0.6));
    const dirLight = new DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(0, 15, 45);
    scene.add(dirLight);
    const dirLight2 = new DirectionalLight(0xffffff, 0.8);
    dirLight2.position.set(0, 0, -45);
    scene.add(dirLight2);
    renderer.shadowMap.enabled = true;
    dirLight.castShadow = true;

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;

    export class HarmonicOscillator extends Group {
        constructor({ damping = 0.2 } = {}) {
            super();
            this._masses = [];
            this._springs = [];
            this._damping = damping;
        }

        withMassAt(position, {color = "yellow"} = {}) {
            this._masses.push(new Ball(this, {position: position, color: color}));
            return this;
        }

        withSpringBetween(i, j, {color = "white"} = {}) {
            const spring = new Spring(
                this,
                this._masses[i].position(),
                this._masses[j].position().clone().sub(this._masses[i].position()),
                {color: color, coils: 20}
            );
            this._springs.push({ spring, i, j });
            return this;
        }

        update(dt=0.01) {
            const forces = this._masses.map(() => new Vector3(0, 0, 0));

            for (const { spring, i, j } of this._springs) {
                const ball1 = this._masses[i];
                const ball2 = this._masses[j];

                const axis = ball2.position().clone().sub(ball1.position());
                const direction = axis.clone().normalize();

                spring.updateAxis(axis);
                spring.updatePosition(ball1.position());

                const springForce = direction.clone().multiplyScalar(spring.force());
                const relVelocity = ball2.velocity().clone().sub(ball1.velocity());
                const dampingForce = relVelocity.projectOnVector(direction).multiplyScalar(this._damping);

                springForce.add(dampingForce);

                forces[i].add(springForce);
                forces[j].add(springForce.clone().negate());
            }

            this._masses.forEach((ball, index) => ball.semiImplicitEulerUpdate(forces[index], dt));
        }
    }

    const worldGroup = new Group();
    scene.add(worldGroup);

    const oscillator = new HarmonicOscillator({damping: 0.5})
        .withMassAt(new Vector3(-25, 0, 0));
    worldGroup.add(oscillator);

    const dt = 0.01;
    const graphCanvas = document.getElementById("graphCanvas");
    const graph = new Graph(graphCanvas, {
        dt: dt,
        scaleY: 10
    });

    graph.addSeries("x_mid", "red");


    const N = 11;
    const mid = Math.floor(N / 2) - 1;
    for (let n = 0; n < N - 1; n++)
        oscillator
            .withMassAt(new Vector3(-25 + n * 5, 0, 0), {color: n === mid ? "red" : "yellow"})
            .withSpringBetween(n, n + 1);

    // Displace
    for (let n = 0; n < N; n++) {
        oscillator._masses[n].moveTo(
            oscillator._masses[n].position().add(
                new Vector3(Math.sin(Math.PI * n / (N + 1)) * 10, 0, 0))
        );
    }

    function animate() {
        requestAnimationFrame(animate);
        oscillator.update(dt);

        const x = oscillator._masses[mid].position().x + 10;

        graph.push({ x_mid: x });
        graph.draw();

        controls.update();
        renderer.render(scene, camera);
    }
    animate();

</script>

