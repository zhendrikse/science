<style>
    #polarContainer {
        position: relative;
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        aspect-ratio: 1 / 1;
    }

    #gui-container {
        margin-top: 0.5em;
        background: #1a1a1a;
    }
</style>

<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<div id="polarContainer">
    <canvas class="applicationCanvas" id="polarCanvas" width="600" height="600"></canvas><br/>
</div>
<div id="gui-container"></div>

<script type="module">
    import * as THREE from "three";
    import { Axes, AxesParameters, ClassicalAxesLayout, ClassicalAnnotations }
        from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import { Plot3D, SurfaceDefinition, TangentFrameView }
        from 'https://www.hendrikse.name/science/js/3d-surface-components.js';
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";

    const canvasContainer = document.getElementById("polarContainer");
    const canvas = document.getElementById("polarCanvas");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x131313);
    const worldGroup = new THREE.Group();
    scene.add(worldGroup);

    const radius = 2;
    const params = {
        theta: 45,
        phi: 0,
        axesParameters: new AxesParameters({xyPlane: false, yzPlane: false, axesLabels: false})
    };

    class ControlsGui {
        constructor(axesLayout, annotations) {
            const gui = new GUI({width: 300, autoPlace: false});

            gui.add(params, "theta", 0, 180, 0.1)
                .name("θ (theta)")
                .onChange(value => {
                    params.theta = value;
                    tangentFrame.update(value / 180, params.phi / 360);
                    const pos = new THREE.Vector3(0, 0, 0);
                    sphereSurface.definition().sample(value / 180, params.phi / 360, pos);
                    radialLine.geometry.setFromPoints([new THREE.Vector3(0, 0, 0), pos]);
                });

            gui.add(params, "phi", 0, 360, 0.1)
                .name("φ (phi)")
                .onChange(value => {
                    params.phi = value;
                    tangentFrame.update(params.theta / 180, value / 360);
                    const pos = new THREE.Vector3(0, 0, 0);
                    sphereSurface.definition().sample(params.theta / 180, value / 360, pos);
                    radialLine.geometry.setFromPoints([new THREE.Vector3(0, 0, 0), pos]);
                });

            const axesFolder = gui.addFolder("Axes");
            axesFolder.add(params.axesParameters, 'axesLines')
                .name("Axes").onChange(value => value ? axesLayout.showAxes() : axesLayout.hideAxes());
            axesFolder.add(params.axesParameters, 'axesLabels')
                .name("Axes labels").onChange(value => annotations.visible = value);
            axesFolder.add(params.axesParameters, 'xyPlane')
                .name("XY plane").onChange(value => value ? axesLayout.showXY() : axesLayout.hideXY());
            axesFolder.add(params.axesParameters, 'xzPlane')
                .name("XZ plane").onChange(value => value ? axesLayout.showXZ() : axesLayout.hideXZ());
            axesFolder.add(params.axesParameters, 'yzPlane')
                .name("YZ plane").onChange(value => value ? axesLayout.showYZ() : axesLayout.hideYZ());
            axesFolder.close();

            document
                .getElementById("gui-container")
                .appendChild(gui.domElement);
        }
    }

    class SphereSurfaceDefinition extends SurfaceDefinition {
        constructor(radius) {
            super();
            this.radius = radius;
        }

        sample(u, v, target) {
            // u in [0,1] → theta in [0, π]
            // v in [0,1] → phi   in [0, 2π]
            const theta = u * Math.PI;
            const phi   = -v * 2 * Math.PI;

            const r = this.radius;
            target.set(
                r * Math.sin(theta) * Math.cos(phi),
                r * Math.cos(theta),
                r * Math.sin(theta) * Math.sin(phi)
            );
        }
    }

    // Class only needed to interface with DifferentialGeometry
    class Surface {
        constructor(definition) {
            this._definition = definition;
        }
        definition() {
            return this._definition;
        }
    }

    const sphereSurface = new Surface(new SphereSurfaceDefinition(radius));
    const tangentFrame = new TangentFrameView(sphereSurface, {
        u: params.theta / 180,
        v: params.phi / 360,
        color: "#ff0",
        scale: 1.0,
        showAxes: true,
    });
    worldGroup.add(tangentFrame);

    // Radial line
    const pos = new THREE.Vector3(0, 0, 0);
    sphereSurface.definition().sample(params.theta / 180, params.phi / 360, pos);
    const radialLine = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), pos]),
        new THREE.LineBasicMaterial({ color: 0xffffff })
    );
    worldGroup.add(radialLine);

    const axes = new Axes();
    worldGroup.add(axes);
    const axesLayout = new ClassicalAxesLayout(radius * 3, 10);
    const annotations = new ClassicalAnnotations(canvasContainer, radius * 3, 10);
    axesLayout.hideXY();
    axesLayout.hideYZ();
    axes.setLayout(axesLayout);
    axes.setAnnotations(annotations);
    worldGroup.add(annotations);
    annotations.visible = params.axesParameters.axesLabels;

    const plot3D = new Plot3D(canvas, scene, axes);
    const bbox = new THREE.Box3();
    bbox.setFromObject( worldGroup );
    plot3D.fitToBoundingBox(bbox, {padding: 0.8, translationY: -2});

    const resolution = 30;
    const geometry = new THREE.SphereGeometry( radius, resolution, resolution );
    const material = new THREE.MeshStandardMaterial( { side:THREE.DoubleSide, color: 0x00ffff, transparent: true, opacity: 0.1, wireframe: true } );
    const sphere = new THREE.Mesh( geometry, material );
    sphere.position.set(0, 0, 0);
    worldGroup.add( sphere );

    const gui = new ControlsGui(axesLayout, annotations);

    function animate() {
        requestAnimationFrame(animate);
        plot3D.render();
    }
    animate();
</script>
