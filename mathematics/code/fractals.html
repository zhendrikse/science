<style>
    html, body {
        background: #131313;
        margin: 0;
        padding: 0;
        overflow-x: hidden;
        height: 100%;
    }

    #canvas-wrapper {
        position: relative;
        width: 100%;        /* past binnen content area */
        max-width: 800px;   /* cap op desktop */
        aspect-ratio: 1 / 1;
        margin: 0 auto;
    }

    #fractalsCanvas {
        width: 100%;        /* past altijd in de wrapper */
        height: 100%;
        display: block;
    }

    table {
        width: 100%;
        border: none;
        max-width: 800px;
        margin: 0 auto;
    }
    td {
        white-space: nowrap;
        border: none;
    }
</style>
<div id="canvas-wrapper">
    <canvas id="fractalsCanvas"></canvas>
</div>
<table>
    <tr>
        <td><label for="kochSnowflake"><input type="radio" id="kochSnowflake"/>Koch snowflake</label></td>
        <td><label for="cesaroFractal"><input type="radio" id="cesaroFractal"/>Cesaro fractal</label></td>
    </tr>
    <tr>
        <td><label for="sierpinskiTriangle"><input type="radio" id="sierpinskiTriangle"/>Sierpinski triangle</label></td>
        <td><label for="tSquareFractal"><input type="radio" id="tSquareFractal"/>T-square fractal</label></td>
    </tr>
    <tr>
        <td><label for="dragonCurve"><input type="radio" id="dragonCurve"/>Dragon curve</label></td>
        <td>&nbsp;</td>
    </tr>
</table>

<script>
    let canvas = document.getElementById("fractalsCanvas");
    let context = canvas.getContext("2d");

    const radioButtons = new Map();
    radioButtons.set("kochSnowflake", drawSnowflake);
    radioButtons.set("cesaroFractal", drawCesaro);
    radioButtons.set("dragonCurve", drawDragonCurve);
    radioButtons.set("sierpinskiTriangle", drawSierpinskiTriangle);
    radioButtons.set("tSquareFractal", drawTSquare);

    function hsvToRgb(h, s, v) {
        let r, g, b;
        let i = Math.floor(h * 6);
        let f = h * 6 - i;
        let p = v * (1 - s);
        let q = v * (1 - f * s);
        let t = v * (1 - (1 - f) * s);

        switch (i % 6) {
            case 0: r = v, g = t, b = p; break;
            case 1: r = q, g = v, b = p; break;
            case 2: r = p, g = v, b = t; break;
            case 3: r = p, g = q, b = v; break;
            case 4: r = t, g = p, b = v; break;
            case 5: r = v, g = p, b = q; break;
        }

        return [Math.round(r), Math.round(g), Math.round(b)];
    }

    const Colors = Object.freeze({
        RED: [1, 0, 0],
        GREEN: [0, 1, 0],
        BLUE: [0, 0, 1],
        CYAN: [0, 1, 1],
        MAGENTA: [1, 0, 1],
        YELLOW: [1, 1, 0],
        ORANGE: [1, .6, 0],
        PURPLE: [0.4, 0.2, 0.6],
        GRAY: [.5, .5, .5],
        WHITE: [1, 1, 1],
        BLACK: [0, 0, 0],
    });

    class Pixel {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
        }
    }

    class PixelImage {
        constructor(width, height, pixelSize=1, backgroundColor=Colors.BLACK) {
            const Array2D = (r, c) => [...Array(r)].map(_=>Array(c).fill(backgroundColor));
            this.pixelSize = pixelSize;
            this.width = width;
            this.height = height;
            this.colours = Array2D(this.dimX(), this.dimY());
        }

        #asCanvasImageData(context) {
            const imageData = context.createImageData(this.width, this.height);
            for (let x = 0 ; x < this.width; x++)
                for (let y = 0 ; y < this.height; y++)
                    this.#setPixelColor(imageData.data, new Pixel(x, y, this.colours[x][y], this.pixelSize));
            return imageData;
        }

        #setPixelColor(imageData, pixel) {
            let coordinate = pixel.y * (this.width * 4) + pixel.x * 4;
            imageData[coordinate++] = pixel.color[0] * 255;
            imageData[coordinate++] = pixel.color[1] * 255;
            imageData[coordinate++] = pixel.color[2] * 255;
            imageData[coordinate++] = 255
        }

        setColour = (pixel) => {
            if (pixel.x < 0 || pixel.y < 0 || pixel.x >= this.dimX() || pixel.y >= this.dimY()) return;
            this.colours[pixel.x][pixel.y] = pixel.color;
        }

        dimX = () => this.width / this.pixelSize;
        dimY = () => this.height / this.pixelSize;

        drawLine(fromPixel, toPixel) {
            // Bresenham with color interpolation
            let x0 = fromPixel.x | 0,
                y0 = fromPixel.y | 0,
                x1 = toPixel.x | 0,
                y1 = toPixel.y | 0;

            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;

            // Interpolate color
            const steps = Math.max(dx, dy) || 1;
            const dr = (toPixel.color[0] - fromPixel.color[0]) / steps;
            const dg = (toPixel.color[1] - fromPixel.color[1]) / steps;
            const db = (toPixel.color[2] - fromPixel.color[2]) / steps;

            let step = 0;

            while (true) {
                const r = fromPixel.color[0] + dr * step;
                const g = fromPixel.color[1] + dg * step;
                const b = fromPixel.color[2] + db * step;
                this.setColour(new Pixel(x0, y0, [r, g, b]));

                if (x0 === x1 && y0 === y1) break;

                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }

                step++;
            }
        }


        render(context) {
            context.clearRect(0, 0, this.width, this.height);
            context.putImageData(this.#asCanvasImageData(context), 0, 0);
        }
    }

    class TurtleRenderer {
        constructor(image, margin = 0.05) {
            this.image = image;
            this.margin = margin; // 5% marge
            this.reset();
        }

        reset() {
            this.pixels = [];
            this.penstates = [];
            this.minX = Infinity;
            this.maxX = -Infinity;
            this.minY = Infinity;
            this.maxY = -Infinity;
        }

        plot(x, y, color=Colors.CYAN, draw=true) {
            this.pixels.push(new Pixel(x, y, color));
            this.penstates.push(draw);
            this.minX = Math.min(this.minX, x);
            this.maxX = Math.max(this.maxX, x);
            this.minY = Math.min(this.minY, y);
            this.maxY = Math.max(this.maxY, y);
        }

        transform(pixel) {
            const fractalW = this.maxX - this.minX || 1;
            const fractalH = this.maxY - this.minY || 1;

            const scale = Math.min(
                this.image.width / fractalW,
                this.image.height / fractalH
            ) * (1 - this.margin * 2);

            const offsetX = this.image.width / 2 - (this.minX + fractalW / 2) * scale;
            const offsetY = this.image.height / 2 - (this.minY + fractalH / 2) * scale;

            return new Pixel(pixel.x * scale + offsetX, this.image.height - (pixel.y * scale + offsetY), pixel.color);
        }

        drawPaths(lineWidth=2) {
            for (let i = 1; i < this.pixels.length; i++) {
                if (!this.penstates[i]) continue;
                const fromPixel = this.transform(this.pixels[i - 1]);
                const toPixel = this.transform(this.pixels[i]);
                this.image.drawLine(fromPixel, toPixel, lineWidth);
            }
        }

        render = (context) => this.image.render(context);
    }

    class Turtle {
        static PenState = Object.freeze({
            UP: [1, 0, 0],
            DOWN: [0, 1, 0]
        });

        constructor(renderer, penState=Turtle.PenState.UP, color=Colors.YELLOW) {
            this.currentColor = color;
            this.penState = penState;
            this.angle = 0;
            this.x = 0;
            this.y = 0;
            this.renderer = renderer;
        }

        degreeToRadians = (angle) => angle * Math.PI / 180;
        right= (angle) => this.angle += this.degreeToRadians(angle);
        left = (angle) => this.angle -= this.degreeToRadians(angle);
        backward = (distance) => this.forward(-distance);
        penDown= () => this.penState = Turtle.PenState.DOWN;
        penUp = () => this.penState = Turtle.PenState.UP;
        draw = (lineWidth = 2) => this.renderer.drawPaths(lineWidth);
        render = (context) => this.renderer.render(context);

        forward(distance) {
            const newX = this.x + distance * Math.cos(this.angle);
            const newY = this.y + distance * Math.sin(this.angle);
            this.goto(newX, newY);
        }

        color(color) {
            this.currentColor = color;
        }

        goto(x, y) {
            this.renderer.plot(x, y, this.currentColor, this.penState === Turtle.PenState.DOWN);
            this.x = x;
            this.y = y;
        }
    }

    function kochSnowflake(turtle, length, depth) {
        if (depth === 0)
            turtle.forward(length);
        else {
            length /= 3.0;
            kochSnowflake(turtle, length, depth - 1);
            turtle.left(60);
            kochSnowflake(turtle, length, depth - 1);
            turtle.right(120);
            kochSnowflake(turtle, length, depth - 1);
            turtle.left(60);
            kochSnowflake(turtle, length, depth - 1);
        }
    }

    function drawSnowflake(turtle) {
        turtle.goto(-150, 90)
        turtle.penDown()
        turtle.color(Colors.YELLOW);
        for (let i = 0; i < 3; i++)
            kochSnowflake(turtle, 300, 4);
        turtle.right(120);
    }

    function cesaroFractal(turtle, depth, length) {
        if (depth === 0)
            turtle.forward(length);
        else {
            const angles = [85, -170, 85, 0]
            for (let index = 0; index < angles.length; index++) {
                cesaroFractal(turtle, depth - 1, length / 3);
                turtle.left(angles[index]);
            }
        }
    }

    function drawCesaro(turtle) {
        turtle.goto(10, 300);
        turtle.penDown();
        turtle.color(Colors.GREEN);
        cesaroFractal(turtle, 6, 4000);
    }

    function dragonCurve(n) {
        if (n === 0) {
            return [[0, 0], [1, 0]];
        } else {
            const prevPoints = dragonCurve(n - 1);
            const newPoints = [];
            for (let i = 0; i < prevPoints.length - 1; i++) {
                const [x1, y1] = prevPoints[i];
                const [x2, y2] = prevPoints[i + 1];
                const dx = x2 - x1;
                const dy = y2 - y1;

                let new_dx, new_dy;
                if (i % 2 === 0) {
                    new_dx = dy;
                    new_dy = -dx;
                } else {
                    new_dx = -dy;
                    new_dy = dx;
                }

                const new_x = x1 + dx / 2 + new_dx / 2;
                const new_y = y1 + dy / 2 + new_dy / 2;

                newPoints.push([x1, y1], [new_x, new_y]);
            }
            newPoints.push(prevPoints[prevPoints.length - 1]);
            return newPoints;
        }
    }

    function drawDragonCurve(turtle) {
        const points = dragonCurve(12);
        const scale = 400;
        const offsetX = canvas.width / 4.5;
        const offsetY = canvas.height / 1.5;

        // Put turtle on first point without drawing
        const [x0, y0] = points[0];
        turtle.penUp();
        turtle.goto(x0 * scale + offsetX, y0 * scale + offsetY);

        // Next plot all other points with color
        turtle.penDown();
        for (let i = 1; i < points.length; i++) {
            const [x, y] = points[i];
            turtle.color(hsvToRgb(i / points.length, 1, 1));
            turtle.goto(x * scale + offsetX, y * scale + offsetY);
        }
    }

    function tSquare(turtle, n, x, y, w) {
        if (n !== 0) {
            turtle.color(hsvToRgb(w * .5, 1, 1));
            turtle.goto(x, y);
            turtle.penDown();
            turtle.goto(x + w, y);
            turtle.goto(x + w, y + w);
            turtle.goto(x, y + w);
            turtle.goto(x, y);
            turtle.penUp();
            const new_w = w / 3
            tSquare(turtle, n - 1, x + new_w, y + new_w, new_w)
            tSquare(turtle, n - 1, x + new_w, y + new_w * 5, new_w)
            tSquare(turtle, n - 1, x + new_w * 5, y + new_w * 5, new_w)
            tSquare(turtle, n - 1, x + new_w * 5, y + new_w, new_w)
        }
    }

    function drawTSquare(turtle) {
        const n = 7;
        const w = 2**n;
        turtle.color(Colors.RED);
        turtle.penUp();
        turtle.goto(0, 0);
        tSquare(turtle, n, 0, 0, w);
    }

    function sierpinskiTriangle(turtle, length, depth) {
        if (depth === 0)
            for (let i = 0; i < 3; i++) {
                turtle.forward(length);
                turtle.left(120);
            } else {
            sierpinskiTriangle(turtle, length / 2, depth - 1);
            turtle.forward(length / 2);
            sierpinskiTriangle(turtle, length / 2, depth - 1);
            turtle.backward(length / 2);
            turtle.left(60);
            turtle.forward(length / 2);
            turtle.right(60);
            sierpinskiTriangle(turtle, length / 2, depth - 1);
            turtle.left(60);
            turtle.backward(length / 2);
            turtle.right(60);
        }
    }

    function drawSierpinskiTriangle(turtle) {
        turtle.goto(50, 375);
        turtle.penDown();
        sierpinskiTriangle(turtle, 400, 5);
    }

    function resetButtons() {
        for (const [key, value] of radioButtons)
            document.getElementById(key).checked = false;
    }

    function redraw() {
        const turtle = createTurtle();
        currentFractal(turtle);
        turtle.draw();
        turtle.render(context);
    }

    function resizeCanvas() {
        const wrapper = document.getElementById("canvas-wrapper");
        const rect = wrapper.getBoundingClientRect(); // echte schermafmetingen
        const dpr = window.devicePixelRatio || 1;

        canvas.width  = Math.floor(rect.width * dpr);
        canvas.height = Math.floor(rect.height * dpr);

        canvas.style.width  = rect.width + "px";
        canvas.style.height = rect.height + "px";

        redraw();
    }

    let currentFractal = drawDragonCurve;

    const createTurtle = () =>
        new Turtle(new TurtleRenderer(new PixelImage(context.canvas.width, context.canvas.height)));

    for (const [key, value] of radioButtons)
        document.getElementById(key).onclick = function() {
            resetButtons();
            this.checked = true;
            currentFractal = value;
            redraw();
        };

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas(); // initial draw
    document.getElementById("dragonCurve").checked = true;

</script>

