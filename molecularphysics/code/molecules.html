<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.175.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.175.0/examples/jsm/"
      }
    }
</script>

<canvas id="myCanvas" width="600" height="400" style="border: none;"></canvas>
<div style="margin-top: 10px;">
    <label for="ammoniaToggle"><input type="radio" id="ammoniaToggle"/>Ammonia  </label>
    <label for="ethanolToggle"><input type="radio" id="ethanolToggle"/>Ethanol  </label>
    <label for="lactateToggle"><input type="radio" id="lactateToggle"/>Lactate  </label>
    <label for="methaneToggle"><input type="radio" id="methaneToggle"/>Methane  </label>
    <label for="waterToggle"><input type="radio" id="waterToggle"/>Water  </label>
</div>
<div style="margin-top: 10px;">
    <label for="atomicRadiusSlider">Atomic radius scale factor: <input type="range" min="3" max="25" value="6" class="slider" id="atomicRadiusSlider"/></label>
</div>
<div style="margin-top: 10px;">
    <button id="resetView">ðŸ”„ Reset View</button>
    <button id="zoomIn">âž• Zoom In</button>
    <button id="zoomOut">âž– Zoom Out</button>
    <button id="wood">Wood</button>
    <button id="metal">Metal</button>
</div>

<script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    const vector = THREE.Vector3;

    console.clear( );

    const canvas = document.getElementById('myCanvas');
    canvas.focus();
    const canvasWidth = canvas.getAttribute('width');
    const canvasHeight = canvas.getAttribute('height');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a1a);

    const cameraBase = new vector(50, 50, 50);
    const camera = new THREE.PerspectiveCamera( 2.5, canvasWidth/canvasHeight, 1, 1000 );
    camera.position.set( cameraBase.x, cameraBase.y,  cameraBase.z );
    camera.updateProjectionMatrix();
    camera.lookAt( scene.position );

    const renderer = new THREE.WebGLRenderer( {antialias: true, canvas: canvas} );
    renderer.setSize( canvasWidth, canvasHeight );
    renderer.setAnimationLoop( animationLoop );

    const controls = new OrbitControls( camera, canvas );
    controls.enableDamping = true;
    controls.autoRotate = true;

    // lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 5, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    const pointLight1 = new THREE.PointLight(0xffffff, 0.6);
    pointLight1.position.set(-5, -5, -5);
    scene.add(pointLight1);

    let zoomLevel = 1; // 1 = default
    function updateCameraPosition() {
        camera.position.set(
            cameraBase.x * zoomLevel,
            cameraBase.y * zoomLevel,
            cameraBase.z * zoomLevel
        );
        camera.lookAt(0, 0, 0);
        controls.update();
    }

    //
    // Class definitions
    //
    class Sphere {
        constructor(positionVector=new vector(0, 0, 0), radius=0.05, colour=new THREE.Color(1, 1, 1), metallic=false, opacity=1) {
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshPhysicalMaterial({
                color: colour,
                metalness: metallic ? 0.8 : 0.1,
                roughness: metallic ? 0.2 : 0.7,
                clearcoat: metallic ? 0.8 : 0.3,
                clearcoatRoughness: 0.2,
                envMapIntensity: 1.0,
                wireframe: false
            });
            this.sphere = new THREE.Mesh(geometry, material);
            this.sphere.position.set(positionVector.x, positionVector.y, positionVector.z);
            this.sphere.castShadow = true;
            this.sphere.receiveShadow = true;
            scene.add(this.sphere);
        }

        show() {
            this.sphere.visible = true;
        }

        hide() {
            this.sphere.visible = false;
        }

        moveTo(newPositionVector) {
            this.sphere.position.copy(newPositionVector);
        }

        setRadiusTo(radius) {
            this.sphere.scale.setScalar(radius);
        }

        setColorTo(rgbColorVector) {
            this.sphere.material.color.setFromVector3(rgbColorVector);
        }

        pos() {
            return this.sphere.position;
        }

        positionVectorTo(other) {
            return new vector().copy(other.sphere.position).sub(this.sphere.position);
        }

        distanceToSquared(other) {
            return this.sphere.position.distanceToSquared(other.sphere.position);
        }

        distanceTo(other) {
            return this.sphere.position.distanceTo(other.sphere.position);
        }
    }

    class Atom extends Sphere {
        constructor(pos=new vector(0, 0, 0), radius, colour) {
            super(pos, radius, colour);
            this._radius = radius;
        }

        scaleBy(scaleFactor) {
            this.setRadiusTo(this._radius * scaleFactor);
        }

        radius() {
            return this._radius;
        }
    }

    class Bond {
        static WoodColor = new THREE.Color(0xface8d);
        static MetalColor = new THREE.Color(0xaaa9ad);

        constructor(atom1, atom2, radius, colour=Bond.MetalColor) {
            this._radius = radius;
            // Gradient for bonds
            const startColor = new THREE.Color(0x666666);
            const endColor = new THREE.Color(0x444444);

            const geometry = this.bondGeometry(radius, startColor, endColor, atom1.distanceTo(atom2))
                .rotateX(-Math.PI / 2);
            this.material = new THREE.MeshLambertMaterial({
                color: colour,
                emissive: colour,
                emissiveIntensity: .1,
            });
            this.mesh = new THREE.Mesh(geometry, this.material);
            this.mesh.position.copy(new vector().copy(atom1.pos()).add(atom2.pos()).multiplyScalar(.5));
            this.mesh.lookAt(atom2.pos());
            scene.add(this.mesh);
        }

        bondGeometry(radius, startColor, endColor, length) {
            const geometry = new THREE.CylinderGeometry(radius, radius, length, 16, 8);
            const positions = geometry.attributes.position.array;
            const colors = new Float32Array(geometry.attributes.position.count * 3);
            for (let i = 0; i < geometry.attributes.position.count; i++) {
                const y = positions[i * 3 + 1];
                const colour = new THREE.Color().lerpColors(startColor, endColor, (y + length / 2) / length);
                colors[i * 3] = colour.r;
                colors[i * 3 + 1] = colour.g;
                colors[i * 3 + 2] = colour.b;
            }
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            return geometry
        }

        makeMetal() {
            this.material.color.set(Bond.MetalColor);
            this.material.color.needsUpdate = true;
        }

        makeWood() {
            this.material.color.set(Bond.WoodColor);
            this.material.color.needsUpdate = true;
        }

        show() {
            this.mesh.visible = true;
        }

        hide() {
            this.mesh.visible = false;
        }
    }

    class Molecule {
        constructor() {
            this._atoms = [];
            this._bonds = [];
        }

        hide() {
            for (let i = 0; i < this._bonds.length; i++)
                this._bonds[i].hide();
            for (let i = 0; i < this._atoms.length; i++)
                this._atoms[i].hide();
        }

        show() {
            for (let i = 0; i < this._bonds.length; i++)
                this._bonds[i].show();
            for (let i = 0; i < this._atoms.length; i++)
                this._atoms[i].show();
        }

        useWoodenBonds() {
            for (let i = 0; i < this._bonds.length; i++)
                this._bonds[i].makeWood();
            renderer.render(scene, camera);
        }

        useMetalBonds() {
            for (let i = 0; i < this._bonds.length; i++)
                this._bonds[i].makeMetal();
            renderer.render(scene, camera);
        }

        scaleAtomicRadiusBy(scaleFactor) {
            for (let i = 0; i < this._atoms.length; i++)
                this._atoms[i].scaleBy(scaleFactor);
        }
    }

    class Ammonia extends Molecule {
        constructor(bondRadius=0.05, hydrogenRadius = 0.265, nitrogenRadius = 0.35) {
            super();
            const r0 = 2;
            const phi = 107 * Math.PI / 180;
            const zN = Math.sqrt((1 + 2 * Math.cos(phi)) / (1 - Math.cos(phi)) / 2) * r0;

            const positions = [new vector(r0 / 2, 0, -zN / 4)];
            positions.push(new vector(-r0 / 4, Math.sqrt(3) * r0 / 4, -zN / 4));
            positions.push(new vector(-r0 / 4, -Math.sqrt(3) * r0 / 4, -zN / 4));
            for (let index = 0; index < positions.length; index++)
                this._atoms.push(new Atom(positions[index], hydrogenRadius, new THREE.Color('white')));

            const nitrogenAtom = new Atom(new vector(0, 0, zN / 4), nitrogenRadius, new THREE.Color('green'));
            for (let index = 0; index < this._atoms.length; index++)
                this._bonds.push(new Bond(this._atoms[index], nitrogenAtom, bondRadius));

            this._atoms.push(nitrogenAtom);
        }
    }

    class Water extends Molecule {
        constructor(oxygenRadius = 0.3, hydrogenRadius = 0.2, bondRadius=0.05) {
            super();
            const phi_hydrogen = (Math.PI * 104.5 / 180) / 2;
            const sin_phi = Math.sin(phi_hydrogen);
            const cos_phi = Math.cos(phi_hydrogen);

            this._atoms.push(new Atom(new vector(0, cos_phi, sin_phi), hydrogenRadius, new THREE.Color('blue')));
            this._atoms.push(new Atom(new vector(0, cos_phi, -sin_phi), hydrogenRadius, new THREE.Color('blue')));

            const oxygenAtom = new Atom(new vector(0, 0, 0), oxygenRadius, new THREE.Color('red'));
            this._bonds.push(new Bond(this._atoms[0], oxygenAtom, bondRadius));
            this._bonds.push(new Bond(this._atoms[1], oxygenAtom, bondRadius));
            this._atoms.push(oxygenAtom);
        }
    }

    class Methane extends Molecule {
        constructor(carbonRadius = 0.25, hydrogenRadius = 0.2, bondRadius=0.05) {
            super();
            const sin_phi = 1 / 3;
            const cos_phi = 2 * Math.sqrt(2) / 3;

            const positions = [new vector(0, 1, 0)];
            positions.push(new vector(cos_phi, -sin_phi, 0));
            positions.push(new vector(-cos_phi / 2, -sin_phi,  Math.sqrt(3) / 2 * cos_phi));
            positions.push(new vector(-cos_phi / 2, -sin_phi, -Math.sqrt(3) / 2 * cos_phi));
            for (let index = 0; index < positions.length; index++)
                this._atoms.push(new Atom(positions[index], hydrogenRadius, new THREE.Color('white')));

            const carbonAtom = new Atom(new vector(0, 0, 0), carbonRadius, new THREE.Color('black'));
            for (let index = 0; index < this._atoms.length; index++)
                this._bonds.push(new Bond(this._atoms[index], carbonAtom, bondRadius));

            this._atoms.push(carbonAtom)
        }
    }

    class Ethanol extends Molecule {
        constructor(carbonRadius=0.25, oxygenRadius=0.3, hydrogenRadius=0.2, bondRadius=0.05) {
            super();
            const hydrogen_positions = [new vector(1, -1/2, -1/2), new vector(1, -1/2, 1/2)]
            hydrogen_positions.push(new vector(-1.25, 1/2, -1/2), new vector(-1.25, 1/2, 1/2));
            hydrogen_positions.push(new vector(-1.1, -1/2, 0), new vector(1.75, 0.75, 0));
            for (let index = 0; index < hydrogen_positions.length; index++)
                this._atoms.push(new Atom(hydrogen_positions[index], hydrogenRadius, new THREE.Color('white')));

            const carbon_positions = [new vector(1/2, 0, 0), new vector(-1/2, 0, 0)]
            const carbonAtom1 = new Atom(new vector( .5, 0, 0), carbonRadius, new THREE.Color('black'));
            const carbonAtom2 = new Atom(new vector(-.5, 0, 0), carbonRadius, new THREE.Color('black'));
            this._atoms.push(carbonAtom1);
            this._atoms.push(carbonAtom2);
            this._bonds.push(new Bond(carbonAtom1, carbonAtom2, bondRadius));

            for (let index = 0; index < hydrogen_positions.length - 1; index++) {
                const carbonAtom = (index === 0 || index === 1) ? carbonAtom1 : carbonAtom2;
                this._bonds.push(new Bond(carbonAtom, this._atoms[index], bondRadius));
            }

            const oxygenAtom = new Atom(new vector(1, 1, 0), oxygenRadius, new THREE.Color('red'));
            this._atoms.push(oxygenAtom);

            this._bonds.push(new Bond(this._atoms[5], oxygenAtom, bondRadius));
            this._bonds.push(new Bond(carbonAtom1, oxygenAtom, bondRadius));
        }
    }

    class Lactate extends Molecule {
        constructor(carbonRadius=0.25, oxygenRadius=0.3, hydrogenRadius=0.2, bondRadius=0.05) {
            super();
            const sqrt3 = Math.sqrt(3),
                sqrt3h = sqrt3 / 2,
                sin_phi = 1 / 3,
                cos_phi = 2 * Math.sqrt(2) / 3,
                carbonPositions = [new vector(-1, 0, 0), new vector(0 ,0, 0), new vector(sin_phi, -cos_phi / 2, -sqrt3h * cos_phi)],
                carbonAtoms = [];

            for (let index = 0; index < carbonPositions.length; index++)
                carbonAtoms.push(new Atom(carbonPositions[index], carbonRadius, new THREE.Color('black')));

            const hydrogenPositions = [new vector(-1 - sin_phi, -cos_phi, 0), new vector(-1 - sin_phi, cos_phi / 2,sqrt3h * cos_phi)];
            hydrogenPositions.push(new vector(-1 - sin_phi,cos_phi / 2, -sqrt3h * cos_phi), new vector(sin_phi, -cos_phi / 2, 0 + sqrt3h * cos_phi));
            hydrogenPositions.push(new vector(1.25 + sin_phi,-0.5 - cos_phi / 2, -1.25 - sqrt3h * cos_phi));
            hydrogenPositions.push(new vector(0.75 - sin_phi, 1 + cos_phi / 2, +sqrt3h * cos_phi));
            const hydrogenAtoms = [];
            for (let index = 0; index < hydrogenPositions.length; index++)
                hydrogenAtoms.push(new Atom(hydrogenPositions[index], hydrogenRadius, new THREE.Color('white')));

            const oxygenPositions = [new vector(0.75, 1, 0)];
            oxygenPositions.push(new vector(1.25, -0.5, -1.25));
            oxygenPositions.push(new vector(0.25, -1.25, -1.25)); // Double bond is located here
            const oxygenAtoms = [];
            for (let index = 0; index < oxygenPositions.length; index++)
                oxygenAtoms.push(new Atom(oxygenPositions[index], oxygenRadius, new THREE.Color('red')));

            this._bonds.push(new Bond(carbonAtoms[1], hydrogenAtoms[3], bondRadius));
            this._bonds.push(new Bond(carbonAtoms[1], oxygenAtoms[0], bondRadius));
            this._bonds.push(new Bond(carbonAtoms[2], oxygenAtoms[1], bondRadius));
            this._bonds.push(new Bond(carbonAtoms[2], oxygenAtoms[2], 2.5 * bondRadius));
            this._bonds.push(new Bond(oxygenAtoms[1], hydrogenAtoms[4], bondRadius));
            this._bonds.push(new Bond(carbonAtoms[2], oxygenAtoms[1], bondRadius));
            this._bonds.push(new Bond(hydrogenAtoms[5], oxygenAtoms[0], bondRadius));
            this._bonds.push(new Bond(carbonAtoms[0], hydrogenAtoms[0], bondRadius));
            this._bonds.push(new Bond(carbonAtoms[0], hydrogenAtoms[1], bondRadius));
            this._bonds.push(new Bond(carbonAtoms[0], hydrogenAtoms[2], bondRadius));
            this._bonds.push(new Bond(carbonAtoms[0], carbonAtoms[1], bondRadius));
            this._bonds.push(new Bond(carbonAtoms[1], carbonAtoms[2], bondRadius));

            for (let index = 0; index < oxygenAtoms.length; index++)
                this._atoms.push(oxygenAtoms[index]);
            for (let index = 0; index < hydrogenAtoms.length; index++)
                this._atoms.push(hydrogenAtoms[index]);
            for (let index = 0; index < carbonAtoms.length; index++)
                this._atoms.push(carbonAtoms[index]);
        }
    }

    function hideMolecules() {
        for (let index = 0; index < molecules.length; index++) {
            molecules[index].hide();
            radioButtons[index].checked = false;
        }
    }

    function animationLoop() {
        controls.update();
        renderer.render( scene, camera );
    }

    // GUI controls
    document.getElementById('resetView').addEventListener('click', () => {
        zoomLevel = 1;
        updateCameraPosition();
    });

    document.getElementById('zoomIn').addEventListener('click', () => {
        zoomLevel *= 0.9;
        updateCameraPosition();
    });

    document.getElementById('zoomOut').addEventListener('click', () => {
        zoomLevel *= 1.1;
        updateCameraPosition();
    });

    document.getElementById('wood').addEventListener('click', () => {
        for (let index = 0; index < molecules.length; index++)
            molecules[index].useWoodenBonds();
    });

    document.getElementById('metal').addEventListener('click', () => {
        for (let index = 0; index < molecules.length; index++)
            molecules[index].useMetalBonds();
    });

    const slider = document.getElementById("atomicRadiusSlider");
    slider.oninput = function () {
        for (let index = 0; index < molecules.length; index++)
            molecules[index].scaleAtomicRadiusBy(this.value * .5);
    }

    const molecules = [new Ammonia(), new Ethanol(), new Lactate(), new Methane(), new Water()];
    const radioButtons = [
        document.getElementById('ammoniaToggle'),
        document.getElementById('ethanolToggle'),
        document.getElementById('lactateToggle'),
        document.getElementById('methaneToggle'),
        document.getElementById('waterToggle')
    ]

    hideMolecules();
    molecules[0].show();
    document.getElementById('ammoniaToggle').checked = true;

    for (let index = 0; index < molecules.length; index++)
        radioButtons[index].onclick = function() {
            hideMolecules();
            molecules[index].show();
            radioButtons[index].checked = true;
        }

</script>