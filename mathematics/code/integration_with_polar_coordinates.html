<style>
    canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
    }

    #container {
        position: relative;
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        aspect-ratio: 1 / 1;
    }
</style>

<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<div id="container">
    <canvas id="myCanvas"></canvas><br/>
</div>

<div id="ui" class="ui">
    <br/><div class="row" id="integral">Integral evaluates to: 0.00</div><br/>
    <div class="row">
        <label>$\theta_{min}$ <input id="thetaMin" type="range" min="0" max="3.1416" step="0.01" value="0"></label>
        <label><input id="thetaMax" type="range" min="0" max="3.1416" step="0.01" value="3.1416">&nbsp;$\theta_{max}$</label>
    </div>
    <div class="row">
        <label>$\phi_{min}$ <input id="phiMin" type="range" min="0" max="6.2832" step="0.01" value="0"></label>
        <label><input id="phiMax" type="range" min="0" max="6.2832" step="0.01" value="6.2832">&nbsp;$\phi_{max}$</label>
    </div>
    <br/><label>Opacity <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.35"></label><br/><br/>
    <label>Axes <input type="checkbox" id="axesCheck" checked></label>
    <label>Axis labels <input type="checkbox" id="axesLabelCheck"></label>
</div>

<script type="module">
    import * as THREE from "three";
    import { Axes, MatlabAxesLayout, StandardAxesAnnotations } from 'https://www.hendrikse.name/science/js/components-library.js';

    const scene = new THREE.Scene();
    const worldGroup = new THREE.Group();
    scene.add(worldGroup);
    // const axes = new MatlabAxes(worldGroup, canvasContainer, 2.1, 10);

    const canvasContainer = document.getElementById("container");
    const canvas = document.getElementById("myCanvas");

    const axes = new Axes(worldGroup);
    axes.setLayout(new MatlabAxesLayout(2.1, 10));
    const annotations = new StandardAxesAnnotations(canvasContainer, 2.1, 10, false);
    axes.setAnnotations(annotations);
    annotations.hide();

    const plot3D = new Plot3D(canvas, scene, axes);
    const bbox = new THREE.Box3();
    bbox.setFromObject( worldGroup );
    plot3D.fitToBoundingBox(bbox, {padding: 1.0, translationY: -1.0});

    const R = 1, da = 0.05;
    const f = (theta, phi) => theta * theta * (phi - Math.PI) * (phi - Math.PI);
    const cells = [];
    let values = [];

    function createCell(theta, phi) {
        const val = f(theta, phi);
        values.push(val);

        const mesh = new THREE.Mesh(
            new THREE.BoxGeometry(da, da, da),
            new THREE.MeshPhongMaterial({ transparent:true, opacity:0.35 })
        );
        const position = Axes.toCartesian(R, theta, phi);
        mesh.position.copy(new THREE.Vector3(position.x, position.z, position.y));
        mesh.userData = {theta:theta, phi:phi, val};
        scene.add(mesh);
        cells.push(mesh);
    }

    for (let theta = 0; theta <= Math.PI; theta += da)
        for (let phi = 0; phi <= 2 * Math.PI; phi += da)
            createCell(theta, phi);


    const minF = Math.min(...values), maxF = Math.max(...values);
    cells.forEach(cell => {
        const t = (cell.userData.val - minF) / (maxF - minF);
        cell.material.color.setRGB(1 - t, t, 0);
    });

    // UI
    const thetaMin = document.getElementById("thetaMin"),
        thetaMax = document.getElementById("thetaMax"),
        phiMin = document.getElementById("phiMin"),
        phiMax = document.getElementById("phiMax"),
        opacity = document.getElementById("opacity"),
        axesCheck = document.getElementById("axesCheck"),
        axesLabelCheck = document.getElementById("axesLabelCheck");

    function updateVisibility() {
        const t0 = parseFloat(thetaMin.value),
            t1 = parseFloat(thetaMax.value),
            p0 = parseFloat(phiMin.value),
            p1 = parseFloat(phiMax.value);

        cells.forEach(cell => {
            const t = cell.userData.theta, p = cell.userData.phi;
            cell.visible = (t >= t0 && t <= t1 && p >= p0 && p <= p1);
        });
    }

    function integrate() {
        let sum = 0;
        cells.forEach(cell => { if (cell.visible) sum += cell.userData.val * Math.sin(cell.userData.theta); });
        return sum * R * R * da * da;
    }

    const updateIntegral = () =>
        document.getElementById("integral").textContent = "Integral evaluates to: " + integrate().toFixed(2);

    // UI listeners
    [thetaMin,thetaMax,phiMin,phiMax].forEach(el =>
        el.addEventListener("input", () => { updateVisibility(); updateIntegral(); })
    );

    opacity.addEventListener("input", () => cells.forEach(cell => cell.material.opacity = parseFloat(opacity.value)));
    axesCheck.addEventListener("input", () => axesCheck.checked ? axes.show() : axes.hide());
    axesLabelCheck.addEventListener("input", () => axesLabelCheck.checked ? annotations.show() : annotations.hide());

    // Init
    updateVisibility();
    updateIntegral();

    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        plot3D.render();
    }
    animate();

</script>

