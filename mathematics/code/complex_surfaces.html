<style>
    .applicationCanvas {
        display: block;
        background-color: #131313;
        width: 100%;
        max-width: 800px;
        aspect-ratio: 1 / 1;
        margin: auto;
    }

    .canvasWrapper {
        position: relative;
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        aspect-ratio: 1 / 1;
    }

    .guiContainer {
        margin-top: 0.5em;
        background: #1a1a1a;
    }

</style>

<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<div class="canvasWrapper" id="complexPlotContainer">
    <canvas class="applicationCanvas" id="complexPlotCanvas"></canvas><br/>
</div>
<div id="gui-container"></div>

<script type="module">
    // import { Vector3 } from "three";
    import { Interval, Plot3DView, AxesParameters }
        from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";
    import { ComplexSurfaceDefinition, ComplexSurfaceSpecification, ComplexSurfaceView, ComplexSurface }
        from 'https://www.hendrikse.name/science/js/3d-surface-components.js';

    const canvasContainer = document.getElementById("complexPlotContainer");
    const canvas = document.getElementById("complexPlotCanvas");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x131313);
    const worldGroup = new THREE.Group();
    scene.add(worldGroup);

    export class ComplexNumber {
        constructor(re, im) {
            this._re = re
            this._im = im
        }

        get re() { return this._re; }
        get im() { return this._im; }

        phase = () => Math.atan2(this.im, this.re);
        abs = () => Math.sqrt(this.re * this.re + this.im * this.im);
    }

    export class MathWrapper {
        constructor() {
            this.complex = this._complex;
            this.add = this._add;
            this.subtract = this._subtract;
            this.multiply = this._multiply;
            this.divide = this._divide;
            this.sqrt = this._sqrt;
            this.log = this._log;
            this.exp = this._exp;
            this.sin = this._sin;
            this.cos = this._cos;
        }

        _complex = (re, im) => new ComplexNumber(re, im);
        _add = (z1, z2) => new ComplexNumber(z1.re + z2.re, z1.im + z2.im);
        _subtract = (z1, z2) => new ComplexNumber(z1.re - z2.re, z1.im - z2.im);
        _log = (z) => new ComplexNumber(Math.log(z.abs()), Math.atan2(z.im, z.re));
        _exp = (z) => new ComplexNumber(Math.exp(z.re) * Math.cos(z.im), Math.exp(z.re) * Math.sin(z.im))
        _sin = (z) => {
            const i_z = this.multiply(z, new ComplexNumber(0, 1));
            const min_i_z = this.multiply(z, new ComplexNumber(0, -1));
            return this.multiply(new ComplexNumber(0, -.5), this.exp(this.subtract(i_z, min_i_z)));
        }
        _cos = (z) => {
            const i_z = this.multiply(z, new ComplexNumber(0, 1));
            const min_i_z = this.multiply(z, new ComplexNumber(0, -1));
            return this.multiply(new ComplexNumber(.5, 0), this.exp(this.add(i_z, min_i_z)));
        }
        _multiply = (z1, z2) => new ComplexNumber(z1.re * z2.re - z1.im * z2.im, z1.im * z2.re + z1.re * z2.im);

        _divide = (z1, z2) => {
            const denominator = z2.re * z2.re + z2.im * z2.im;
            const re = z1.re * z2.re + z1.im * z2.im;
            const im = z1.im * z2.re - z1.re * z2.im;
            return new ComplexNumber(re / denominator, im / denominator);
        }
        _sqrt = (z) => {
            const factor = Math.sqrt((z.abs() + z.re) / 2);
            return new ComplexNumber(factor, factor * (z.im / Math.abs(z.im)));
        }
    }

    const math = new MathWrapper();
    const zSquaredPlusTwo = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.add(math.multiply(z, z), math.complex(2, 0)),
        new Interval(-2, 2),
        new Interval(-2, 2),
        "$\\psi(z) = \\big(z^2 + 2\\big)$",
        "z * z + 2"
    ));
    const zAbsSquared = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.multiply(z, new ComplexNumber(z.re, -z.im)),
        new Interval(-2, 2),
        new Interval(-2, 2),
        "$\\psi(z) = z\\bar{z}$",
        "z * z_bar"
    ));
    const zCubed = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.add(math.multiply(z, math.multiply(z, z)), new ComplexNumber(2, 0)),
        new Interval(-2, 2),
        new Interval(-2, 2),
        "$\\psi(z) = \\big(z^3 + 2\\big)$",
        "z * z * z + 2"
    ));
    const sqrtZ = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.sqrt(math.add(z, math.complex(0.0001, 0.0001))),
        new Interval(-1, 1),
        new Interval(-1, 1),
        "$\\psi(z) = \\sqrt(z)$",
        "sqrt(z)"
    ));
    const expZ = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.exp(math.multiply(z, z)),
        new Interval(-1, 1),
        new Interval(-1, 1),
        "$\\psi(z) = \\exp(z * z)$",
        "exp(z * z)"
    ));
    const logZ = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.log(math.add(z, math.complex(0.0001, 0.0001))),
        new Interval(-Math.PI, Math.PI),
        new Interval(-Math.PI, Math.PI),
        "$\\psi(z) = \\log(z)$",
        "log(z)"
    ));
    const sinZ = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.sin(z),
        new Interval(-Math.PI, Math.PI),
        new Interval(-Math.PI, Math.PI),
        "$\\psi(z) = \\sin(z)$",
        "sin(z)"
    ));
    const zPlusOneOverZMinusOne = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.divide(math.add(math.complex(1, 0), z), math.add(math.complex(-1, 0), z)),
        new Interval(-4, 4),
        new Interval(-4, 4),
        "$\\psi(z) = \\bigg(\\dfrac{z + 1}{z - 1} \\bigg)$",
        "(z + 1) / (z - 1)"
    ));
    const zPlusOneOverZ = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.add(z, math.divide(math.complex(1, 0), math.add(z, math.complex(0.01, 0)))),
        new Interval(-3, 3),
        new Interval(-3, 3),
        "$\\psi(z) = z + \\bigg(\\dfrac{1}{z}\\bigg)$",
        "z + 1 / z"
    ));
    const ComplexFunctions = Object.freeze({
        ZSquaredPlusTwo: zSquaredPlusTwo.specification.textString,
        ZAbsSquared: zAbsSquared.specification.textString,
        ZCubed: zCubed.specification.textString,
        SinZ: sinZ.specification.textString,
        logZ: logZ.specification.textString,
        expZ: expZ.specification.textString,
        sqrtZ: sqrtZ.specification.textString,
        ZPlusOneOverZMinusOne: zPlusOneOverZMinusOne.specification.textString,
        ZPlusOneOverZ: zPlusOneOverZ.specification.textString
    });
    class ControlsGui {
        constructor(plot, params) {
            const gui = new GUI({width: 300, autoPlace: false});
            gui.add(params, 'function', Object.values(ComplexFunctions))
                .name("F(z) = ")
                .onChange(value => {
                    surface.dispose();
                    switch (value) {
                        case zSquaredPlusTwo.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(zSquaredPlusTwo));
                            break;
                        case zAbsSquared.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(zAbsSquared));
                            break;
                        case zCubed.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(zCubed));
                            break;
                        case expZ.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(expZ));
                            break;
                        case logZ.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(logZ));
                            break;
                        case sqrtZ.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(sqrtZ));
                            break;
                        case sinZ.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(sinZ));
                            break;
                        case zPlusOneOverZMinusOne.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(zPlusOneOverZMinusOne));
                            break;
                        case zPlusOneOverZ.specification.textString:
                            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(zPlusOneOverZ));
                            break;
                    }
                    plot.updateAxes(surface.boundingBox());
                    plot.tiltY(params.tilt);
                });
            gui.add({ tilt: params.tilt }, "tilt", -45, 45, 1)
                .onChange(v => {
                    plot.tiltY(v - params.tilt);
                    params.tilt = v;
                });

            const axesFolder = gui.addFolder("Axes");
            axesFolder.add(params.axesParameters, 'axes')
                .name("Axes").onChange(value => plot.applyAxesParameters());
            axesFolder.add(params.axesParameters, 'gridPlanes')
                .name("Layout").onChange(value => plot.applyAxesParameters());
            axesFolder.add(params.axesParameters, 'annotations')
                .name("Annotations").onChange(value => plot.applyAxesParameters());
            axesFolder.close();

            document.getElementById("gui-container").appendChild(gui.domElement);
        }
    }

    const params = {
        axesParameters: new AxesParameters({axisLabels: ["Re(z)", "log|z|", "Im(z)"]}),
        function: ComplexFunctions.ZSquaredPlusTwo,
        tilt: 15
    };

    let surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(zCubed), {showWireframe: false});
    const plot3D = new Plot3DView(canvas, canvasContainer, scene, surface.boundingBox(), params.axesParameters);
    plot3D.tiltY(params.tilt);
    const gui = new ControlsGui(plot3D, params);

    function animate() {
        requestAnimationFrame(animate);
        plot3D.render();
    }
    animate();
</script>

<!--
   -
   - POLEN AUTOMATISCH DETECTEREN
   -

Suggestie is van **simpel ‚Üí degelijk ‚Üí echt wiskundig correct**,
met concrete implementatie-idee√´n die passen bij deze code.

---

# 1Ô∏è‚É£ Praktisch & robuust: detecteer ‚Äúnumerieke explosie‚Äù

Dit is in de praktijk de **meest gebruikte methode** in visualisaties.

### Idee

Een pool herken je aan:

* |f(z)| wordt *extreem groot*
* of `NaN / Infinity`

### Implementatie (past 1-op-1 in `sample()`)

```js
const value = this._specification.func(z);

if (!Number.isFinite(value.re) ||
    !Number.isFinite(value.im)) {
    return { isPole: true };
}

const r = value.abs();
if (!Number.isFinite(r) || r > POLE_THRESHOLD) {
    return { isPole: true };
}
```

Of minimalistischer:

```js
const r = value.abs();
const isPole = !Number.isFinite(r) || r > 1e6;
```

### Wat je ermee doet

* geen vertex maken
* of hoogte afkappen
* of kleur satureren
* of gat maken

### ‚úîÔ∏è Voordelen

‚úîÔ∏è Simpel
‚úîÔ∏è Werkt voor *alle* functies
‚úîÔ∏è Geen kennis van formule nodig

### ‚ùå Nadelen

‚ùå Heuristisch
‚ùå Afhankelijk van schaal

‚û°Ô∏è **Voor jouw use-case: absoluut geschikt.**

---

# 2Ô∏è‚É£ Geometrisch: detecteer ‚Äúte grote gradi√´nt‚Äù

Polen zijn plekken waar de functie **heel snel verandert**.

### Idee

Vergelijk waarde met naburige samples:

```text
|f(z + Œ¥) - f(z)| >> |Œ¥|
```

### Implementatie (discreet)

Bijvoorbeeld in je grid:

```js
const r = value.abs();
const rRight = rightValue.abs();
const rUp    = upValue.abs();

const gradient =
    Math.max(
        Math.abs(r - rRight),
        Math.abs(r - rUp)
    );

const isPole = gradient > GRAD_THRESHOLD;
```

### ‚úîÔ∏è Voordelen

‚úîÔ∏è Schaallonafhankelijker
‚úîÔ∏è Detecteert ook ‚Äúbijna-polen‚Äù
‚úîÔ∏è Werkt goed voor `log`, `1/z`, `tan(z)`

### ‚ùå Nadelen

‚ùå Iets duurder
‚ùå Vereist naburige samples

üëâ Ideaal als **secundaire check**.

---

# 3Ô∏è‚É£ Wiskundig correct: analytische pooldetectie

Als je de functie **kent**, kun je het exact doen.

### Voorbeelden

#### `1 / f(z)`

Pool waar `f(z) = 0`

```js
if (Math.abs(denominator.abs()) < EPS) pole = true;
```

#### `log(f(z))`

Pool waar `f(z) = 0`

#### `tan(z)`

Polen waar `cos(z) = 0`

### Structuur die dit ondersteunt

```js
class ComplexSurfaceSpecification {
    constructor(func, reInterval, imInterval, poleTest=null) {
        this.func = func;
        this.poleTest = poleTest;
    }

    isPole(z) {
        return this.poleTest?.(z) ?? false;
    }
}
```

Gebruik:

```js
const spec = new ComplexSurfaceSpecification(
    z => math.log(z),
    reInterval,
    imInterval,
    z => z.abs() < 1e-3
);
```

### ‚úîÔ∏è Voordelen

‚úîÔ∏è Exact
‚úîÔ∏è Geen heuristiek
‚úîÔ∏è Wiskundig zuiver

### ‚ùå Nadelen

‚ùå Niet generiek
‚ùå Meer werk per functie

---

# 4Ô∏è‚É£ Topologisch correct: winding number / monodromie (geavanceerd)

Dit is *next level*, maar wel prachtig.

### Idee

Neem een klein kringetje rond een punt en kijk of:

```text
arg(f(z)) maakt een volledige winding
```

Dat betekent: **er zit een pool of nul binnen**.

### Discrete aanpak

```js
let winding = 0;
for (let k = 0; k < N; k++) {
    winding += phase[k+1] - phase[k];
}
const isPole = Math.abs(winding) > Math.PI;
```

üìå Dit gebruik je zelden realtime, maar:

* geweldig voor analyse
* geweldig voor automatische detectie

---

# üß© Hoe ik dit in jouw code zou integreren

### Stap 1 ‚Äî Breid `sample()` uit

```js
sample(u, v, target) {
    const z = ...
    const value = this.specification.func(z);
    const r = value.abs();

    const isPole =
        !Number.isFinite(r) ||
        r > this.specification.poleThreshold;

    return { value, isPole };
}
```

### Stap 2 ‚Äî Geometrie beslist

```js
if (sample.isPole) {
    target.set(NaN, NaN, NaN);
} else {
    target.set(re, heightMapper(r), im);
}
```

### Stap 3 ‚Äî Optioneel visueel accent

* rood
* transparant
* gat
* spike

---

# üèÅ Mijn concrete aanbeveling voor jou

Voor **jouw huidige project**:

ü•á **Numerieke explosie + log-height**

```js
const r = value.abs();
const isPole = !Number.isFinite(r) || r > 1e4;
const y = Math.log1p(Math.min(r, 1e4));
```

ü•à Optioneel: gradi√´ntcheck

ü•â Optioneel: analytische `poleTest` per functie

---

Als je wilt, kan ik:

* een `PoleDetector` class maken
* poolgebieden als heatmap tonen
* automatisch gaten *smooth* laten aflopen
* of poles in de GUI zichtbaar maken

Maar inhoudelijk:
üëâ **zo detecteer je polen robuust √©n verantwoord.**

-->