
<canvas id="myCanvas" width="600" height="600" style="border: none;">

<div id="ui" class="ui">
    <div class="row">θ_min <input id="thetaMin" type="range" min="0" max="3.1416" step="0.01" value="0"></div>
    <div class="row">θ_max <input id="thetaMax" type="range" min="0" max="3.1416" step="0.01" value="3.1416"></div>
    <div class="row">φ_min <input id="phiMin" type="range" min="0" max="6.2832" step="0.01" value="0"></div>
    <div class="row">φ_max <input id="phiMax" type="range" min="0" max="6.2832" step="0.01" value="6.2832"></div>
    <div class="row">Opacity <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.35"></div>
    <div class="row">Mesh <input type="checkbox" id="meshChk" checked></div>
    <div class="row">Tick labels <input type="checkbox" id="tickChk" checked></div>
    <div class="row">Axis labels <input type="checkbox" id="axisLabelCheck" checked></div>
    <div class="row" id="integral">Integral = 0.00</div>
</div>

<script type="module">
    import * as THREE from "https://cdn.skypack.dev/three@0.136.0";
    import { OrbitControls } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls";
    import { CSS2DRenderer, CSS2DObject } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/renderers/CSS2DRenderer";

    // ------------------------
    // SCENE SETUP
    // ------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
    camera.position.set(5,5,5);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(innerWidth, innerHeight);
    labelRenderer.domElement.style.position = "absolute";
    labelRenderer.domElement.style.top = "0px";
    labelRenderer.domElement.style.pointerEvents = "none";
    document.body.appendChild(labelRenderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    const ui = document.getElementById("ui");
    ui.addEventListener("pointerenter", () => controls.enabled = false);
    ui.addEventListener("pointerleave", () => controls.enabled = true);

    const light = new THREE.DirectionalLight(0xffffff, 1.2);
    light.position.set(10, 10, 10);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));

    function createPlane(size, colour) {
        return new THREE.Mesh(
            new THREE.PlaneGeometry(size, size),
            new THREE.MeshPhongMaterial({color:colour, transparent:true, opacity:0.1, side:THREE.DoubleSide})
        );
    }

    function xyPlane(size, divisions) {
        const gridXY = new THREE.GridHelper(size, divisions, 0x666666, 0x333333);

        const planeXY = createPlane(size, 0x4444ff);
        planeXY.rotateX(Math.PI/2);

        planeXY.position.set(1, 0, 1);
        gridXY.position.set(1, 0, 1);
        return [planeXY, gridXY];
    }

    function yzPlane(size, divisions) {
        const gridYZ = new THREE.GridHelper(size, divisions, 0x666666, 0x333333);
        gridYZ.rotateZ(Math.PI/2);

        const planeYZ = createPlane(size, 0x44ff44);
        planeYZ.rotateY(Math.PI/2);

        planeYZ.position.set(0, 1, 1);
        gridYZ.position.set(0, 1, 1);
        return [planeYZ, gridYZ];
    }

    function xzPlane(size, divisions) {
        const gridXZ = new THREE.GridHelper(size, divisions, 0x666666, 0x333333);
        gridXZ.rotateX(Math.PI/2);

        const planeXZ = createPlane(size, 0xff4444);
        planeXZ.rotateZ(Math.PI/2);

        planeXZ.position.set(1, 1, 0);
        gridXZ.position.set(1, 1, 0);
        return [planeXZ, gridXZ];
    }

    function createGridPlanes(size, divisions) {
        const grids = xyPlane(size, divisions)
            .concat(yzPlane(size, divisions))
            .concat(xzPlane(size, divisions));
        grids.forEach(item => {scene.add(item);})
        return grids;
    }

    const gridSize = 2;
    const gridDivisions = 10;
    const allGrids = createGridPlanes(gridSize, gridDivisions);

    function makeTickLabel(text, position) {
        const div = document.createElement('div');
        div.style.color = "yellow";
        div.style.fontSize = "15px";
        div.textContent = text;
        const label = new CSS2DObject(div);
        label.position.copy(position);
        scene.add(label);
        return label;
    }

    function createTickLabels(size, divisions) {
        const step = 2 * size / divisions;
        const labels = [];
        for (let i = 0; i <= 2; i += step) {
            labels.push(makeTickLabel(i.toFixed(1), new THREE.Vector3(i, 0, size)));
            labels.push(makeTickLabel(i.toFixed(1), new THREE.Vector3(0, i, size)));
            labels.push(makeTickLabel(i.toFixed(1), new THREE.Vector3(size, 0, i)));
        }
        return labels;
    }
    const tickLabels = createTickLabels(gridSize, gridDivisions);

    function createAxisTextLabels(size) {
        const axisLabels = [];
        const offset = 0.3;
        axisLabels.push(makeTickLabel("X-axis", new THREE.Vector3(size + offset, 0, 1)));
        axisLabels.push(makeTickLabel("Y-axis", new THREE.Vector3(0,size + offset, 1)));
        axisLabels.push(makeTickLabel("Z-axis", new THREE.Vector3(0, 0, size + offset)));
        return axisLabels;
    }
    const axisLabels = createAxisTextLabels(gridSize);

    function toCartesian(radius, theta, phi) {
        const x = 1 + radius * Math.sin(theta) * Math.cos(phi);
        const y = 1 + radius * Math.sin(theta) * Math.sin(phi);
        const z = 1 + radius * Math.cos(theta);
        return new THREE.Vector3(x, y, z);
    }

    // ------------------------
    // SPHERE CELLS
    // ------------------------
    const R = 1, da = 0.05;
    function f(theta, phi) { return theta * theta * (phi - Math.PI) * (phi - Math.PI); }

    const cells = [];
    let functionValues = [];

    for (let theta = 0; theta <= Math.PI; theta += da)
        for (let phi = 0; phi <= 2 * Math.PI; phi += da) {
            const val = f(theta,phi);
            functionValues.push(val);

            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(da, da, da),
                new THREE.MeshPhongMaterial({transparent:true, opacity:0.35}));
            mesh.position.copy(toCartesian(R, theta, phi));
            mesh.userData = {theta, phi, val};
            scene.add(mesh);
            cells.push(mesh);
        }

    const fMin = Math.min(...functionValues),
        fMax = Math.max(...functionValues);
    cells.forEach(c=>{
        const t = (c.userData.val - fMin) / (fMax - fMin);
        c.material.color.setRGB(t, 0, 1 - t);
    });

    // ------------------------
    // INTERACTION
    // ------------------------
    const thetaMin = document.getElementById("thetaMin");
    const thetaMax = document.getElementById("thetaMax");
    const phiMin   = document.getElementById("phiMin");
    const phiMax   = document.getElementById("phiMax");
    const opacity  = document.getElementById("opacity");
    const meshCheck  = document.getElementById("meshChk");
    const tickCheck  = document.getElementById("tickChk");
    const axisLabelCheck = document.getElementById("axisLabelCheck");

    function isVisible(theta, phi, tmin, tmax, pmin, pmax) {
        return theta >= tmin && theta <= tmax && phi >= pmin && phi <= pmax;
    }

    function updateVisibility() {
        const tmin = parseFloat(thetaMin.value);
        const tmax = parseFloat(thetaMax.value);
        const pmin = parseFloat(phiMin.value);
        const pmax = parseFloat(phiMax.value);
        for (const c of cells) {
            const {theta,phi} = c.userData;
            c.visible = isVisible(theta, phi, tmin, tmax, pmin, pmax);
        }
    }

    function updateOpacity() {
        cells.forEach(c => c.material.opacity = parseFloat(opacity.value));
    }

    function updateMeshVisibility() {
        allGrids.forEach(mesh => mesh.visible = meshCheck.checked);
    }

    function updateAxisLabelVisibility() {
        axisLabels.forEach(label => label.visible = axisLabelCheck.checked);
    }

    function updateTickVisibility() {
        tickLabels.forEach(label => label.visible = tickCheck.checked);
    }

    function integrate() {
        let sum = 0;
        for (const c of cells)
            if(c.visible)
                sum += c.userData.val * Math.sin(c.userData.theta);
        return sum * R * R * da * da;
    }

    function updateIntegral() {
        document.getElementById("integral").textContent="Integral = "+integrate().toFixed(2);
    }

    [thetaMin,thetaMax,phiMin,phiMax].forEach(el=>el.addEventListener("input", ()=>{ updateVisibility(); updateIntegral(); }));
    opacity.addEventListener("input", updateOpacity);
    meshCheck.addEventListener("input", updateMeshVisibility);
    tickCheck.addEventListener("input", updateTickVisibility);
    axisLabelCheck.addEventListener("input", updateAxisLabelVisibility);

    updateVisibility();
    updateIntegral();

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);
    }
    animate();
</script>