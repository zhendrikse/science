<style>
    #canvas-wrapper {
        position: relative;
    }

    #gui-container {
        position: absolute;
        bottom: 10px;      /* distance from the bottom of the canvas */
        left: 10px;          /* center horizontally */
        z-index: 20;
    }
</style>

<div id="canvas-wrapper">
    <div id="gui-container"></div>
    <canvas id="myCanvas" width="600" height="800"></canvas>
</div>


<script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.0/lib/browser/math.js" type="text/javascript"></script>
<script type="module">
    import * as THREE from "https://cdn.skypack.dev/three@0.136.0";
    import { ParametricGeometry } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/geometries/ParametricGeometry";
    import { OrbitControls } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls";
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm";
    import { VertexNormalsHelper } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/helpers/VertexNormalsHelper.js";

    const canvas = document.getElementById("myCanvas"),
        width = canvas.width,
        height = canvas.height;

    class Scenery {
        constructor(scene, worldGroup) {
            this.camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100);
            this.renderer = this.#createRenderer();
            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.scene = scene;

            this.controls.enableDamping = true;
            this.camera.position.set(6, 5, 6);
            this.scene.background = new THREE.Color(0x131313);

            this.scene.add(worldGroup);
            this.scene.add(this.#createDirectionalLight());
            this.scene.add(this.#createHemisphereLight());
        }

        #createHemisphereLight =
            (skyColour=0x87ceeb, groundColour=0x444444) => new THREE.HemisphereLight(skyColour, groundColour, 0.8);

        #createDirectionalLight() {
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 10, 7.5); // kind of "sunlight"
            directionalLight.castShadow = true; // Enable shadows
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            return directionalLight;
        }

        #createRenderer() {
            const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
            renderer.setSize(width, height);
            return renderer;
        }

        setSize(width, height) {
            this.renderer.setSize(width, height);
            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();

            const pr = window.devicePixelRatio || 1;
            this.fxaaPass.material.uniforms["resolution"].value.x = 1 / (width * pr);
            this.fxaaPass.material.uniforms["resolution"].value.y = 1 / (height * pr);
        }

        render() {
            this.controls.update();
            this.renderer.render(this.scene, this.camera);
        }
    }

    const params = {
        amplitude: 1.0,
        frequency: 0.5,
        baseColor: "#ee4",
        wireframe: false,
        axes: true,
        normals: false,
        animate: false,
        resolution: 50,
        opacity: 0.9,
        customFunction: "5 * sin(x*x + y*y) * exp(-x*x - y*y)"
    }

    function createGui(surface) {
        const controls = new GUI({ width: 275, autoPlace: false });
        document.getElementById("gui-container").appendChild(controls.domElement);

        const mathFolder = controls.addFolder("Mathematical Surface");
        mathFolder.add(params, "customFunction").name("f(x,y) =")
            .onFinishChange(expr => {
                const f = surface.createMathJsSurface(expr);
                if (f) surface.setSurfaceFunction(f, params.frequency);
            });

        const shapeFolder = controls.addFolder("Shape Controls");
        shapeFolder.add(params, 'amplitude', 0.1, 1).step(0.01).name("Amplitude")
            .onChange(() => surface.updateNormalsLength(params.resolution));
        shapeFolder.add(params, 'frequency', 0, 2).step(0.01).name("Frequency");

        const appearanceFolder = controls.addFolder("Appearance");
        appearanceFolder.add(params, 'baseColor').name("Color").onChange(() => surface.updateColors());
        appearanceFolder.add(params, "resolution", 10, 200, 1).name("Resolution").onChange(resolution => {
            surface.rebuild(resolution)
            surface.updateNormalsLength(resolution);
        });

        appearanceFolder.add(params, "opacity", 0, 1, .01).name("Opacity").onChange(value => surface.setOpacity(value));
        appearanceFolder.add(params, 'animate').name("Animate");
        appearanceFolder.add(params, 'wireframe').name("Wireframe").onChange(value => surface.toggleWireframe(value));
        appearanceFolder.add(params, 'axes').name("Axes").onChange(value => axes.show(value));
        controls.add({reset:()=> scenery.camera.position.set(6, 5, 6)}, "reset").name("Reset Camera");
        appearanceFolder.add(params, 'normals').name('Show Normals').onChange(value => {
            surface.normalsVisible = value;
            if (surface.normalsHelper) surface.normalsHelper.visible = value;
        });

        mathFolder.open();
        shapeFolder.close();
        appearanceFolder.close();
    }

    class MatlabAxes {
        constructor(parentGroup, axesSize=4, gridDivisions=10) {
            this.axesSize = axesSize;

            // Create main axes using THREE built-in helper
            //this.axesHelper = new THREE.AxesHelper(axesSize);
            //parentGroup.add(this.axesHelper);

            // Create grids in XY, YZ, XZ planes
            this.gridXZ = new THREE.GridHelper(axesSize, gridDivisions, 0x444444, 0x444444);
            this.gridXZ.rotation.x = Math.PI / 2; // XZ plane
            this.gridXZ.position.y = .5 * this.axesSize;
            this.gridXZ.position.z = -.5 * this.axesSize;
            parentGroup.add(this.gridXZ);

            this.gridYZ = new THREE.GridHelper(axesSize, gridDivisions, 0x444444, 0x444444);
            this.gridYZ.rotation.z = Math.PI / 2; // YZ plane
            this.gridYZ.position.y = .5 * this.axesSize;
            this.gridYZ.position.x = -.5 * this.axesSize;
            parentGroup.add(this.gridYZ);

            this.gridXY = new THREE.GridHelper(axesSize, gridDivisions, 0x444444, 0x444444);
            this.gridXY.rotation.x = 0; // XY plane
            parentGroup.add(this.gridXY);

            // Group all helpers for easy visibility toggle
            this.group = new THREE.Group();
            this.group.add(this.gridXZ, this.gridYZ, this.gridXY);
            //this.group.add(this.axesHelper, this.gridXZ, this.gridYZ, this.gridXY);
            parentGroup.add(this.group);
        }

        show = (value) => this.group.visible = value;
    }

    class Surface {
        constructor(parentGroup, scenery, functionAsString="5 * sin(x*x + y*y) * exp(-x*x - y*y)", resolution=75, axesSize=4) {
            this.surfaceFunction = this.createMathJsSurface(functionAsString);
            this.axesSize = axesSize;
            this.parentGroup = parentGroup;
            this.time = 0;
            this.setToMaxHeight(params.frequency);
            this.normalsHelper = null;
            this.geometry = null;
            this.mesh = null;
            this.normalsVisible = false;
            this.#build(resolution);
        }

        createMathJsSurface(exprString) {
            let compiled;
            try {
                const surfaceFunction = exprString + " * amplitude";
                compiled = math.compile(surfaceFunction);
            } catch (err) {
                alert("Math.js parse error: " + err.message);
                return null;
            }

            // Swap y and z so that Three.js Y-axis is vertical
            return (u, v, amplitude, target) => {
                const [x, y] = this.#scale(u, v);
                let z;
                try {
                    z = compiled.evaluate({ x, y, amplitude });
                } catch (err) {
                    z = 0;
                }
                target.set(x, z, y); // z is vertical (Three.js Y), y is depth (Three.js Z)
            };
        }

        #scale = (u, v) => [this.axesSize * (u - 0.5), this.axesSize * (-v + 0.5)];

        #mesh(resolution, showWireframe) {
            this.geometry = new ParametricGeometry(
                (u, v, target) => this.surfaceFunction(u, v, this.#amplitudeModulation(0), target),
                resolution, resolution
            );

            const colors = new Float32Array(this.geometry.attributes.position.count * 3);
            this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const mesh = new THREE.Mesh(this.geometry, this.#material(showWireframe));
            mesh.castShadow = false;
            mesh.receiveShadow = false;
            return mesh; // mesh stays at (0,0,0)
        }


        #build(resolution, showWireframe = false) {
            this.mesh = this.#mesh(resolution, showWireframe);
            this.parentGroup.add(this.mesh);

            this.normalsHelper = new VertexNormalsHelper(
                this.mesh,
                0.2,
                0x770000
            );
            this.normalsHelper.visible = this.normalsVisible;
            this.mesh.add(this.normalsHelper);

            this.updateColors();
            this.#updateGeometry();
        }

        #updateGeometry() {
            const posAttr = this.geometry.attributes.position;
            const uvAttr  = this.geometry.attributes.uv;
            this._tempVec ??= new THREE.Vector3();
            const temp = this._tempVec;

            for (let i = 0; i < posAttr.count; i++) {
                const u = uvAttr.getX(i);
                const v = uvAttr.getY(i);

                this.surfaceFunction(u, v, this.#amplitudeModulation(this.time), temp);
                posAttr.setXYZ(i, temp.x, temp.y, temp.z);
            }

            posAttr.needsUpdate = true;
            this.geometry.computeVertexNormals();

            if (this.normalsHelper) this.normalsHelper.update();
        }

        #amplitudeModulation = (t) => (1.01 - Math.sin(t * params.frequency)) * params.amplitude;

        #material(showWireframe=false) {
            return new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.FrontSide,
                wireframe: showWireframe,
                transparent: true,
                opacity: params.opacity,
            });
        }

        setToMaxHeight = (frequency) => this.time = 3 * Math.PI / 2 / frequency;

        toggleWireframe = (value) => this.mesh.material.wireframe = value;

        setOpacity(opacity) {
            this.mesh.material.opacity = opacity;
            this.geometry.attributes.position.needsUpdate = true;
        }

        rebuild(resolution) {
            if (this.normalsHelper) {
                this.mesh.remove(this.normalsHelper);
                this.normalsHelper.geometry.dispose();
                this.normalsHelper.material.dispose();
                this.normalsHelper = null;
            }

            this.parentGroup.remove(this.mesh);
            this.geometry.dispose();

            this.#build(resolution, this.mesh.material.wireframe);
        }

        #yMinMax() {
            let yMin = Infinity, yMax = -Infinity;
            const posAttr = this.geometry.attributes.position;
            for(let i = 0; i < posAttr.count; i++) {
                const y = posAttr.getY(i);
                if (y < yMin) yMin = y;
                if (y > yMax) yMax = y;
            }
            return [yMin, yMax];
        }

        updateColors() {
            const posAttr = this.geometry.attributes.position;
            const colors = this.geometry.attributes.color.array;
            const range = this.#yMinMax();

            for (let i = 0; i < posAttr.count; i++) {
                const c = this.#updateColor(posAttr.getY(i), range);
                colors[3 * i]     = c.r;
                colors[3 * i + 1] = c.g;
                colors[3 * i + 2] = c.b;
            }

            this.geometry.attributes.color.needsUpdate = true;
        }

        #isValidColor(str) {
            const s = new Option().style;
            s.color = str;
            return s.color !== '';
        }

        #updateColor(yValue, range) {
            const t = range[1] !== range[0] ? (yValue - range[0]) / (range[1] - range[0]) : 0;
            const color = new THREE.Color();
            const hsl = {};
            hsl.h = t * .5 - .025;
            hsl.s = 0.9;
            hsl.l = 0.4 + 0.2 * (1 - t);

            if (params.baseColor && this.#isValidColor(params.baseColor)) {
                color.setStyle(params.baseColor);
                color.getHSL(hsl);
                hsl.l = 0.4 + 0.3 * (1 - t);
            }

            color.setHSL(hsl.h, hsl.s, hsl.l);
            return color;
        }

        update(deltaTime) {
            if (!params.animate) return;

            this.time += deltaTime;
            this.#updateGeometry();
            this.updateColors(); // needed when colors depend on height
        }

        updateNormalsLength(resolution) {
            if (!this.normalsHelper) return;

            const baseResolution = 50;     // resolution where base length looks good
            const baseAmplitude = 1.0;     // amplitude where base length looks good
            const baseLength = 0.2;        // default length at base resolution & amplitude

            // Scale inversely with resolution, proportionally with amplitude
            const length = baseLength * (baseResolution / resolution) * (params.amplitude / baseAmplitude);

            this.normalsHelper.size = length;
            this.normalsHelper.update(); // recalc positions
        }

        setSurfaceFunction(newFunc, frequency) {
            this.surfaceFunction = newFunc;
            this.setToMaxHeight(frequency);
            this.rebuild(params.resolution);
        }
    }

    /* Optional future-proof resize: make FXAA remain always sharp */
    window.addEventListener("resize", () => {
        const w = canvas.clientWidth || width;
        const h = canvas.clientHeight || height;
        scenery.setSize(w, h);
    });

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x131313);

    const worldGroup = new THREE.Group();
    scene.add(worldGroup);

    const scenery = new Scenery(scene, worldGroup);
    const axes = new MatlabAxes(worldGroup);
    axes.show(true);

    const surface = new Surface(worldGroup, scenery, params.customFunction);
    createGui(surface);

    let lastTime = performance.now();
    function animate() {
        requestAnimationFrame(animate);

        const now = performance.now();
        const deltaTime = params.animate ? (now - lastTime) * 0.001 : 0;
        lastTime = now;

        surface.update(deltaTime);
        scenery.render();
    }
    animate();

</script>
