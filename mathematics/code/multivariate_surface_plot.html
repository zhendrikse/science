<style>
    #gui-container {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 20;
    }
</style>

<div id="canvas-wrapper">
    <div id="gui-container"></div>
    <canvas id="myCanvas" width="600" height="800"></canvas>
</div>


<script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.0/lib/browser/math.js" type="text/javascript"></script>
<script type="module">
    import * as THREE from "https://cdn.skypack.dev/three@0.136.0";
    import { ParametricGeometry } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/geometries/ParametricGeometry";
    import { OrbitControls } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls";
    import { CSS2DRenderer, CSS2DObject } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/renderers/CSS2DRenderer";
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm";

    import { EffectComposer } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js";
    import { OutlinePass } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/OutlinePass.js";

    import { ShaderPass } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/ShaderPass.js";
    import { FXAAShader } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/shaders/FXAAShader.js";

    const canvas = document.getElementById("myCanvas"),
        width = canvas.width,
        height = canvas.height;

    class Scenery {
        constructor(scene, worldGroup) {
            this.camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100);
            this.renderer = this.#createRenderer();
            this.labelRenderer = this.#createLabelRenderer();
            this.fxaaPass = new ShaderPass(FXAAShader);
            this.outlinePass = new OutlinePass(new THREE.Vector2(width, height), scene, this.camera);
            this.composer = this.#createComposer(this.renderer, this.camera, scene);
            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.scene = scene;

            this.controls.enableDamping = true;
            this.camera.position.set(5, 5, 5);
            //this.scene.background = new THREE.Color(0xeeeeee);

            this.scene.add(worldGroup);
            this.scene.add(this.#createDirectionalLight());
            this.scene.add(this.#createHemisphereLight());
        }

        #createHemisphereLight =
            (skyColour=0x87ceeb, groundColour=0x444444) => new THREE.HemisphereLight(skyColour, groundColour, 0.8);

        #createDirectionalLight() {
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 10, 7.5); // kind of "sunlight"
            directionalLight.castShadow = true; // Enable shadows
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            return directionalLight;
        }

        #createComposer(renderer, camera, scene) {
            const composer = new EffectComposer(renderer);
            composer.setSize(width, height);
            composer.addPass(new RenderPass(scene, camera));

            // ⭐ Outline edges
            this.outlinePass.edgeStrength = 2.5;
            this.outlinePass.edgeThickness = 1.0;
            this.outlinePass.visibleEdgeColor.set("#000000");
            this.outlinePass.hiddenEdgeColor.set("#000000");
            composer.addPass(this.outlinePass);

            /* ⭐ FXAA ANTI-ALIASING */
            const pixelRatio = window.devicePixelRatio || 1;
            this.fxaaPass.material.uniforms["resolution"].value.x = 1 / (width * pixelRatio);
            this.fxaaPass.material.uniforms["resolution"].value.y = 1 / (height * pixelRatio);
            composer.addPass(this.fxaaPass);

            return composer;
        }

        #createLabelRenderer() {
            const labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(width, height);
            labelRenderer.domElement.style.position = "absolute";
            labelRenderer.domElement.style.top = "0px";
            labelRenderer.domElement.style.left = "0px";
            labelRenderer.domElement.style.pointerEvents = "none";
            labelRenderer.domElement.style.zIndex = 5;
            document.getElementById("canvas-wrapper").appendChild(labelRenderer.domElement);
            return labelRenderer;
        }

        #createRenderer() {
            const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
            renderer.setSize(width, height);
            return renderer;
        }

        setSize(width, height) {
            this.composer.setSize(width, height);
            this.renderer.setSize(width, height);
            this.labelRenderer.setSize(width, height);
            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();

            const pr = window.devicePixelRatio || 1;
            this.fxaaPass.material.uniforms["resolution"].value.x = 1 / (width * pr);
            this.fxaaPass.material.uniforms["resolution"].value.y = 1 / (height * pr);
        }

        render() {
            this.controls.update();
            this.composer.render();
            this.labelRenderer.render(this.scene, this.camera);
        }

        setControlsTarget(x, y, z) {
            this.controls.target.set(x, y, z);
        }
    }

    const params = {
        amplitude: 1.0,
        frequency: 0.5,
        baseColor: "#ee5",
        wireframe: false,
        axes: true,
        animate: false,
        resolution: 50,
        opacity: .85,
        customFunction: "(y*y - x*x) / 5"
    }

    const scaleCoordinates = (u, v) => [axes.axesSize * (u - 0.5), axes.axesSize * (v - 0.5)];

    // Converts user-input math.js code into a SurfaceFunction(u, v, t, target)
    function createMathJsSurface(exprString) {
        let compiled;

        try {
            const surfaceFunction = exprString + " * amplitude";
            console.log(surfaceFunction);
            compiled = math.compile(surfaceFunction);
        } catch (err) {
            alert("Math.js parse error: " + err.message);
            console.error(err);
            return null;
        }

        return (u, v, amplitude, target) => {
            const [x, y] = scaleCoordinates(u, v);

            let z;
            try {
                z = compiled.evaluate({ x, y, amplitude });
            } catch (err) {
                console.error(err);
                z = 0; // fail safe
            }

            target.set(x, z, y);
        };
    }

    function createLeftGuiColumn(surface) {
        const controls = new GUI({ width: 275, autoPlace: false });
        document.getElementById("gui-container").appendChild(controls.domElement);

        const mathFolder = controls.addFolder("Mathematical Surface");
        mathFolder.add(params, "customFunction").name("f(x,y) =")
            .onFinishChange(expr => {
                const f = createMathJsSurface(expr);
                if (f) surface.setSurfaceFunction(f, params.frequency);
            });

        const shapeFolder = controls.addFolder("Shape Controls");
        shapeFolder.add(params, 'amplitude', 0.1, 1).step(0.01).name("Amplitude");
        shapeFolder.add(params, 'frequency', 0, 2).step(0.01).name("Frequency");

        const appearanceFolder = controls.addFolder("Appearance");
        appearanceFolder.add(params, 'baseColor').name("Color");
        appearanceFolder.add(params, "resolution", 10, 200, 1).name("Resolution");
        appearanceFolder.add(params, "opacity", 0, 1, .01).name("Opacity").onChange(value => surface.setOpacity(value));
        appearanceFolder.add(params, 'animate').name("Animate");
        appearanceFolder.add(params, 'wireframe').name("Wireframe").onChange(value => surface.mesh.material.wireframe = value);
        appearanceFolder.add(params, 'axes').name("Axes").onChange(value => axes.show(value));
        controls.add({reset:()=> scenery.camera.position.set(5,5,5)}, "reset").name("Reset Camera");

        mathFolder.open();
        shapeFolder.close();
        appearanceFolder.close();
    }

    class MatlabAxes {
        constructor(parentGroup, axesSize=4, gridDivisions=10) {
            this.axesSize = axesSize;
            this.grids = [];
            this.#createPlanes(gridDivisions);
            this.tickLabels = this.#createTickLabels(gridDivisions);
            this.axisLabels = this.#createAxisLabels();
            this.arrows = this.#createArrows();

            [...this.grids, ...this.tickLabels, ...this.axisLabels, ...this.arrows].forEach(obj => parentGroup.add(obj));
        }

        getCenter() {
            return new THREE.Vector3(0.5 * this.axesSize, 0.5 * this.axesSize, 0.5 * this.axesSize);
        }

        #preventZFlickering(arrow) {
            arrow.renderOrder = 2;
            arrow.cone.material.depthTest = false;
            arrow.line.material.depthTest = false;
        }

        #createArrow = (axis, colour) => new THREE.ArrowHelper(axis, new THREE.Vector3(0, 0, 0), 1.2 * this.axesSize, colour, 0.2, 0.1);

        #createArrows() {
            const arrowX = this.#createArrow(new THREE.Vector3(1, 0 ,0), "red");
            const arrowY = this.#createArrow(new THREE.Vector3(0, 1 ,0), "green");
            const arrowZ = this.#createArrow(new THREE.Vector3(0, 0, 1), "blue");
            const arrows = [arrowX, arrowY, arrowZ];
            arrows.forEach(arrow => this.#preventZFlickering(arrow));
            return arrows;
        }

        #material = (colour) => new THREE.MeshPhongMaterial({color: colour, transparent: true, opacity: 0.2, side: THREE.DoubleSide});

        #grid = (divisions) => new THREE.GridHelper(this.axesSize, divisions, 0x333333, 0x333333);

        #plane = (colour) => new THREE.Mesh(new THREE.PlaneGeometry(this.axesSize, this.axesSize), this.#material(colour));

        #createPlanes(divisions) {
            const
                planeXZ = this.#plane(0x4444ff),
                planeYZ = this.#plane(0x44ff44),
                planeXY = this.#plane(0xff4444);

            planeXZ.rotateX(Math.PI * .5);
            planeYZ.rotateY(Math.PI * .5);
            planeXY.rotateZ(Math.PI * .5);

            planeXZ.position.set(this.axesSize * .5, 0, this.axesSize * .5);
            planeYZ.position.set(0, this.axesSize * .5, this.axesSize * .5);
            planeXY.position.set(this.axesSize * .5, this.axesSize * .5, 0);

            this.grids.push(planeXZ, planeYZ, planeXY);
            this.#createGrids(planeXZ, planeYZ, planeXY, divisions);
        }

        #createGrids(planeXZ, planeYZ, planeXY, divisions) {
            const
                gridXZ = this.#grid(divisions),
                gridYZ = this.#grid(divisions),
                gridXY = this.#grid(divisions);

            gridXZ.position.copy(planeXZ.position);
            gridYZ.position.copy(planeYZ.position);
            gridXY.position.copy(planeXY.position);

            gridXZ.rotateY(Math.PI * .5);
            gridYZ.rotateZ(Math.PI * .5);
            gridXY.rotateX(Math.PI * .5);

            this.grids.push(gridXZ);
            this.grids.push(gridYZ);
            this.grids.push(gridXY);
        }

        #makeLabel(text, pos, colour="ffffff") {
            const div = document.createElement("div");
            div.style.color = colour;
            div.style.fontSize = "15px";
            div.textContent = text;
            const label = new CSS2DObject(div);
            label.position.copy(pos);
            return label;
        }

        #createTickLabels(divisions) {
            const labels = [];
            const step = (2 * this.axesSize) / divisions;
            const offset = 0.1;

            for (let v = 0; v <= this.axesSize; v += step) {
                labels.push(this.#makeLabel(v.toFixed(1), new THREE.Vector3(v, 0, this.axesSize + offset), "yellow"));
                labels.push(this.#makeLabel(v.toFixed(1), new THREE.Vector3(0, v, this.axesSize + offset), "yellow"));
                labels.push(this.#makeLabel(v.toFixed(1), new THREE.Vector3(this.axesSize + offset, 0, v), "yellow"));
            }
            return labels;
        }

        #createAxisLabels() {
            const offset = 0.15 * this.axesSize;
            return [
                this.#makeLabel("X", new THREE.Vector3(this.axesSize + offset, 0, .1 * this.axesSize), "red"),
                this.#makeLabel("Z", new THREE.Vector3(0, this.axesSize + offset * .5, 0), "green"),
                this.#makeLabel("Y", new THREE.Vector3(.1 * this.axesSize, 0 ,this.axesSize + offset), "blue")
            ];
        }

        show(value) {
            [...this.grids, ...this.tickLabels, ...this.axisLabels, ...this.arrows].forEach(obj => obj.visible = value);
        }
    }

    class Surface {
        constructor(parentGroup, surfaceFunction, scenery, resolution=75) {
            this.surfaceFunction = surfaceFunction;
            this.parentGroup = parentGroup;
            this.time = 0;
            this.needsColorUpdate = true;

            this.geometry = null;
            this.mesh = null;
            this.#build(resolution);
            scenery.outlinePass.selectedObjects = [this.mesh];
        }

        setToMaxHeight(frequency) {
            this.time = 3 * Math.PI / 2 / frequency;
        }

        #amplitudeModulation = (t) => (1 - Math.sin(t * params.frequency)) * params.amplitude;

        #material(showWireframe=false) {
            return new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: 0.1,  // lager = glanzender
                metalness: 0.25,  // hoger = meer reflectie
                side: THREE.DoubleSide,
                wireframe: showWireframe,
                transparent: true,
                opacity: 0.85
            });
        }

        setOpacity(opacity) {
            this.mesh.material.opacity = opacity;
            this.geometry.attributes.position.needsUpdate = true;
        }

        rebuild(resolution) {
            this.parentGroup.remove(this.mesh);
            this.geometry.dispose();

            this.#build(resolution, this.mesh.material.wireframe);
        }

        #build(resolution, showWireframe=false) {
            this.geometry = new ParametricGeometry(
                (u, v, target) => this.surfaceFunction(u, v, this.#amplitudeModulation(0), target),
                resolution, resolution
            );

            this.mesh = new THREE.Mesh(this.geometry, this.#material(showWireframe));
            this.mesh.position.copy(this.#calculateOffset());
            this.parentGroup.add(this.mesh);

            const colors = new Float32Array(this.geometry.attributes.position.count * 3);
            this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            this.needsColorUpdate = true;
            this.#updateColors(true);
        }

        #calculateOffset() {
            this.geometry.computeBoundingBox();
            return new THREE.Vector3(
                axes.getCenter().x - 0.5 * (this.geometry.boundingBox.max.x + this.geometry.boundingBox.min.x),
                axes.getCenter().y - 0.5 * (this.geometry.boundingBox.max.y + this.geometry.boundingBox.min.y),
                axes.getCenter().z - 0.5 * (this.geometry.boundingBox.max.z + this.geometry.boundingBox.min.z)
            );
        }

        #yMinMax() {
            let yMin = Infinity, yMax = -Infinity;
            const posAttr = this.geometry.attributes.position;
            for(let i = 0; i < posAttr.count; i++) {
                const y = posAttr.getY(i);
                if (y < yMin) yMin = y;
                if (y > yMax) yMax = y;
            }
            return [yMin, yMax];
        }

        #updateColors(force=false) {
            if (!this.needsColorUpdate && !force) return;

            const posAttr = this.geometry.attributes.position;
            const colors = this.geometry.attributes.color.array;
            const range = this.#yMinMax();

            for (let i = 0; i < posAttr.count; i++) {
                const c = this.#updateColor(posAttr.getY(i), range);
                colors[3 * i]     = c.r;
                colors[3 * i + 1] = c.g;
                colors[3 * i + 2] = c.b;
            }

            this.geometry.attributes.color.needsUpdate = true;
            this.needsColorUpdate = false;
        }

        #isValidColor(str) {
            const s = new Option().style;
            s.color = str;
            return s.color !== '';
        }

        #updateColor(yValue, range) {
            const t = range[1] !== range[0] ? (yValue - range[0]) / (range[1] - range[0]) : 0;
            const color = new THREE.Color();
            const hsl = {};
            hsl.h = t * .5 - .025;
            hsl.s = 0.9;
            hsl.l = 0.4 + 0.2 * (1 - t);

            if (params.baseColor && this.#isValidColor(params.baseColor)) {
                color.setStyle(params.baseColor);
                color.getHSL(hsl);
                hsl.l = 0.4 + 0.3 * (1 - t);
            }

            color.setHSL(hsl.h, hsl.s, hsl.l);
            return color;
        }

        update(deltaTime) {
            this.time += deltaTime;
            this.#updateGeometry();
            this.#updateColors();
        }

        markColorUpdate = () => (this.needsColorUpdate = true);

        #updateGeometry() {
            const posAttr = this.geometry.attributes.position;
            const temp = new THREE.Vector3();

            for (let i = 0; i < posAttr.count; i++) {
                const u = posAttr.getX(i) / axes.axesSize + 0.5;
                const v = posAttr.getZ(i) / axes.axesSize + 0.5;
                this.surfaceFunction(u, v, this.#amplitudeModulation(this.time), temp);
                posAttr.setXYZ(i, temp.x, temp.y, temp.z);
            }

            // Computationally intensive, but supposedly improves quality
            //this.geometry.computeVertexNormals();
            //this.geometry.normalizeNormals();
            posAttr.needsUpdate = true;
        }

        #center = () => this.mesh.position.copy(this.#calculateOffset());

        setSurfaceFunction(newFunc, frequency) {
            this.surfaceFunction = newFunc;
            this.setToMaxHeight(frequency);
            this.rebuild(params.resolution);
        }
    }

    function boundingBoxOfWorldGroup(worldGroup) {
        const box = new THREE.Box3().setFromObject(worldGroup);
        const center = new THREE.Vector3();
        box.getCenter(center);
        return center;
    }

    /* ⭐ Optional future-proof resize: make FXAA remain always sharp */
    window.addEventListener("resize", () => {
        const w = canvas.clientWidth || width;
        const h = canvas.clientHeight || height;
        scenery.setSize(w, h);
    });

    const
        scene = new THREE.Scene(),
        worldGroup = new THREE.Group(),
        scenery = new Scenery(scene, worldGroup),
        axes = new MatlabAxes(worldGroup),
        surface = new Surface(worldGroup, createMathJsSurface(params.customFunction), scenery);

    const center = boundingBoxOfWorldGroup(worldGroup);
    worldGroup.position.sub(center);

    // Shift DOWN to avoid overlapping GUI
    worldGroup.position.y -= 0.25 * axes.axesSize;

    scenery.setControlsTarget(0, 0, 0);
    surface.update(0);
    surface.setToMaxHeight(params.frequency);

    createLeftGuiColumn(surface);

    let lastTime = performance.now();
    function animate() {
        requestAnimationFrame(animate);

        const now = performance.now();
        const deltaTime = params.animate ? (now - lastTime) * 0.001 : 0; // In seconds
        lastTime = now;

        surface.update(deltaTime);
        scenery.render();
    }

    animate();
</script>
