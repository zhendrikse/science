<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<canvas class="applicationCanvas" id="simulationCanvas" width="800" height="800"></canvas><br/>

<script type="module">
    import { Scene, Vector3, PerspectiveCamera, WebGLRenderer, DirectionalLight, AmbientLight }  from "three";
    import { Ball, Spring, Cylinder } from "https://www.hendrikse.name/science/js/three-js-extensions.js";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    console.clear( );
    const scene = new Scene();

    const canvas = document.getElementById('simulationCanvas');
    canvas.focus();
    const canvasWidth = canvas.clientWidth;
    const canvasHeight = canvas.clientHeight;

    const camera = new PerspectiveCamera(60, canvasWidth/canvasHeight, 0.1, 1000);
    camera.position.set(2, 0, 3);
    camera.updateProjectionMatrix();

    const renderer = new WebGLRenderer( {antialias: true, canvas: canvas, alpha: true} );
    renderer.setSize( canvasWidth, canvasHeight );
    renderer.setAnimationLoop( animationLoop );

    const controls = new OrbitControls( camera, canvas );
    controls.enableDamping = true;

    const light = new DirectionalLight(0xffffff, 1);
    light.position.set(0, 4, 0);
    scene.add(light);
    scene.add(new AmbientLight(0xffffff, .5));

    class Atom {
        constructor(parent, position, {
            radius = 0.175,
            color = 0xffcc11,
            visible = false,
            mass = 1
        } = {}) {

            this._ball = new Ball(parent, {
                position: position.clone(),
                radius: radius,
                mass: mass,
                color: color,
                opacity: visible ? 1 : 0,
            });

            this._visible = visible;
            this._force = new Vector3();
            this._neighbors = [];
        }

        appendNeighbor(atom) { this._neighbors.push(atom); }

        updateForce() {
            this._force.set(0, 0, 0);
            const k = 1000;
            const leq = 1;

            for (const atom of this._neighbors) {
                const delta = atom.position.clone().sub(this.position);
                const stretch = delta.length() - leq;
                this._force.add(delta.normalize().multiplyScalar(k * stretch));
            }
        }

        update(dt) {
            if (!this._visible) return;
            this._ball.semiImplicitEulerUpdate(this._force, dt);
        }

        shiftBy(displacement) { this._ball.moveTo(this.position.clone().add(displacement)); }
        get visible() { return this._visible; }
        get position() { return this._ball.position; }
    }

    class Bond {
        constructor(parent, atomA, atomB) {
            this._atomA = atomA;
            this._atomB = atomB;

            // this.spring = new Cylinder(
            //     parent,
            //     atomA.position.clone(),
            //     atomB.position.clone().sub(atomA.position),
            //     0.05
            // );

            this._spring = new Spring(
                parent,
                atomA.position.clone(),
                atomB.position.clone().sub(atomA.position),
                {
                    k: 1000,
                    color: "lightblue",
                    radius: 0.05,
                    coils: 25,
                    coilRadius: 0.1 * 0.05 // TODO atomA.ball._sphere.radius * 0.5
                }
            );
        }

        update(time) {
            const axis = this._atomB.position.clone().sub(this._atomA.position);

            this._spring.moveTo(this._atomA.position);
            this._spring.updateAxis(axis);
            this._spring.update(time);
        }
    }

    class Lattice {
        constructor(parent, nrows = 2) {
            this._atoms = [];
            this._bonds = [];

            nrows += 2;
            const half = Math.floor(nrows / 2);

            this.#createLattice(parent, half);
            this.#determineNeighbors(parent);
        }

        #createLattice(parent, half) {
            for (let z = -half; z < half; z++)
                for (let y = -half; y < half; y++)
                    for (let x = -half; x < half; x++) {
                        const visible =
                            Math.abs(x) !== half &&
                            Math.abs(y) !== half &&
                            Math.abs(z) !== half;

                        const atom = new Atom(parent, new Vector3(x, y, z), { visible });
                        this._atoms.push(atom);
                    }
        }

        #determineNeighbors(parent) {
            for (const atom of this._atoms)
                for (const other of this._atoms) {
                    const delta = atom.position.clone().sub(other.position);
                    if (
                        delta.equals(new Vector3(1,0,0)) ||
                        delta.equals(new Vector3(-1,0,0)) ||
                        delta.equals(new Vector3(0,1,0)) ||
                        delta.equals(new Vector3(0,-1,0)) ||
                        delta.equals(new Vector3(0,0,1)) ||
                        delta.equals(new Vector3(0,0,-1))
                    ) {
                        atom.appendNeighbor(other);
                        if (atom.visible && other.visible)
                            this._bonds.push(new Bond(parent, atom, other));
                    }
                }
        }

        update(dt, time) {
            for (const atom of this._atoms)
                atom.updateForce();

            for (const atom of this._atoms)
                atom.update(dt);

            for (const bond of this._bonds)
                bond.update(time);
        }

        moveAtom(index, displacement) {
            this._atoms[index].shiftBy(displacement);
        }
    }

    const lattice = new Lattice(scene);
    const dt = 0.01;

    lattice.moveAtom(26, new Vector3(0, 0, 0.2));

    function animationLoop(time) {
        lattice.update(dt, time * 0.001);
        renderer.render(scene, camera);
    }

</script>