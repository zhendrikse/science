
<canvas id="theCanvas" width="720" height="360">Please update your browser!</canvas>

<div style="text-align:center;">
    <input type="button" id="pauseButton" value="Pause" style="width:100px; font-size:16px;"/>&nbsp;
    <label for="latSlider">Latitude = <output id="latReadout" for="latSlider">41&deg;</output>
        <input id="latSlider" type="range" min="-90" max="90" step="1" value="41"/>
    </label>
    <label for="bearingSlider">Bearing = <output id="bearingReadout" for="bearingSlider">180&deg;</output>
        <input id="bearingSlider" type="range" min="0" max="360" step="1" value="180"/>
    </label>
</div>

<script>
    const constellationStars = [
        {"id":27989,"ra":88.79,"dec":7.41,"mag":0.42},
        {"id":25336,"ra":81.28,"dec":6.35,"mag":1.64},
        {"id":26311,"ra":84.05,"dec":-1.20,"mag":1.70},
        {"id":26727,"ra":83.00,"dec":-0.30,"mag":2.25},
        {"id":25930,"ra":85.19,"dec":-1.94,"mag":1.74},
        {"id":28614,"ra":86.94,"dec":-9.67,"mag":2.07},
        {"id":24436,"ra":78.63,"dec":-8.20,"mag":0.13}
        ];

    const constellations = {
        "Orion": [
            [27989, 25336],
            [25336, 26311],
            [26311, 26727],
            [26727, 25930],
            [25930, 28614],
            [28614, 24436],
            [24436, 27989]
        ]};

    let starById = {};
    let projectedStars = {};
    let stars2Draw = [];

    async function loadData() {
        // Load stars
        const starsRes = await fetch('https://raw.githubusercontent.com/ofrohn/d3-celestial/master/data/stars.6.json');
        const starsData = await starsRes.json();

        // GeoJSON -> own format
        const stars = starsData.features.map(feature => ({
            id: feature.id,
            ra: feature.geometry.coordinates[0] * 180 / Math.PI,   // rad -> graden
            dec: feature.geometry.coordinates[1] * 180 / Math.PI,
            mag: feature.properties.mag
        }));

        stars2Draw = stars.filter(star => star.mag <= 4);
        requestAnimationFrame(nextFrame);
    }

    const theCanvas = document.getElementById("theCanvas");
    const theContext = theCanvas.getContext("2d");
    const pauseButton = document.getElementById("pauseButton");
    const latSlider = document.getElementById("latSlider");
    const latReadout = document.getElementById("latReadout");
    const bearingSlider = document.getElementById("bearingSlider");
    const bearingReadout = document.getElementById("bearingReadout");

    pauseButton.addEventListener("click", () => {
        running = !running;
        pauseButton.value = running ? "Pause ": "Resume";
        if (running)
            requestAnimationFrame(nextFrame);
    });

    latSlider.addEventListener("input", () => {
        latReadout.innerHTML = latSlider.value.replace("-","&minus;") + "&deg;";
        drawSky();
    });
    bearingSlider.addEventListener("input", () => {
        bearingReadout.innerHTML = bearingSlider.value + "&deg;";
        drawSky();
    });

    const radiusSkyDomeInPixels = Number(theCanvas.height);      // radius of sky dome image in screen pixels
    let localSidTime = 0;   // local sidereal time in hours
    let running = true;

    function nextFrame() {
        if (!running) return;

        localSidTime += 1/60;
        drawSky();

        requestAnimationFrame(nextFrame);
    }

    function projectStar(raDeg, decDeg) {
        // Latitude
        let latitude = Number(latSlider.value);
        if (latitude > 89.9) latitude = 89.9;
        if (latitude < -89.9) latitude = -89.9;

        const cosLat = Math.cos(latitude * Math.PI / 180);
        const sinLat = Math.sin(latitude * Math.PI / 180);

        const bearing = Number(bearingSlider.value) * Math.PI / 180;
        const sidTime = localSidTime * 15 * Math.PI / 180;

        // naar radialen
        const ra  = raDeg  * Math.PI / 180;
        const dec = decDeg * Math.PI / 180;

        const sinDec = Math.sin(dec);
        const cosDec = Math.cos(dec);

        // Hour angle
        const ha = sidTime - ra;

        // Altitude
        const sinAltitude = sinDec*sinLat + cosDec*cosLat*Math.cos(ha);
        if (sinAltitude <= 0) return null;   // onder horizon

        const alt = Math.asin(sinAltitude);
        const cosAlt = Math.cos(alt);

        // Azimuth
        const sinAzimuth = -Math.sin(ha) * cosDec / cosAlt;
        const cosAzimuth = (sinDec - sinLat * sinAltitude) / (cosLat*cosAlt);
        const az = Math.atan2(sinAzimuth, cosAzimuth);

        // Relatieve azimut
        let azRel = az - bearing;
        if (azRel < -Math.PI) azRel += 2 * Math.PI;

        // buiten beeld?
        if (azRel < -Math.PI / 2 || azRel > Math.PI / 2) return null;

        // Azimuthal equidistant projectie
        const alpha = Math.acos(cosAlt * Math.cos(azRel));
        const sinAlpha = Math.sin(alpha);

        if (sinAlpha === 0) return null;  // singulariteit

        const scaleFactor = radiusSkyDomeInPixels / (Math.PI / 2);

        const x = alpha * scaleFactor * cosAlt * Math.sin(azRel) / sinAlpha;
        const y = -alpha * scaleFactor * sinAltitude / sinAlpha;

        return {x, y};
    }

    // Draw the sky image:
    function drawSky() {
        // theContext.clearRect(0, 0, theCanvas.width, theCanvas.height);
        // Draw the background:
        theContext.fillStyle = "black";
        theContext.beginPath();
        theContext.arc(radiusSkyDomeInPixels, radiusSkyDomeInPixels, radiusSkyDomeInPixels, Math.PI, 2*Math.PI);
        theContext.fill();

        projectedStars = {};
        for (let star of stars2Draw) {
            let projectedStar = projectStar(star.ra, star.dec);
            if (!projectedStar) continue;

            projectedStars[star.id] = projectedStar;
            drawStar(projectedStar.x, projectedStar.y, star.mag);
        }
        drawConstellations();
    }

    function drawConstellations() {
        theContext.strokeStyle = "rgba(0, 150, 255, 0.25)";
        theContext.lineWidth = 1.5;
        projectedStars = {};

        for (let star of constellationStars) {
            let projectedStar = projectStar(star.ra, star.dec);
            if (!projectedStar) continue;

            projectedStars[star.id] = projectedStar;
            drawStar(projectedStar.x, projectedStar.y, star.mag);
        }

        for (let name in constellations) {
            let lines = constellations[name];

            for (let pair of lines) {
                let a = projectedStars[pair[0]];
                let b = projectedStars[pair[1]];
                if (!a || !b) continue;

                theContext.beginPath();
                theContext.moveTo(radiusSkyDomeInPixels + a.x, radiusSkyDomeInPixels + a.y);
                theContext.lineTo(radiusSkyDomeInPixels + b.x, radiusSkyDomeInPixels + b.y);
                theContext.stroke();
            }
        }
    }

    // Draw a star at given pixel coordinates, relative to straight ahead:
    function drawStar(x, y, mag) {
        const brightness = Number((5 - mag) / 6.5).toFixed(2);    // linear map, mag -> brightness
        theContext.fillStyle = "rgba(255,255,255," + brightness + ")";
        theContext.beginPath();
        theContext.arc(radiusSkyDomeInPixels + x, radiusSkyDomeInPixels + y, 1.5, 0, 2 * Math.PI);
        theContext.fill();
    }

    loadData();
</script>
