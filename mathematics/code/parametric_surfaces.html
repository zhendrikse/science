<style>
    #canvas-wrapper {
        position: relative;
        width: 600px;
        height: 800px;
    }

    #myCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
    }

    #gui-container {
        position: absolute;
        bottom: 10px;      /* distance from the bottom of the canvas */
        left: 10px;          /* center horizontally */
        z-index: 20;
    }

    #surface-name {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        font-size: 24px;
        font-family: sans-serif;
        color: yellow;
        z-index: 10;  /* above canvas */
        pointer-events: none;
        font-weight: bold;
        text-shadow: 0 0 8px black;
    }

    #surface-equation {
        font-size: 18px;
        color: yellow;
        margin: 20px 20px 40px 20px;   /* top, sides, bottom */
        text-align: left;               /* align formula to left */
        width: 600px;
        height: 200px;
    }

    #surface-equation .mjx-chtml {
        display: block;                 /* make MathJax fill the div */
        max-width: 100%;
    }
</style>

<div id="canvas-wrapper">
    <div id="gui-container"></div>
    <div id="surface-name"></div>
    <canvas id="myCanvas" width="600" height="800"></canvas>
</div>
<div id="surface-equation"></div>

<script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.0/lib/browser/math.js" type="text/javascript"></script>
<script type="module">
    import * as THREE from "https://cdn.skypack.dev/three@0.136.0";
    import { ParametricGeometry } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/geometries/ParametricGeometry";
    import { OrbitControls } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls";
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm";
    import { VertexNormalsHelper } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/helpers/VertexNormalsHelper.js";

    const canvas = document.getElementById("myCanvas"),
        width = canvas.width,
        height = canvas.height;

    const Category = Object.freeze({
        TOROID: "Toroid",
        BASIC: "Basic",
        SPIRAL: "Spiral",
        MISC: "Miscellaneous"
    });

    const surfaceDefinitions = [ {
        name: "Arc",
        category: Category.MISC,
        func: (u, v, amplitude, target) => {
            const
                b = 3,
                [theta, phi] = [Math.PI * u, Math.PI * (1 - v)],
                x = Math.cos(theta),
                y = b * Math.sin(phi),
                z = Math.sin(theta) + Math.cos(phi);

            target.set(x, y * amplitude, z);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} \\cos(\\theta) \\\\ \\cos(\\phi)+\\sin(\\theta) \\\\ b\\sin(\\phi)\\end{pmatrix}\\text{, } \\begin{cases} \\theta \\in [0, \\pi] \\\\ \\phi \\in [0, \\pi] \\end{cases}"
    }, {
        name: "Bow curve",
        category: Category.TOROID,
        func: (u, v, amplitude, target) => {
            const
                a = 2, b = 1,
                [theta, phi] = [2 * Math.PI * u, 4 * Math.PI * v],
                x = (a + b * Math.sin(theta)) * Math.sin(phi),
                y = (a + b * Math.sin(theta)) * Math.cos(phi),
                z = b * Math.cos(theta) + a * Math.cos(.5 * phi);

            target.set(x, z * amplitude, y);
        },
        equation: "\\begin{pmatrix}x \\\\ y \\\\ z\\end{pmatrix}=\\begin{pmatrix} (2 + T \\sin(\\theta)) \\sin(\\phi) \\\\  (2 + T \\sin(\\theta)) \\cos(\\phi) \\\\ T \\cos(\\theta) + 3 \\cos(\\phi/2) \\end{pmatrix}\\text{, } \\begin{cases} \\theta \\in [0, 2\\pi] \\\\ \\phi \\in [0, 4\\pi] \\end{cases}"
    }, {
        name: "Catenoid",
        category: Category.BASIC,
        func: (u, v, amplitude, target) => {
            const
                c = 1.25,
                [theta, phi] = [2 * Math.PI * (u - 0.5), 4 * (0.5 - v)],
                x = Math.cosh(phi / c) * Math.cos(theta),
                y = Math.cosh(phi / c) * Math.sin(theta);
            target.set(x, c * phi * amplitude, y);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} c\\cdot\\cosh(\\phi/c)\\cos(\\theta) \\\\ c\\cdot\\cosh(\\phi/c)\\sin(\\theta) \\\\ \\phi\\end{pmatrix}\\text{, } \\begin{cases} \\theta \\in [-\\pi, \\pi] \\\\ \\phi \\in [-2\\pi, 2\\pi] \\end{cases}"
    }, {
        name: "Conchoidal 1",
        category: Category.SPIRAL,
        func: (u, v, amplitude, target) => {
            const
                k = 1.2, l = 1.2, a = 1.5,
                [theta, phi] = [6 * Math.PI * u, 2 * Math.PI * (1 - v)],
                x = k ** theta * (1 + Math.cos(phi)) * Math.cos(theta),
                y = k ** theta * Math.sin(phi) - a * l ** theta,
                z = k ** theta * (1 + Math.cos(phi)) * Math.sin(theta);

            target.set(x, y * amplitude, z);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} k^\\theta(1 + \\cos(\\phi))\\cos(\\theta) \\\\ k^\\theta(1 + \\cos(\\phi))\\cos(\\sin) \\\\ k^\\theta\\sin(\\phi) -a\\cdot l^\\theta\\end{pmatrix}\\text{, } \\begin{cases} \\theta \\in [0, 6\\pi] \\\\ \\phi \\in [0, 2\\pi] \\end{cases}"
    }, {
        name: "Conchoidal 2",
        category: Category.SPIRAL,
        func: (u, v, amplitude, target) => {
            const
                num_spirals = 3, r_final = 2, height = 6.5, r_inner = .5,
                [s, t] = [2 * Math.PI * u, 2 * Math.PI * v],
                x = r_final * (1 - t / (2 * Math.PI)) * Math.cos(num_spirals * t) * (1 + Math.cos(s)) + r_inner * Math.cos(num_spirals * t),
                y = (height * t / (2 * Math.PI)) + r_final * (1 - t / (2 * Math.PI)) * Math.sin(s),
                z = r_final * (1 - t / (2 * Math.PI)) * Math.sin(num_spirals * t) * (1 + Math.cos(s)) + r_inner * Math.sin(num_spirals * t);

            target.set(x, y * amplitude, z);
        },
        equation: "\\begin{pmatrix}x \\\\ y \\\\ z\\end{pmatrix}=\\begin{pmatrix} a\\left(1-\\frac{\\theta}{2\\pi}\\right)\\cos(n\\theta)(1+\\cos(\\phi))+c\\cos(n\\theta) \\\\  a\\left(1-\\frac{\\theta}{2\\pi}\\right)\\sin(n\\theta)(1+\\cos(\\phi))+c\\sin(n\\theta) \\\\ b\\frac{\\theta}{2\\pi}+a\\left(1-\\frac{\\theta}{2\\pi}\\right)\\sin(\\phi) \\end{pmatrix}\\text{, } \\begin{cases} \\theta \\in [0, 2\\pi] \\\\ \\phi \\in [0, 2\\pi] \\end{cases}"
    }, {
        name: "Cone",
        category: Category.BASIC,
        func: (u, v, amplitude, target) => {
            const
                a = 2, b = 2, c = 4, eps = 1e-4,
                [u1, v1] = [u * (1 - eps) - 0.5, 2 * Math.PI * v],
                x = 2 * a * u1 * Math.cos(v1),
                y = c * u1,
                z = 2 * b * u1 * Math.sin(v1);
            target.set(x, y * amplitude, z);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} a\\cdot u\\cos(v) \\\\ b\\cdot u\\sin(v) \\\\ 2\\cdot u\\end{pmatrix}\\text{, } \\begin{cases} u \\in [-0.5, 0.5] \\\\ v \\in [0, 2\\pi] \\end{cases}"
    }, {
        name: "Cosine",
        category: Category.MISC,
        func: (u, v, amplitude, target) => {
            const
                [theta, phi] = [2 * Math.PI * u, 2 * Math.PI * (1 - v)],
                x = Math.cos(theta),
                y = Math.cos(phi),
                z = Math.cos(theta + phi);

            target.set(x, y * amplitude, z);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} \\cos(\\phi) \\\\ \\cos(\\theta) \\\\ \\cos(\\phi+\\theta)\\end{pmatrix}\\text{, } \\begin{cases} \\theta \\in [0, 2\\pi] \\\\ \\phi \\in [0, 2\\pi] \\end{cases}"
    }, {
        name: "Cylinder",
        category: Category.BASIC,
        func: (u, v, amplitude, target) => {
            const
                r = 2, h=4,
                [theta, height] = [2 * Math.PI * u, 1 - v],
                x = r * Math.cos(theta),
                y = height * h,
                z = r * Math.sin(theta);

            target.set(x, y * amplitude, z);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} r\\cos(\\theta) \\\\ r\\sin(\\theta) \\\\ h\\cdot v\\end{pmatrix}\\text{, } \\begin{cases} \\theta \\in [0, 2\\pi] \\\\ v \\in [0, 1] \\end{cases}"
    }, {
        name: "Dini\'s surface",
        category: Category.SPIRAL,
        func: (u, v, amplitude, target) => {
            const
                b = 0.1, eps = 0.05,
                [theta, phi] = [4 * Math.PI * (1 - u), 1.99 * (eps + (1 - eps) * v)],
                x = Math.cos(theta) * Math.sin(phi),
                y = (Math.cos(phi) + Math.log(Math.tan(phi / 2))) + b * theta,
                z = Math.sin(theta) * Math.sin(phi);

            target.set(x, y * amplitude, z);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} a\\cos(\\theta)\\sin(\\phi) \\\\ a\\sin(\\theta)\\sin(\\phi) \\\\ a(\\cos(\\phi) + \\ln(\\tan(\\phi /2))+b\\theta\\end{pmatrix}\\text{, } \\begin{cases} \\theta \\in [0, 4\\pi] \\\\ \\phi \\in [0, 2\\pi] \\end{cases}"
    }, {
        name: "Elliptic torus",
        category: Category.TOROID,
        func: (u, v, amplitude, target) => {
            const
                a = 1, c = 3,
                [theta, phi] = [2 * Math.PI * u, 2 * Math.PI * (1 - v)],
                x = (a * Math.cos(phi) + c) * Math.cos(theta),
                y = (a * Math.cos(phi) + c) * Math.sin(theta),
                z = a * (Math.sin(phi) + Math.cos(phi))
            target.set(x, z * amplitude, y);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} a(\\cos(\\phi + c)\\cos(\\theta) \\\\ a(\\cos(\\phi + c)\\sin(\\theta) \\\\ a(\\sin(\\phi) + \\cos(\\phi))\\end{pmatrix}\\text{, } \\begin{cases} \\theta \\in [0, 2\\pi] \\\\ \\phi \\in [0, 2\\pi] \\end{cases}"
    }, {
        name: "Helicoid",
        category: Category.SPIRAL,
        func: (u1, v1, amplitude, target) => {
            const
                a = 0.75, b = .6,
                [u, v] = [4 * (u1 - 0.5), 2 * v1 * Math.PI],
                x = a * u * Math.cos(v),
                y = a * u * Math.sin(v),
                z = b * v;
            target.set(x, z * amplitude, y);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} 4a\\cdot u\\cos(v) \\\\ 4a\\cdot u\\sin(v) \\\\ bv\\end{pmatrix}\\text{, } \\begin{cases} u \\in [-2, 2] \\\\ v \\in [0, 2\\pi] \\end{cases}"
    }, {
        name: "Limpet torus",
        category: Category.TOROID,
        func: (u, v, amplitude, target) => {
            const
                sqrt_2 = Math.sqrt(2),
                [theta, phi] = [2 * Math.PI * u, 2 * Math.PI * v],
                x = Math.cos(theta) / (sqrt_2 + Math.sin(phi)),
                y = Math.sin(theta) / (sqrt_2 + Math.sin(phi)),
                z = 1 / (sqrt_2 + Math.cos(phi))
            target.set(x, z * amplitude, y);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} \\cos(\\theta)/(\\sqrt{2} +\\sin(\\phi) \\\\ \\sin(\\theta)/(\\sqrt{2} +\\sin(\\phi) \\\\ 1//(\\sqrt{2} +\\cos(\\phi)\\end{pmatrix}\\text{, } \\begin{cases} \\theta \\in [0, 2\\pi] \\\\ \\phi \\in [0, 2\\pi] \\end{cases}",
    }, {
        name: "Paraboloid",
        category: Category.BASIC,
        func: (u, v, amplitude, target) => {
            const
                a = 2, b = 2, h = 1, eps = 1e-4,
                [u1, v1] = [eps + (1 - eps) * u, 2 * Math.PI * v],
                x = a * Math.sqrt(u1 / h) * Math.cos(v1),
                y = b * Math.sqrt(u1 / h) * Math.sin(v1),
                z = 3 * u1;

            target.set(x, z * amplitude, y);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} a\\sqrt{u/h}\\cos(v) \\\\ b\\sqrt{u/h}\\sin(v) \\\\ 3u\\end{pmatrix}\\text{, } \\begin{cases} u \\in [0, 1] \\\\ v \\in [0, 2\\pi] \\end{cases}"
    },{
        name: "Sine",
        category: Category.MISC,
        func: (u, v, amplitude, target) => {
            const
                [theta, phi] = [2 * Math.PI * u, 2 * Math.PI * v],
                x = Math.sin(theta),
                y = Math.sin(phi),
                z = Math.sin(theta + phi);

            target.set(x, y * amplitude, z);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} \\sin(\\phi) \\\\ \\sin(\\theta) \\\\ \\sin(\\phi+\\theta)\\end{pmatrix}\\text{, } \\begin{cases} \\theta \\in [0, 2\\pi] \\\\ \\phi \\in [0, 2\\pi] \\end{cases}"
    }, {
        name: "Sphere",
        category: Category.BASIC,
        func: (u, v, amplitude, target) => {
            const
                eps = 1e-4,
                [theta, phi] = [2 * Math.PI * u, Math.PI * (eps + (1 - 2 * eps) * v)],
                x = Math.cos(theta) * Math.sin(phi),
                y = Math.sin(theta) * Math.sin(phi),
                z = Math.cos(phi);
            target.set(x, z * amplitude, y);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} r\\cos(\\theta)\\sin(\\phi) \\\\ r\\sin(\\theta)\\sin(\\phi) \\\\ r\\cos(\\phi)\\end{pmatrix}\\text{, } \\begin{cases} \\theta \\in [0, 2\\pi] \\\\ \\phi \\in [0, 2\\pi]\\end{cases}"
    }, {
        name: "Tangent spiral",
        category: Category.SPIRAL,
        func: (u1, v1, amplitude, target) => {
            const
                [u, v] = [(u1 - 0.5) * 3, v1],
                x = Math.sinh(2 * u) / (Math.cos(10 * u) + Math.cosh(2 * u)),
                y = v,
                z = Math.sin(10 * u) / (Math.cos(10 * u) + Math.cosh(2 * u));

            target.set(x, y * amplitude, z);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} \\sinh(2u)/(\\cos(10u) + \\cosh(2u) \\\\ v \\\\ \\sin(10u)/(\\cos(10u) + \\cosh(2u)\\end{pmatrix}\\text{, } \\begin{cases} u \\in [-3/2, 3/2] \\\\ v \\in [0, 1] \\end{cases}"
    }, {
        name: "Torus",
        category: Category.TOROID,
        func: (u, v, amplitude, target) => {
            const
                a = 1, b = 2,
                [theta, phi] = [2 * Math.PI * u, -2 * Math.PI * v],
                x = Math.cos(theta) * (a * Math.cos(phi) + b),
                y = Math.sin(theta) * (a * Math.cos(phi) + b),
                z = Math.sin(phi) * a
            target.set(x, z * amplitude, y);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} \\cos(\\theta)(a \\cos(\\phi) + b) \\\\ \\sin(\\theta)(a \\cos(\\phi) + b) \\\\ a\\sin(\\phi)\\end{pmatrix}\\text{, } \\begin{cases} \\theta \\in [0, 2\\pi] \\\\ \\phi \\in [0, 2\\pi] \\end{cases}"
    }, {
        name: "Trefoil knot",
        category: Category.TOROID,
        func: (u, v, amplitude, target) => {
            const a = 4, b = 2,
                [theta, phi] = [2 * Math.PI * u, 2 * Math.PI * v],
                x = (a * (1 + 0.25 * Math.sin(3 * phi)) + Math.cos(theta)) * Math.cos(2 * phi),
                y = (a * (1 + 0.25 * Math.sin(3 * phi)) + Math.cos(theta)) * Math.sin(2 * phi),
                z = Math.sin(theta) + b * Math.cos(phi * 3);
            target.set(x, z * amplitude, y);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} (a (1 + 0.25\\sin(3\\phi)) + \\cos(\\theta)))\\cos(2\\phi) \\\\ (a (1 + 0.25\\sin(3\\phi)) + \\cos(\\theta)))\\sin(2\\phi) \\\\ \\sin(\\theta) + b\\cos(3\\phi)\\end{pmatrix}\\text{, } \\begin{cases} \\theta \\in [0, 2\\pi] \\\\ \\phi \\in [0, 2\\pi] \\end{cases}"
    }, {
        name: "Twisted torus",
        category: Category.TOROID,
        func: (u, v, amplitude, target) => {
            const
                a = 2, b = 3,
                [theta, phi] = [2 * Math.PI * u, 2 * Math.PI * v],
                x = (a + Math.sin(phi) + Math.cos(theta)) * Math.cos(2 * phi),
                y = (a + Math.sin(phi) + Math.cos(theta)) * Math.sin(2 * phi),
                z = Math.sin(theta) + b * Math.cos(phi)
            target.set(x, z * amplitude, y);
        },
        equation: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} (a + \\cos(\\theta) + \\sin(\\phi))\\cos(2\\phi) \\\\ (a + \\cos(\\theta) + \\sin(\\phi))\\sin(2\\phi) \\\\ \\sin(\\theta) + b\\cos(\\phi)\\end{pmatrix}\\text{, } \\begin{cases} \\theta \\in [0, 2\\pi] \\\\ \\phi \\in [0, 2\\pi] \\end{cases}"
    }];

    class Scenery {
        constructor(scene, worldGroup) {
            this.camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100);
            this.renderer = this.#createRenderer();
            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.scene = scene;

            this.controls.enableDamping = true;
            this.camera.position.set(5, 2, 7);
            this.scene.background = new THREE.Color(0x131313);

            this.scene.add(worldGroup);
            this.scene.add(this.#createDirectionalLight());
            this.scene.add(this.#createHemisphereLight());
        }

        #createHemisphereLight =
            (skyColour=0x87ceeb, groundColour=0x444444) => new THREE.HemisphereLight(skyColour, groundColour, 0.8);

        #createDirectionalLight() {
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 10, 7.5); // kind of "sunlight"
            directionalLight.castShadow = true; // Enable shadows
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            return directionalLight;
        }

        #createRenderer() {
            const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
            renderer.setSize(width, height);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            return renderer;
        }

        setSize(width, height) {
            this.renderer.setSize(width, height);
            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();
        }

        render() {
            this.controls.update();
            this.renderer.render(this.scene, this.camera);
        }
    }

    const params = {
        amplitude: 0.5,
        frequency: 0.5,
        baseColor: "#4f6",
        colorMode: "Height",
        wireframe: false,
        axes: true,
        normals: false,
        animate: false,
        resolution: 50,
        opacity: 0.9,
        category: Category.TOROID
    }

    class ControlsGui {
        constructor(surface, axes, ring) {
            const controls = new GUI({width: 275, autoPlace: false});
            document.getElementById("gui-container").appendChild(controls.domElement);

            const shapeFolder = controls.addFolder("Shape Controls");
            shapeFolder.add(params, 'category', Object.values(Category))
                .name("Category")
                .onChange(() => ring.changeActiveCategoryTo(params.category));
            shapeFolder.add(params, 'amplitude', 0.1, 1).step(0.01).name("Amplitude")
                .onChange(() => parametricSurface.updateNormalsLength(params.resolution));
            shapeFolder.add(params, 'frequency', 0, 2).step(0.01).name("Frequency");

            const appearanceFolder = controls.addFolder("Appearance");
            appearanceFolder.add(params, "colorMode", ["Height", "Base", "Curvature 1", "Curvature 2"])
                .name("Color Mode")
                .onChange(() => surface.updateColors());
            appearanceFolder.add(params, 'baseColor').name("Color").onChange(() => surface.updateColors());
            appearanceFolder.add(params, "resolution", 10, 200, 1).name("Resolution").onChange(resolution => {
                surface.rebuild(resolution)
                surface.updateNormalsLength(resolution);
            });

            appearanceFolder.add(params, "opacity", 0, 1, .01).name("Opacity").onChange(value => surface.setOpacity(value));
            appearanceFolder.add(params, 'animate').name("Animate");
            appearanceFolder.add(params, 'wireframe').name("Wireframe").onChange(value => surface.toggleWireframe(value));
            appearanceFolder.add(params, 'axes').name("Axes").onChange(value => axes.show(value));
            controls.add({reset: () => scenery.camera.position.set(5, 2, 7)}, "reset").name("Reset Camera");
            appearanceFolder.add(params, 'normals').name('Show Normals').onChange(value => {
                surface.normalsVisible = value;
                if (surface.normalsHelper) surface.normalsHelper.visible = value;
            });

            shapeFolder.close();
            appearanceFolder.close();
        }
    }

    class MatlabAxes {
        constructor(parentGroup, axesSize=4, gridDivisions=10) {
            this.axesSize = axesSize;
            this.group = new THREE.Group();

            this.#createGrids(axesSize, gridDivisions);
            this.#createPlanes(axesSize);
            this.group.add(this.#createAxes(axesSize));

            // Group all helpers for easy visibility toggle
            parentGroup.add(this.group);
        }

        #createGrids(axesSize, gridDivisions) {
            const gridXZ = new THREE.GridHelper(axesSize, gridDivisions, 0x444444, 0x444444);
            gridXZ.rotation.x = Math.PI / 2;
            gridXZ.position.set(0, .5 * axesSize, -0.5 * axesSize);
            this.group.add(gridXZ);

            const gridYZ = new THREE.GridHelper(axesSize, gridDivisions, 0x444444, 0x444444);
            gridYZ.rotation.z = Math.PI / 2;
            gridYZ.position.set(-0.5 * axesSize, .5 * axesSize, 0);
            this.group.add(gridYZ);

            const gridXY = new THREE.GridHelper(axesSize, gridDivisions, 0x444444, 0x444444);
            this.group.add(gridXY);
        }

        #createPlanes(axesSize) {
            const planeXZ = this.#createPlane(axesSize, 0, 0, 0);
            planeXZ.rotation.x = -Math.PI / 2;

            const planeYZ = this.#createPlane(axesSize, -0.5, 0.5, 0);
            planeYZ.rotation.y = -Math.PI / 2;

            this.#createPlane(axesSize, 0, 0.5, -0.5);
        }

        #createAxes(axesSize) {
            const eps = .025
            const axesHelper = new THREE.AxesHelper(axesSize);
            axesHelper.position.set(-.5 * axesSize + eps, eps, -.5 * axesSize +eps);
            return axesHelper;
        }

        #createPlane(size, x, y, z, opacity=0.2, color=0x888888) {
            const material = new THREE.MeshPhongMaterial({
                color: color,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: opacity,
                depthWrite: false // ensures grid lines appear on top
            });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(size, size), material);
            mesh.position.set(x * size, y * size, z * size);
            this.group.add(mesh);
            return mesh;
        }

        show = (value) => this.group.visible = value;

        getAxesSize = () => this.axesSize;
    }

    class Surface {
        constructor(parentGroup, surfaceFunction, resolution=75, size=4, wireframe=false) {
            this.surfaceFunction = surfaceFunction ?
                surfaceFunction :
                (u, v, amplitude, target) => { target.set((u - .5) * size, amplitude, (.5 - v) * size); };
            this.parentGroup = parentGroup;
            this.time = 0;
            this.size = size;
            this.setDefaultHeight();
            this.normalsHelper = null;
            this.geometry = null;
            this.mesh = null;
            this.normalsVisible = false;
            this.#buildGeometry(resolution, wireframe);
            this.#fitToAxesAndScale(size);
            this.mesh.userData.surfaceFunction = surfaceFunction;
        }

        #fitToAxesAndScale() {
            this.geometry.computeBoundingBox();
            const box = this.geometry.boundingBox;
            const bbSize = new THREE.Vector3();
            box.getSize(bbSize);
            const maxExtent = Math.max(bbSize.x, bbSize.y, bbSize.z);
            const targetSize = this.size * 0.85;

            const scale = targetSize / maxExtent;
            const position = this.geometry.attributes.position;

            for (let i = 0; i < position.count; i++)
                position.setXYZ(i, position.getX(i) * scale, position.getY(i) * scale, position.getZ(i) * scale);

            const yMin = box.min.y * scale;
            for (let i = 0; i < position.count; i++)
                position.setY(i, position.getY(i) - yMin);

            position.needsUpdate = true;
            this.geometry.computeVertexNormals();
            if (this.normalsHelper) this.normalsHelper.update();
        }

        #magnitudeOfNormalChange = (nx, ny, nz) => Math.sqrt(nx*nx + ny*ny + nz*nz);

        #deviationFromYAxis = (nx, ny, nz) => 1 - Math.abs(ny);

        #computeCurvature(curvatureAlgorithm) {
            const posAttr = this.geometry.attributes.position;
            const normAttr = this.geometry.attributes.normal;
            const curvatures = new Float32Array(posAttr.count);

            for (let i = 0; i < posAttr.count; i++)
                curvatures[i] = curvatureAlgorithm(normAttr.getX(i), normAttr.getY(i), normAttr.getZ(i));

            return curvatures;
        }

        #buildGeometry(resolution, wireframe) {
            this.geometry = new ParametricGeometry(
                (u, v, target) => this.surfaceFunction(u, v, this.#amplitudeModulation(this.time), target),
                resolution, resolution
            );

            const colors = new Float32Array(this.geometry.attributes.position.count * 3);
            this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            if (this.mesh) {
                this.parentGroup.remove(this.mesh);
                this.#removeNormalsHelper();
                this.geometry.dispose();
            }

            this.mesh = new THREE.Mesh(this.geometry, this.#material(wireframe));
            this.parentGroup.add(this.mesh);

            this.#addNormalsHelper();
            this.updateColors();
            this.updateNormalsLength(resolution);
        }

        #addNormalsHelper() {
            this.normalsHelper = new VertexNormalsHelper(this.mesh, 0.2, 0x770000);
            this.normalsHelper.visible = this.normalsVisible;
            this.mesh.add(this.normalsHelper);
        }

        #removeNormalsHelper() {
            if (this.normalsHelper) {
                this.mesh.remove(this.normalsHelper);
                this.normalsHelper.geometry.dispose();
                this.normalsHelper.material.dispose();
                this.normalsHelper = null;
            }
        }

        #updateGeometry() {
            const posAttr = this.geometry.attributes.position;
            const uvAttr  = this.geometry.attributes.uv;
            this._tempVec ??= new THREE.Vector3();
            const temp = this._tempVec;

            for (let i = 0; i < posAttr.count; i++) {
                const u = uvAttr.getX(i);
                const v = uvAttr.getY(i);

                this.surfaceFunction(u, v, this.#amplitudeModulation(this.time), temp);
                posAttr.setXYZ(i, temp.x, temp.y, temp.z);
            }

            posAttr.needsUpdate = true;
            this.geometry.computeVertexNormals();

            if (this.normalsHelper) this.normalsHelper.update();
        }

        #updateColor(yValue, range, useBaseColor = false) {
            const t = range[1] !== range[0] ? (yValue - range[0]) / (range[1] - range[0]) : 0;
            const color = new THREE.Color();
            const hsl = {};

            if (useBaseColor && params.baseColor && this.#isValidColor(params.baseColor)) {
                color.setStyle(params.baseColor);
                color.getHSL(hsl);
                hsl.l = 0.4 + 0.3 * (1 - t);
            } else {
                hsl.h = t * .5 - .025;
                hsl.s = 0.9;
                hsl.l = 0.4 + 0.2 * (1 - t);
            }

            color.setHSL(hsl.h, hsl.s, hsl.l);
            return color;
        }

        #amplitudeModulation = (t) => (1.01 - Math.cos(Math.PI + t * params.frequency)) * params.amplitude;

        #material(showWireframe) {
            return new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                wireframe: showWireframe,
                transparent: true,
                opacity: params.opacity,
            });
        }

        #colorFromCurvature(k) {
            const color = new THREE.Color();
            const t = THREE.MathUtils.clamp(k * 500, 0, 1); // scale curvature for visibility

            if (params.baseColor && this.#isValidColor(params.baseColor)) {
                color.setStyle(params.baseColor);
                const hsl = {};
                color.getHSL(hsl);

                // Modulate lightness and saturation by curvature
                hsl.l = 0.4 + 0.4 * (1 - t); // darker in high curvature
                hsl.s = 0.5 + 0.5 * (1 - t); // less saturated in high curvature, more in low

                color.setHSL(hsl.h, hsl.s, hsl.l);
            } else // fallback gradient if baseColor is invalid
                color.setHSL(0.6 - 0.6 * t, 0.9, 0.5);

            return color;
        }

        #yMinMax() {
            let yMin = Infinity, yMax = -Infinity;
            const posAttr = this.geometry.attributes.position;
            for(let i = 0; i < posAttr.count; i++) {
                const y = posAttr.getY(i);
                if (y < yMin) yMin = y;
                if (y > yMax) yMax = y;
            }
            return [yMin, yMax];
        }

        #isValidColor(str) {
            const s = new Option().style;
            s.color = str;
            return s.color !== '';
        }

        setDefaultHeight = () => this.time = 0;

        toggleWireframe = (value) => this.mesh.material.wireframe = value;

        setOpacity(opacity) {
            this.mesh.material.opacity = opacity;
            this.geometry.attributes.position.needsUpdate = true;
        }

        rebuild(resolution) {
            this.#buildGeometry(resolution, this.mesh.material.wireframe);
            this.#fitToAxesAndScale();
        }

        update(deltaTime) {
            if (!params.animate) return;

            this.time += deltaTime;
            this.#updateGeometry();
            this.#fitToAxesAndScale();
            this.updateColors();
            if (this.normalsHelper) this.updateNormalsLength(params.resolution);
        }

        updateColors() {
            const posAttr = this.geometry.attributes.position;
            const colors = this.geometry.attributes.color.array;
            const range = this.#yMinMax();
            let curvature = params.colorMode === "Curvature 1" ? this.#computeCurvature(this.#deviationFromYAxis) : null;
            curvature = params.colorMode === "Curvature 2" ? this.#computeCurvature(this.#magnitudeOfNormalChange) : curvature;

            for (let i = 0; i < posAttr.count; i++) {
                let c;
                if (params.colorMode === "Height")
                    c = this.#updateColor(posAttr.getY(i), range);
                else if (params.colorMode === "Base")
                    c = this.#updateColor(posAttr.getY(i), range, true); // pass a flag for base color
                else if (params.colorMode === "Curvature 1" || params.colorMode === "Curvature 2")
                    c = this.#colorFromCurvature(curvature[i]);

                colors[3 * i]     = c.r;
                colors[3 * i + 1] = c.g;
                colors[3 * i + 2] = c.b;
            }

            this.geometry.attributes.color.needsUpdate = true;
        }

        updateNormalsLength(resolution) {
            if (!this.normalsHelper) return;

            const baseResolution = 50;     // resolution where base length looks good
            const baseAmplitude = 1.0;     // amplitude where base length looks good
            const baseLength = 0.2;        // default length at base resolution & amplitude

            // Scale inversely with resolution, proportionally with amplitude
            const length = baseLength * (baseResolution / resolution) * (params.amplitude / baseAmplitude);

            this.normalsHelper.size = length;
            this.normalsHelper.update(); // recalc positions
        }

        show = () => this.mesh.material.visible = true;

        hide = () => this.mesh.material.visible = false;

        rotateBy = (delta) => this.mesh.rotation.y += delta;

        setSurfaceFunction(newFunc) {
            this.surfaceFunction = newFunc;
            this.setDefaultHeight();
            this.rebuild(params.resolution);
        }

        moveTo(positionAsVector) {
            this.mesh.position.copy(positionAsVector);
        }
    }

    class RingItem {
        constructor(surface, category, name, equation) {
            this.surface = surface;
            this.category = category;
            this.name = name;
            this.equation = equation;
        }
    }

    class Ring {
        constructor(displaySurface, ringRadius=2, ringRotationSpeed=0.01, selectionLerp=0.08) {
            this.ring = new THREE.Group();
            this.items = [];
            this.displaySurface = displaySurface;
            this.ringRadius = ringRadius;
            this.ringRotationSpeed = ringRotationSpeed;
            this.selectionLerp = selectionLerp;
            this.ringTargetRotation = null;
            this.selectedSurfaceMesh = null;
            this.activeCategory = Category.TOROID;
            scene.add(this.ring);
        }

        #rotationToTargetSurfaceIsNeeded = () => this.ringTargetRotation !== null;

        #rotate() {
            const delta = this.ringTargetRotation - this.ring.rotation.y;
            const shortest = ((delta + Math.PI) % (2 * Math.PI)) - Math.PI;
            this.ring.rotation.y += shortest * this.selectionLerp;

            if (Math.abs(shortest) < 0.001) {
                this.ring.rotation.y = this.ringTargetRotation;
                this.ringTargetRotation = null;
            }
        }

        #setTargetRotation() {
            const local = this.selectedSurfaceMesh.position.clone();
            const angle = Math.atan2(local.x, local.z);
            this.ringTargetRotation = -angle + Math.PI * .3;
        }

        #placeAndShowSurface = (surface, index) => {
            const angle = 2 * Math.PI * index / this.visibleRingItems().length;
            const position = new THREE.Vector3(this.ringRadius * Math.cos(angle), -3, this.ringRadius * Math.sin(angle));
            surface.moveTo(position);
            surface.show();
        };

        #updateSurfaceName() {
            const nameDiv = document.getElementById("surface-name");
            const equationDiv = document.getElementById('surface-equation');

            const item = this.items.find(item => item.surface.mesh === this.selectedSurfaceMesh);
            nameDiv.textContent = item ? item.category + ": " + item.name: "Surface not found";
            equationDiv.innerHTML = item ? "$$" + item.equation + "$$" : "Equation not found";
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, equationDiv]);
            //MathJax.typesetPromise([eqDiv]);
        }

        setSelectedSurfaceMesh = (mesh) => {
            const surfaceFunction = mesh.userData.surfaceFunction;
            this.displaySurface.setSurfaceFunction(surfaceFunction);

            mesh.material.emissive.set(0x111111);
            mesh.material.wireframe = false;
            if (this.selectedSurfaceMesh) {
                this.selectedSurfaceMesh.material.emissive.set(0x000000);
                this.selectedSurfaceMesh.material.wireframe = true;
            }
            this.selectedSurfaceMesh = mesh;
            this.#setTargetRotation();
            this.#updateSurfaceName();
        }

        changeActiveCategoryTo(category) {
            this.activeCategory = category;
            this.redistribute();

            // Auto-select the first surface in the new category, if any
            const firstItem = this.visibleRingItems()[0];
            if (firstItem)
                this.setSelectedSurfaceMesh(firstItem.surface.mesh);
            else {
                this.selectedSurfaceMesh = null;
                this.ringTargetRotation = null;
            }
        }

        getPickableMeshes = () => this.visibleRingItems().map(item => item.surface.mesh);

        rotateRingToSelectedSurface = () => { if (this.#rotationToTargetSurfaceIsNeeded()) this.#rotate(); };

        visibleRingItems = () => this.items.filter(item => item.category === this.activeCategory);

        rotateSurfaces = () => this.visibleRingItems().forEach(item => item.surface.rotateBy(this.ringRotationSpeed));

        redistribute() {
            this.items.forEach(item => item.surface.hide());
            this.visibleRingItems().forEach((item, index) => this.#placeAndShowSurface(item.surface, index));
        }

        addSurface(surface, category, name, equation) {
            this.ring.add(surface.mesh);
            this.items.push(new RingItem(surface, category, name, equation));
        }
    }

    window.addEventListener("resize", () => {
        const w = canvas.clientWidth || width;
        const h = canvas.clientHeight || height;
        scenery.setSize(w, h);
    });

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    canvas.addEventListener("pointerdown", event => {
        mouse.x = (event.offsetX / canvas.clientWidth) * 2 - 1;
        mouse.y = -(event.offsetY / canvas.clientHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, scenery.camera);

        const hits = raycaster.intersectObjects(
            ring.getPickableMeshes(),
            false // IMPORTANT: no recursion
        );

        if (!hits.length) return;

        const mesh = hits[0].object;
        ring.setSelectedSurfaceMesh(mesh);
    });

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x131313);

    const worldGroup = new THREE.Group();
    scene.add(worldGroup);

    const scenery = new Scenery(scene, worldGroup);
    const axes = new MatlabAxes(worldGroup);
    axes.show(true);

    const parametricSurface = new Surface(worldGroup, surfaceDefinitions[0].func, params.resolution);

    const ring = new Ring(parametricSurface);
    surfaceDefinitions.forEach((definition) =>
        ring.addSurface(new Surface(scene, definition.func, 20, 0.8, true), definition.category, definition.name, definition.equation));
    ring.redistribute();

    // Auto-select first surface in the initial category
    const firstItem = ring.visibleRingItems()[0];
    if (firstItem) ring.setSelectedSurfaceMesh(firstItem.surface.mesh);

    new ControlsGui(parametricSurface, axes, ring);

    let lastTime = performance.now();
    function animate() {
        requestAnimationFrame(animate);

        const now = performance.now();
        const deltaTime = params.animate ? (now - lastTime) * 0.001 : 0;
        lastTime = now;

        parametricSurface.update(deltaTime);
        ring.rotateRingToSelectedSurface();
        ring.rotateSurfaces();
        scenery.render();
    }
    animate();

</script>