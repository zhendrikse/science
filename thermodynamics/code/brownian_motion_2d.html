<!--
  -- https://physics.bu.edu/~duffy/HTML5/brownian_motion.html
  -->
<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<canvas class="applicationCanvas" id="brownianCanvas2d" width="500" height="500"></canvas>
<div class="buttonRow">
    <button id="toggle2d">&nbsp;Pause&nbsp;</button>
    <button id="reset2d">Reset</button>
</div>
<p style="clear: both;"></p>
<div class="buttonRow">Molecules:&nbsp;
    <button id="show2d">Show</button>
    <button id="hide2d">Hide</button>
    <button id="add2d">+50</button>
</div>
<p style="clear: both;"></p>
<div>
    <label for="temperatureSlider2d">
        Cold <input type="range" id="temperatureSlider2d" min="0.05" max="2.0" value=".5" step="0.01"/> Hot
    </label>
</div>
<div id="speedPlot" style="margin:auto;"></div>

<link rel="stylesheet" href="https://unpkg.com/uplot/dist/uPlot.min.css">
<script src="https://unpkg.com/uplot/dist/uPlot.iife.min.js"></script>

<script type="module">
    import {Scene, OrthographicCamera, WebGLRenderer, PlaneGeometry, MeshBasicMaterial, Mesh, Vector2,
        CircleGeometry, BufferGeometry, LineBasicMaterial, BufferAttribute, Line } from "three";

    const brownianCanvas2d = document.getElementById("brownianCanvas2d");
    const centerX = brownianCanvas2d.clientWidth  * .5;
    const centerY = brownianCanvas2d.clientHeight * .5;
    const scene = new Scene();

    const camera = new OrthographicCamera(-centerX, centerX, centerY, -centerY, 0.1, 1000);
    camera.position.z = 10;

    const renderer2d = new WebGLRenderer({ antialias: true, canvas: brownianCanvas2d, alpha: true });
    renderer2d.setClearColor(0x232323);
    renderer2d.setSize(brownianCanvas2d.clientWidth, brownianCanvas2d.clientHeight);
    renderer2d.setAnimationLoop( animate );

    const boxSize = 400;
    const boxGeometry = new PlaneGeometry(boxSize, boxSize);
    const boxMaterial = new MeshBasicMaterial({ color:0x131313 });
    const boxMesh = new Mesh(boxGeometry, boxMaterial);
    scene.add(boxMesh);

    class Particle {
        constructor(position, radius, color, mass=1, temperature=0.5, k=1) {
            this._position = position;
            this._radius = radius;
            this._mass = mass;
            this._k = k;
            this._temperature = temperature;

            // Init speed based on temperature: v_rms^2 = 2 k T / m (2D)
            const vRms = Math.sqrt(2 * this._k * this._temperature / this._mass);
            const angle = Math.random() * 2 * Math.PI;
            this._velocity = new Vector2(vRms * Math.cos(angle), vRms * Math.sin(angle));

            const geometry = new CircleGeometry(radius, 24);
            const material = new MeshBasicMaterial({color});
            this._mesh = new Mesh(geometry, material);
            scene.add(this._mesh);
        }

        show = () => this._mesh.visible = true;
        hide = () => this._mesh.visible = false;

        get position() { return this._position; }
        get velocity() { return this._velocity; }
        get radius() { return this._radius; }
        get mass() { return this._mass; }

        speed = () => this._velocity.length();
        kineticEnergy = () => 0.5 * this._mass * this._velocity.lengthSq();
        scaleVelocity = (scale) => this._velocity.multiplyScalar(scale);
        updateMesh = () => this._mesh.position.set(this.position.x, this.position.y, 0);

        reset() {
            this._position.set(0, 0);
            const vRms = Math.sqrt(2 * this._k * this._temperature / this._mass);
            const angle = Math.random() * 2 * Math.PI;
            this._velocity.set(vRms * Math.cos(angle), vRms * Math.sin(angle));
        }

        move() {
            this._position.add(this._velocity);
            const half = .5 * boxSize;
            const left = -half + this.radius;
            const right = half - this.radius;
            const top = half - this.radius;
            const bottom = -half + this.radius;
            this.limitTo(left, right, top, bottom);
        }

        isCollidingWith(otherBall) {
            const r = this.radius + otherBall.radius;
            return this.position.distanceToSquared(otherBall.position) < r * r;
        }

        limitTo(left, right, top, bottom) {
            if (this.position.x > right) this._velocity.x = -Math.abs(this.velocity.x);
            if (this.position.x < left) this._velocity.x = Math.abs(this.velocity.x);
            if (this.position.y > top) this._velocity.y = -Math.abs(this.velocity.y);
            if (this.position.y < bottom) this._velocity.y = Math.abs(this.velocity.y);
        }

        #disentangleFrom(other, r, overlap) {
            const n = r.clone().normalize();

            let selfAdjust = 0.5;
            let otherAdjust = 0.5;
            if (this.radius > other.radius) {
                selfAdjust = 0;
                otherAdjust = 1;
            } else if (this.radius < other.radius) {
                selfAdjust = 1;
                otherAdjust = 0;
            }

            this._position.addScaledVector(n, -selfAdjust * overlap);
            other._position.addScaledVector(n, otherAdjust * overlap);
        }

        collideWith(other) {
            const r = other.position.clone().sub(this.position);
            const distance = r.length();
            const minDist = this.radius + other.radius;
            if (distance === 0 || distance >= minDist) return;

            const overlap = minDist - distance;
            this.#disentangleFrom(other, r, overlap);

            // To center-of-mass frame
            const frame = other.velocity.clone();
            this._velocity.sub(frame);
            other._velocity.sub(frame);

            // Projection onto normal
            const projFactor = this._velocity.dot(r) / r.lengthSq();
            const p = r.clone().multiplyScalar(projFactor);

            // New velocities
            const totalMass = this.mass + other.mass;
            const v1 = this._velocity.clone().sub(p).addScaledVector(p, (this.mass - other.mass) / totalMass);
            const v2 = p.clone().multiplyScalar(2 * this.mass / totalMass);

            this._velocity.copy(v1);
            other._velocity.copy(v2);

            // Back to lab-frame
            this._velocity.add(frame);
            other._velocity.add(frame);
        }
    }

    class Trail {
        constructor(nPath = 500000) {
            this._dust = new Array(nPath);
            this._pushIndex = -1;
            this._index = -1;

            for (let i = 0; i < nPath; i++)
                this._dust[i] = new Vector2(0, 0);

            this._positions = new Float32Array(nPath * 3);
            this._colors    = new Float32Array(nPath * 3);

            this._geometry = new BufferGeometry();
            this._geometry.setAttribute("position",
                new BufferAttribute(this._positions, 3));
            this._geometry.setAttribute("color",
                new BufferAttribute(this._colors, 3));

            this._material = new LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 1,
                depthWrite: false
            });

            this._line = new Line(this._geometry, this._material);
            scene.add(this._line);
        }

        reset() {
            this._index = -1;
            this._pushIndex = -1;
        }

        increment(ball) {
            if (this._index++ > 400 && this._pushIndex === -1)
                this._pushIndex = 0;

            if (this._pushIndex <= -1) return;

            this._dust[this._pushIndex].x = ball.position.x;
            this._dust[this._pushIndex].y = ball.position.y;
        }

        draw(fadeLength = 1000) {
            if (this._pushIndex <= -1) return;

            const startIndex = Math.max(0, this._pushIndex - fadeLength);
            for (let i = startIndex; i <= this._pushIndex; i++) {
                const pos = this._dust[i];
                this._positions[i * 3]     = pos.x;
                this._positions[i * 3 + 1] = pos.y;
                this._positions[i * 3 + 2] = 0;

                // fade factor: 0 = old, 1 = new
                const t = (i - startIndex) / (this._pushIndex - startIndex);
                this._colors[i * 3]     = 0.8 * t;  // R
                this._colors[i * 3 + 1] = 0.0;      // G
                this._colors[i * 3 + 2] = 1.0 * t;  // B
            }

            this._geometry.setDrawRange(startIndex, this._pushIndex - startIndex + 1);
            this._geometry.attributes.position.needsUpdate = true;
            this._geometry.attributes.color.needsUpdate = true;

            this._pushIndex++;
        }
    }


    const trail = new Trail();
    const balls = [];
    let numBalls = 200;
    balls.push(new Particle(new Vector2(0, 0), 20, "red", 100));  // Big red ball
    for (let i = 1; i <= numBalls; i++)
        balls.push(new Particle(new Vector2(0, 0), 5, "yellow"));


    const binCount = 30;
    const maxSpeed = 5;
    const averagingFrames = 100;
    let histogramBuffer = [];
    const binsX = Array.from({length: binCount}, (_, i) => i);

    function computeSpeedDistribution() {
        const bins = new Array(binCount).fill(0);
        const binSize = maxSpeed / binCount;

        let sumV2 = 0;
        for (let i = 1; i < balls.length; i++) {
            const v = balls[i].speed();
            sumV2 += v * v;
            const index = Math.min(Math.floor(v / binSize), binCount - 1);
            bins[index]++;
        }

        const meanV2 = sumV2 / (numBalls - 1);
        return { bins, meanV2 };
    }

    function setTemperature(newTemp) {
        // calculate current effective T via mean kinetic energy
        let sumV2 = 0;
        for (let i = 1; i < balls.length; i++)
            sumV2 += balls[i].velocity.lengthSq();

        const currentTemp = sumV2 / (2 * (balls.length - 1)); // 2D
        const scale = Math.sqrt(newTemp / currentTemp);

        for (let i = 1; i < balls.length; i++)
            balls[i].scaleVelocity(scale);
    }

    function getAveragedHistogram(newBins) {
        histogramBuffer.push(newBins);

        if (histogramBuffer.length > averagingFrames)
            histogramBuffer.shift();

        const average = new Array(binCount).fill(0);
        for (let frame of histogramBuffer)
            for (let i = 0; i < binCount; i++)
                average[i] += frame[i];

        for (let i = 0; i < binCount; i++)
            average[i] /= histogramBuffer.length;

        return average;
    }

    function computeTheoreticalCurve(meanV2, totalParticles) {
        const binSize = maxSpeed / binCount;
        const T = meanV2 / 2;   // effective temperature

        const theory = [];
        for (let i = 0; i < binCount; i++) {
            const v = (i + 0.5) * binSize;
            const value = (v / T) * Math.exp(-v * v / (2 * T));
            theory.push(value);
        }

        // normalize so that area is equal to histogram
        const sumTheory = theory.reduce((a, b) => a + b, 0);
        const scale = totalParticles / sumTheory;

        return theory.map(v => v * scale);
    }

    const speedPlot = new uPlot({
            title: "Speed Distribution (averaged)",
            width: 500,
            height: 300,
            bg: "transparent",
            scales: {
                x: { time: false },
                y: { auto: false, range: [0, 70] }
            },
            series: [
                {},
                {
                    label: "Simulation",
                    stroke: "cyan",
                    fill: "rgba(0,255,255,0.2)"
                },
                {
                    label: "Maxwell (2D)",
                    stroke: "orange",
                    width: 2
                }
            ]
        },
        [binsX, new Array(binCount).fill(0), new Array(binCount).fill(0)],
        document.getElementById("speedPlot"));

    let graphUpdateCounter = 0;
    function updateGraph() {
        if (graphUpdateCounter++ % 5 !== 0)
            return;

        const { bins, meanV2 } = computeSpeedDistribution();
        const averaged = getAveragedHistogram(bins);
        const theory = computeTheoreticalCurve(meanV2, numBalls - 1);
        speedPlot.setData([binsX, averaged, theory]);
    }

    let running = true;
    const toggleButton = document.getElementById("toggle2d");
    toggleButton.onclick = () => { running = !running; toggleButton.innerHTML = running ? "&nbsp;Pause&nbsp;" : "Resume";}
    document.getElementById("show2d").addEventListener("click", () => { for (let ball of balls) ball.show(); });
    document.getElementById("hide2d").addEventListener("click", () => { for (let ball of balls) ball.hide(); balls[0].show() });
    document.getElementById("temperatureSlider2d").addEventListener("input", (event) => setTemperature(Number(event.target.value)));
    document.getElementById("add2d").addEventListener("click", () => {
        for (let i = 0; i < 50; i++)
            balls.push(new Particle(new Vector2(0, 0), 5, "cyan"));

        numBalls += 50;
    });
    document.getElementById("reset2d").addEventListener("click",()=>{
        trail.reset();
        while(balls.length > 201) { // Remove balls that have been added with the add-button, if any
            const ball = balls.pop();
            scene.remove(ball._mesh);
        }

        balls[0]._x = balls[0]._y = 0; // Big red ball
        for(let i = 1; i <= 200; i++)
            balls[i].reset();

        numBalls = 200;
    });

    function iterate() {
        trail.increment(balls[0]);   // big red ball

        for (let ball of balls)
            ball.move();

        for (let i = 0; i < balls.length - 1; i++)
            for (let j = i + 1; j < balls.length; j++)
                if (balls[i].isCollidingWith(balls[j]))
                    balls[i].collideWith(balls[j]);

        for (let ball of balls)
            ball.updateMesh();

        trail.draw();
        updateGraph();
    }

    function animate() {
        for (let i = 0; i < 5; i++)
            if (running) iterate();

        renderer2d.render(scene, camera);
    }
</script>
