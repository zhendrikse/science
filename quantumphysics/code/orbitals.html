<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<div class="canvasWrapper" id="orbitalsContainer">
    <canvas class="applicationCanvas" id="orbitalsCanvas"></canvas><br/>
</div>
<div id="gui-container"></div>

<script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.0/lib/browser/math.js" type="text/javascript"></script>

<script type="module">
    import { Scene, Color, Group } from "three";
    import { AxesController, ThreeJsUtils, Plot3DView, AxesParameters, Interval }
        from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";
    import { SignedOpacityColorMapper, ViewParameters, ContourType, TangentFrameParameters, ContourParameters,
        SurfaceSpecification, LiteralStringBasedSurfaceDefinition, Surface, SurfaceController, SurfaceDefinition }
        from 'https://www.hendrikse.name/science/js/3d-surface-components.js';

    const canvasContainer = document.getElementById("orbitalsContainer");
    const canvas = document.getElementById("orbitalsCanvas");

    const scene = new Scene();
    const worldGroup = new Group();
    scene.add(worldGroup);

    const surfaceData = [{
        meta: { name: "1s" },
        parametrization: {
            xFn: (u, v) => Math.sin(u) * Math.cos(v),
            yFn: (u, v) => Math.cos(u),
            zFn: (u, v) => Math.sin(u) * Math.sin(v)
        },
        signedField: { field: (u, v) => 1 },
        intervals: [[-Math.PI, Math.PI], [0, Math.PI]]
    }, {
        meta: { name: "2pâ‚“" },
        parametrization: {
            xFn: (u, v) => Math.abs(Math.sin(u) * Math.cos(v)) * Math.sin(u) * Math.cos(v),
            yFn: (u, v) => Math.abs(Math.sin(u) * Math.cos(v)) * Math.cos(u),
            zFn: (u, v) => Math.abs(Math.sin(u) * Math.cos(v)) * Math.sin(u) * Math.sin(v)
        },
        signedField: { field: (u, v) => Math.sin(u) * Math.cos(v) },
        intervals: [[-Math.PI, Math.PI], [0, Math.PI]]
    },{
        meta: { name: "2páµ§" },
        parametrization: {
            xFn: (u, v) => Math.abs(Math.cos(u)) * Math.sin(u) * Math.cos(v),
            yFn: (u, v) => Math.abs(Math.cos(u)) * Math.cos(u),
            zFn: (u, v) => Math.abs(Math.cos(u)) * Math.sin(u) * Math.sin(v)
        },
        signedField: { field: (u, v) => Math.cos(u) },
        intervals: [[-Math.PI, Math.PI], [0, Math.PI]]
    }, {
        meta: { name: "2p_z" },
        parametrization: {
            xFn: (u, v) => Math.abs(Math.sin(u) * Math.sin(v)) * Math.sin(u) * Math.cos(v),
            yFn: (u, v) => Math.abs(Math.sin(u) * Math.sin(v)) * Math.cos(u),
            zFn: (u, v) => Math.abs(Math.sin(u) * Math.sin(v)) * Math.sin(u) * Math.sin(v)
        },
        signedField: { field: (u, v) => Math.sin(u) * Math.sin(v) },
        intervals: [[-Math.PI, Math.PI], [0, Math.PI]]
    }, {
        meta: { name: "3d_zÂ²" },
        parametrization: {
            xFn: (u, v) => Math.abs(3 * Math.cos(u)^2-1) * Math.sin(u) * Math.cos(v),
            yFn: (u, v) => Math.abs(3 * Math.cos(u)^2-1) * Math.cos(u),
            zFn: (u, v) => Math.abs(3 * Math.cos(u)^2-1) * Math.sin(u) * Math.sin(v)
        },
        signedField: { field: (u, v) => "3*Math.cos(u)^2-1" },
        intervals: [[-Math.PI, Math.PI], [0, Math.PI]]
    }, {
        meta: { name: "3d_xz" },
        parametrization: {
            xFn: (u, v) => Math.abs(Math.sin(u) * Math.cos(u) * Math.cos(v)) * Math.sin(u) * Math.cos(v),
            yFn: (u, v) => Math.abs(Math.sin(u) * Math.cos(u) * Math.cos(v)) * Math.cos(u),
            zFn: (u, v) => Math.abs(Math.sin(u) * Math.cos(u) * Math.cos(v)) * Math.sin(u) * Math.sin(v)
        },
        signedField: { field: (u, v) => Math.sin(u) * Math.cos(u) * Math.cos(v) },
        intervals: [[-Math.PI, Math.PI], [0, Math.PI]]
    }, {
        meta: { name: "3d_yz" },
        parametrization: {
            xFn: (u, v) => Math.abs(Math.sin(u) * Math.cos(u) * Math.sin(v)) * Math.sin(u) * Math.cos(v),
            yFn: (u, v) => Math.abs(Math.sin(u) * Math.cos(u) * Math.sin(v)) * Math.cos(u),
            zFn: (u, v) => Math.abs(Math.sin(u) * Math.cos(u) * Math.sin(v)) * Math.sin(u) * Math.sin(v)
        },
        signedField: { field: (u, v) => Math.sin(u) * Math.cos(u) * Math.sin(v) },
        intervals: [[-Math.PI, Math.PI], [0, Math.PI]]
    }, {
        meta: { name: "3d_xÂ²â‚‹zÂ²" },
        parametrization: {
            xFn: (u, v) => Math.abs(Math.sin(u)**2 * Math.cos(2 * v)) * Math.sin(u) * Math.cos(v),
            yFn: (u, v) => Math.abs(Math.sin(u)**2 * Math.cos(2 * v)) * Math.cos(u),
            zFn: (u, v) => Math.abs(Math.sin(u)**2 * Math.cos(2 * v)) * Math.sin(u) * Math.sin(v)
        },
        signedField: { field: (u, v) => Math.sin(u)**2 * Math.cos(2*v) },
        intervals: [[-Math.PI, Math.PI], [0, Math.PI]]
    }, {
        meta: { name: "3d_xy" },
        parametrization: {
            xFn: (u, v) => Math.abs(Math.sin(u)**2 * Math.sin(2 * v)) * Math.sin(u) * Math.cos(v),
            yFn: (u, v) => Math.abs(Math.sin(u)**2 * Math.sin(2 * v)) * Math.cos(u),
            zFn: (u, v) => Math.abs(Math.sin(u)**2 * Math.sin(2 * v)) * Math.sin(u) * Math.sin(v)
        },
        signedField: { field: (u, v) => Math.sin(u)**2 * Math.sin(2*v) },
        intervals: [[-Math.PI, Math.PI], [0, Math.PI]]
    }, {
        meta: { name: "4f_zÂ³" },
        parametrization: {
            xFn: (u, v) => Math.abs(5 * Math.cos(u)**3 - 3 * Math.cos(u)) * Math.sin(u) * Math.cos(v),
            yFn: (u, v) => Math.abs(5 * Math.cos(u)**3 - 3 * Math.cos(u)) * Math.cos(u),
            zFn: (u, v) => Math.abs(5 * Math.cos(u)**3 - 3 * Math.cos(u)) * Math.sin(u) * Math.sin(v)
        },
        signedField: { field: (u, v) => 5 * Math.cos(u)**3 - 3 * Math.cos(u) },
        intervals: [[-Math.PI, Math.PI], [0, Math.PI]]
    }, {
        meta: { name: "4f_xyz" },
        parametrization: {
            xFn: (u, v) => 2 * Math.abs(Math.sin(u)**2 * Math.cos(u) * Math.sin(2 * v)) * Math.sin(u) * Math.cos(v),
            yFn: (u, v) => 2 * Math.abs(Math.sin(u)**2 * Math.cos(u) * Math.sin(2 * v)) * Math.cos(u),
            zFn: (u, v) => 2 * Math.abs(Math.sin(u)**2 * Math.cos(u) * Math.sin(2 * v)) * Math.sin(u) * Math.sin(v)
        },
        signedField: { field: (u, v) => Math.sin(u)**2 * Math.cos(u) * Math.sin(2 * v) },
        intervals: [[-Math.PI, Math.PI], [0, Math.PI]]
    }, {
        meta: { name: "4f_x(xÂ²âˆ’3zÂ²)" },
        parametrization: {
            xFn: (u, v) => Math.abs(Math.sin(u)**3 * Math.cos(3 * v)) * Math.sin(u) * Math.cos(v),
            yFn: (u, v) => Math.abs(Math.sin(u)**3 * Math.cos(3 * v)) * Math.cos(u),
            zFn: (u, v) => Math.abs(Math.sin(u)**3 * Math.cos(3 * v)) * Math.sin(u) * Math.sin(v)
        },
        signedField: { field: (u, v) => Math.sin(u)**3 * Math.cos(3 * v) },
        intervals: [[-Math.PI, Math.PI], [0, Math.PI]]
    }, {
        meta: { name: "4f_z(xÂ²âˆ’zÂ²)" },
        parametrization: {
            xFn: (u, v) => Math.abs(Math.sin(u)**3 * Math.sin(3 * v)) * Math.sin(u) * Math.cos(v),
            yFn: (u, v) => Math.abs(Math.sin(u)**3 * Math.sin(3 * v)) * Math.cos(u),
            zFn: (u, v) => Math.abs(Math.sin(u)**3 * Math.sin(3 * v)) * Math.sin(u) * Math.sin(v)
        },
        signedField: { field: (u, v) => Math.sin(u)**3 * Math.sin(3 * v) },
        intervals: [[-Math.PI, Math.PI], [0, Math.PI]]
    }];

    class OrbitalSurfaceSpecification extends SurfaceSpecification {
        constructor({ meta, parametrization, intervals, signedField }) {
            super({meta, parametrization, intervals});
            this._signedField = signedField;
            Object.freeze(this);
        }

        get signedFieldFunction() { return this._signedField.field; }

        withParametrization(patch) {
            return new OrbitalSurfaceSpecification({
                meta: this._meta,
                intervals: this._intervals,
                signedField: this._signedField,
                parametrization: {
                    ...this._parametrization,
                    ...patch
                }
            });
        }
    }

    class OrbitalSurfaceDefinition extends SurfaceDefinition {
        constructor(surfaceSpecification) {
            super();

            this._xFn = surfaceSpecification.parametrization.xFn;
            this._yFn = surfaceSpecification.parametrization.yFn;
            this._zFn = surfaceSpecification.parametrization.zFn;

            this._uInterval = new Interval(surfaceSpecification.intervals[0][0], surfaceSpecification.intervals[0][1]);
            this._vInterval = new Interval(surfaceSpecification.intervals[1][0], surfaceSpecification.intervals[1][1]);
        }

        sample(u, v, target) {
            const U = this._uInterval.scaleUnitParameter(u);
            const V = this._vInterval.scaleUnitParameter(v);

            target.set(
                this._xFn(U, V),
                this._yFn(U, V),
                this._zFn(U, V)
            );
        }

        specification() { return this._surfaceSpecification; }
    }


    class ControlsGui {
        constructor(surfaceController, axesController, plot3d) {
            const gui = new GUI({width: "100%", autoPlace: false});

            const OrbitalPresets = Object.fromEntries(surfaceData.map((surface, index) => [surface.meta.name, index]));

            this._axesController = axesController;
            this._surfaceController = surfaceController;
            this._plot3d = plot3d;

            gui.add(params, "surfacePreset", OrbitalPresets)
                .name("Orbital")
                .onChange(index => {
                    const data = surfaceData[index];
                    const spec = new OrbitalSurfaceSpecification(data);
                    this.#updateSurface(spec);
                });


            this.#createContourFolder(gui);
            this.#createAxesFolder(gui);
            document.getElementById("gui-container").appendChild(gui.domElement);
        }

        #isValidColor() {
            const style = new Option().style;
            style.color = surfaceParams.baseColor;
            return style.color !== '';
        }

        #createAxesFolder(parentFolder) {
            const axesFolder = parentFolder.addFolder("Axes");
            const dummyToggle = {gridPlanes: true};
            axesFolder.add(params.axesParameters, 'frame')
                .name("Frame").onChange(value => axesController.updateSettings());
            axesFolder.add(dummyToggle, 'gridPlanes')
                .name("Layout").onChange(value => {
                params.axesParameters.xyPlane = value;
                params.axesParameters.xzPlane = value;
                params.axesParameters.yzPlane = value;
                axesController.updateSettings();
            });
            axesFolder.add(params.axesParameters, 'annotations')
                .name("Annotations").onChange(value => axesController.updateSettings());
            axesFolder.close();
        }

        #createContourFolder(folder) {
            const contourFolder = folder.addFolder("Contours");
            contourFolder.add(surfaceParams.contourParameters, "contourType", Object.values(ContourType))
                .name("Contour type")
                .onChange(value => this._surfaceController.onContourTypeChange(surfaceParams.contourParameters));
            contourFolder.add(surfaceParams.contourParameters, 'color')
                .name("Color")
                .onChange(() => {if (this.#isValidColor()) this._surfaceController.onContourSettingsChange(surfaceParams.contourParameters);});
            contourFolder.add(surfaceParams.contourParameters, "uCount", 1, 50, 1)
                .name("U contours")
                .onFinishChange(value => this._surfaceController.onContourSettingsChange(surfaceParams.contourParameters));
            contourFolder.add(surfaceParams.contourParameters, "vCount", 1, 50, 1)
                .name("V contours")
                .onFinishChange(value => this._surfaceController.onContourSettingsChange(surfaceParams.contourParameters));
            contourFolder.close();
        }

        #updateSurface(surfaceSpecification) {
            const surfaceDef = new OrbitalSurfaceDefinition(surfaceSpecification);
            this._surfaceController.onSurfaceChange(new Surface(surfaceDef), surfaceParams);
            this._surfaceController.onColorMapperChange(new SignedOpacityColorMapper(surfaceSpecification.signedFieldFunction));
            this._axesController.createFromBoundingBox(surfaceController.surfaceBoundingBox());
            this._plot3d.frame(ThreeJsUtils.scaleBox3(surfaceController.surfaceBoundingBox(), .9));
        }
    }

    const surfaceParams = new ViewParameters({
        contourParameters: new ContourParameters({
            contourType: ContourType.NONE
        }),
        tangentFrameParameters: new TangentFrameParameters({
            visible: false
        }),
        opacity: 0.95,
        resolution: 125
    });

    const params = {
        axesParameters: new AxesParameters({annotations: false}), //, xyPlane: false, xzPlane: false, yzPlane: false}),
        surfacePreset: "4f_zÂ³"
    };
    const axesController = new AxesController({
        parentGroup: worldGroup,
        canvasContainer: canvasContainer,
        axesParameters: params.axesParameters,
        scene: scene
    });

    const defaultSurfaceSpec = new OrbitalSurfaceSpecification(surfaceData[9]);
    const surfaceDef = new OrbitalSurfaceDefinition(defaultSurfaceSpec);
    const orbitalColorMapper = new SignedOpacityColorMapper(defaultSurfaceSpec.signedFieldFunction);
    const surfaceController = new SurfaceController(worldGroup, new Surface(surfaceDef), surfaceParams, orbitalColorMapper);

    // Scale scene according to current surface
    axesController.createFromBoundingBox(surfaceController.surfaceBoundingBox());
    const plot3D = new Plot3DView(scene, canvas, surfaceController.surfaceBoundingBox());
    plot3D.frame(ThreeJsUtils.scaleBox3(surfaceController.surfaceBoundingBox(), .9));
    const gui = new ControlsGui(surfaceController, axesController, plot3D);

    // Resizing for mobile devices
    function resize() {
        ThreeJsUtils.resizeRendererToCanvas(plot3D.renderer, plot3D.camera);
        axesController.resize();
    }
    window.addEventListener("resize", resize);
    resize();

    function animate() {
        requestAnimationFrame(animate);
        plot3D.render();
        axesController.render(plot3D.camera);
    }
    animate();
</script>

<!--
Ja â€” **helemaal mee eens** ðŸ‘
Als *math.js* er toch al in zit, is dit precies het moment om het **netjes en algemeen** te doen, zonder dat het meteen â€œte academischâ€ wordt.

Ik zal je laten zien:

1. **Welke formule je nodig hebt** (praktisch, niet textbook-zwaar)
2. **Hoe je die met math.js implementeert**
3. **Hoe dit in jouw bestaande structuur past**
4. **Wat dit je kost in werk en complexiteit**

---

## 1ï¸âƒ£ De radiale functie die je echt wilt

Voor waterstofachtige orbitalen:

[
R_{nl}(r) = e^{-r/n}, r^l, L_{n-l-1}^{2l+1}!\left(\tfrac{2r}{n}\right)
]

Waar:

* (L_k^{\alpha}(x)) = geassocieerde Laguerre-polynomen
* normalisatie mag je **weglaten** voor visualisatie

ðŸ‘‰ Dit is *exact* geschikt voor math.js:

* exponent
* machten
* polynomen
* geen integralen nodig

---

## 2ï¸âƒ£ Laguerre-polynomen met math.js

math.js heeft **geen kant-en-klare Laguerre**, maar wÃ©l:

* binomiaalcoÃ«fficiÃ«nten
* factorial
* powers

De definitie:

[
L_n^{\alpha}(x)
===============

\sum_{k=0}^{n}
(-1)^k
\binom{n+\alpha}{n-k}
\frac{x^k}{k!}
]

### JS-implementatie (compact & robuust)

```js
function generalizedLaguerre(n, alpha, x) {
    let sum = 0;
    for (let k = 0; k <= n; k++) {
        const coeff =
            Math.pow(-1, k) *
            math.combinations(n + alpha, n - k) /
            math.factorial(k);

        sum += coeff * Math.pow(x, k);
    }
    return sum;
}
```

---

## 3ï¸âƒ£ Radiale functie `R_nl(r)`

```js
function radialHydrogen(n, l, r) {
    const rho = 2 * r / n;
    return Math.exp(-rho / 2) *
           Math.pow(rho, l) *
           generalizedLaguerre(n - l - 1, 2 * l + 1, rho);
}
```

âœ”ï¸ klopt qua nulpunten
âœ”ï¸ shape is correct
âœ”ï¸ schaal is arbitrair (prima)

---

## 4ï¸âƒ£ Integratie in jouw surface pipeline

Je hoeft **geen nieuwe SurfaceView** te maken.

### Uitbreiding van je `OrbitalSurfaceSpecification`

```js
class OrbitalSurfaceSpecification extends SurfaceSpecification {
    constructor({ meta, parametrization, intervals, signedField, n, l }) {
        super({ meta, parametrization, intervals });
        this._signedField = signedField;
        this._n = n;
        this._l = l;
        Object.freeze(this);
    }

    radialFn(r) {
        return radialHydrogen(this._n, this._l, r);
    }
}
```

---

### In je parametrisatie

In plaats van:

```js
abs(signedField(u,v)) * direction
```

doe je:

```js
const Y = signedField(u, v);
const R = radialFn(r0);   // r0 slider of vaste waarde
const A = Math.abs(R * Y);
```

En klaar.

---

## 5ï¸âƒ£ GUI: minimale toevoeging

EÃ©n slider is genoeg:

```js
surfaceParams.radialScale = 1.0;
gui.add(surfaceParams, 'radialScale', 0.1, 10.0);
```

Gebruik `r = radialScale`.

---

## â±ï¸ Extra werk t.o.v. â€œhandmatigâ€

| Onderdeel              | Extra tijd |
| ---------------------- | ---------- |
| Laguerre-implementatie | 30 min     |
| Radial helper          | 15 min     |
| Integratie + testen    | 30â€“45 min  |
| **Totaal extra**       | **Â±1 uur** |

Voor die ene extra uur:

* krijg je **alle n,l orbitalen gratis**
* geen hardcoded specials
* perfecte opstap naar volumetrische kansdichtheid

---

## âš ï¸ EÃ©n subtiele maar belangrijke tip

Clamp je radius:

```js
const r = Math.min(radialScale, 10 * n);
```

Anders explodeert `L_n^Î±` voor grote r en krijg je lelijke spikes.

---

## ðŸŽ¯ Samenvatting

âœ”ï¸ math.js is hier exact het juiste gereedschap
âœ”ï¸ radiale nodes zijn een *schone, zelfstandige stap*
âœ”ï¸ implementatie is kort en algemeen
âœ”ï¸ je architectuur blijft intact

Als je wilt, kan ik in de volgende stap:

* een **kant-en-klare 2s / 3s / 3p vergelijking** geven om te vergelijken
* of samen een **didactisch goede slider-set** kiezen (n, l, radial scale)

Zeg maar waar je heen wilt ðŸš€
-->