<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<div class="titleDiv" id="vectorFieldTitle"></div>
<div class="canvasWrapper" id="quiverContainer">
    <canvas class="applicationCanvas" id="quiverCanvas"></canvas><br/>
</div>
<div class="guiContainer" id="gui-container"></div>

<script type="module">
    import { Plot3DView, AxesController, ThreeJsUtils, ArrowField, VectorField, Range, AxesParameters }
        from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";
    import { Vector3, Scene, Color, Group, Box3 } from "three";

    const canvasContainer = document.getElementById("quiverContainer");
    const canvas = document.getElementById("quiverCanvas");

    const scene = new Scene();
    scene.background = new Color(0x131313);
    const worldGroup = new Group();
    scene.add(worldGroup);

    const VectorFields = Object.freeze({
        FIELD_1: "Vector field 1",
        FIELD_2: "Vector field 2"
    });

    class VectorField1 extends VectorField {
        constructor() {
            super();
            this.meta = "$$\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} =" +
                "\\begin{pmatrix} \\sin(\\pi x)\\cos(\\pi y)\\cos(\\pi z) \\\\ " +
                "-\\cos(\\pi  x)\\sin(\\pi y)\\cos(\\pi z) \\\\" +
                " (\\sqrt{(2 / 3)} \\cos(\\pi x)\\cos(\\pi y)\\sin(\\pi z)) \\end{pmatrix}$$";
        }

        sample(position) {
            const u = Math.sin(Math.PI * position.x) * Math.cos(Math.PI * position.y) * Math.cos(Math.PI * position.z);
            const v = -Math.cos(Math.PI * position.x) * Math.sin(Math.PI * position.y) * Math.cos(Math.PI * position.z);
            const w = Math.sqrt(2.0 / 3.0) * Math.cos(Math.PI * position.x) * Math.cos(Math.PI * position.y) * Math.sin(Math.PI * position.z);
            return new Vector3(u, v, w);
        }
    }

    class VectorField2 extends VectorField {
        constructor() {
            super();
            this.meta = "$$\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}$$";
        }

        sample(position) {
            return position.clone();
        }
    }

    const params = {
        animate: false,
        vectorField: VectorFields.FIELD_1,
        colorMode: ArrowField.ColorMode.MAGNITUDE,
        axesParameters: new AxesParameters({annotations: false}),
        tilt: 15
    };
    const axesController = new AxesController({
        parentGroup: worldGroup,
        canvasContainer,
        axesParameters: params.axesParameters,
        scene
    });

    class ControlsGui {
        constructor() {
            const gui = new GUI({width: 300, autoPlace: false});
            gui.add(params, 'vectorField', Object.values(VectorFields))
                .name("Field type")
                .onChange(value => this.#changeVectorFieldTo(value));
            gui.add(params, "animate").name("Animate");
            gui.add(params, "colorMode", Object.values(ArrowField.ColorMode))
                .name("Color by")
                .onChange(mode => arrowField.changeColorModeTo(mode));
            gui.add({reset: () =>  arrowField.reset()}, "reset")
                .name("Reset field");

            const axesFolder = gui.addFolder("Axes");
            const dummyToggle = {gridPlanes: true};
            axesFolder.add(params.axesParameters, 'frame')
                .name("Frame").onChange(value => axesController.updateSettings());
            axesFolder.add(dummyToggle, 'gridPlanes')
                .name("Layout").onChange(value => {
                params.axesParameters.xyPlane = value;
                params.axesParameters.xzPlane = value;
                params.axesParameters.yzPlane = value;
                axesController.updateSettings();
            });
            axesFolder.add(params.axesParameters, 'annotations')
                .name("Annotations").onChange(value => axesController.updateSettings());
            axesFolder.close();

            document.getElementById("gui-container").appendChild(gui.domElement);
        }

        #changeVectorFieldTo(vectorField) {
            switch (vectorField) {
                case VectorFields.FIELD_1:
                    equationDiv.innerHTML = vectorField1.meta;
                    arrowField.updateFieldWith(vectorField1);
                    break;
                case VectorFields.FIELD_2:
                    equationDiv.innerHTML = vectorField2.meta;
                    arrowField.updateFieldWith(vectorField2);
                    break;
            }
            if (window.MathJax) MathJax.typesetPromise([equationDiv]);
        }
    }

    const vectorField1 = new VectorField1();
    const vectorField2 = new VectorField2();
    const arrowField = new ArrowField(
        new Range(-1, 0.8, .2), new Range(-1, 0.8, .1), new Range(-1, 0.8, .2),
        vectorField1,
        { scaleFactor: 0.2 }
    );
    worldGroup.add(arrowField);

    const boundingBox = new Box3();
    boundingBox.setFromObject( arrowField );

    axesController.createFromBoundingBox(boundingBox);

    const plot3D = new Plot3DView(scene, canvas, boundingBox);
    plot3D.frame(ThreeJsUtils.scaleBox3(boundingBox, .9));
    const gui = new ControlsGui();

    // Resizing for mobile devices
    function resize() {
        ThreeJsUtils.resizeRendererToCanvas(plot3D.renderer, plot3D.camera);
        axesController.resize();
    }
    window.addEventListener("resize", resize);
    resize();

    const equationDiv = document.getElementById("vectorFieldTitle");
    equationDiv.innerHTML = vectorField1.meta;
    if (window.MathJax) MathJax.typesetPromise([equationDiv]);

    function animate() {
        requestAnimationFrame(animate);
        plot3D.render();
        axesController.render(plot3D.camera);
        if (!params.animate) return;
        arrowField.euler();
    }
    animate();
</script>
