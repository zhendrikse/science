<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<canvas id="myCanvas" width="600" height="600"></canvas>
<h1>Graph</h1>
<canvas id="graphCanvas" width="600" height="300" style="background-color: #131313"></canvas>

<script type="module">
    import * as THREE from "three";
    import { Spring, Ball } from 'https://www.hendrikse.name/science/js/three-js-extensions.js';

    // --- Scene setup ---
    const canvas = document.getElementById("myCanvas");
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x131313);

    const g = 9.8; // gravitational constant

    const camera = new THREE.PerspectiveCamera(45, canvas.clientWidth/canvas.clientHeight, 0.1, 100);
    camera.position.set(15, 15, 30);
    camera.lookAt(0, 5, 0);

    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);

    scene.add(new THREE.HemisphereLight(0xffffff,0x222222,0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);
    renderer.shadowMap.enabled = true;
    dirLight.castShadow = true;

    // --- Plafond ---
    // const ceilingSize = 50;
    // const ceilingGeometry = new THREE.PlaneGeometry(ceilingSize, ceilingSize);
    // const ceilingMaterial = new THREE.MeshStandardMaterial({
    //     color: 0x8a8a8a,
    //     metalness: 0.05,
    //     roughness: 0.95,
    //     side: THREE.DoubleSide
    // });
    // ceilingMaterial.bumpScale = 0.05;
    //
    // const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    //
    // // horizontal plane
    // ceiling.rotation.x = Math.PI / 2;
    // ceiling.position.y = start.y;
    //
    // scene.add(ceiling);
    // ceiling.receiveShadow = true;

    // Spring
    const suspensionPoint = new THREE.Vector3(0, 15, 0);
    const axis = new THREE.Vector3(0, -10, 0);
    const slinky = new Spring(scene, suspensionPoint, axis, {k:200, length:15, longitudinalOscillation: true});

    // Ball
    const ballPosition = new THREE.Vector3(
        (Math.random() - 0.5) * 0.5,  // ±0.25 in X
        0,
        (Math.random() - 0.5) * 0.5   // ±0.25 in Z
    );
    const ball = new Ball(scene, {position: ballPosition, radius: 1, mass: 10});
    slinky.updateAxis(ball.position().sub(suspensionPoint.clone()));

    // --- Mouse click & drag ---
    let dragging = false;
    let mouseY = 0;
    canvas.addEventListener('mousedown', e => {
        const rect = canvas.getBoundingClientRect();
        mouseY = ((e.clientY - rect.top) / rect.height) * 2 - 1; // niet exact nodig voor nu
        dragging = true;
    });
    canvas.addEventListener('mouseup', e => dragging = false);
    canvas.addEventListener('mousemove', e => {
        if(dragging){
            const rect = canvas.getBoundingClientRect();
            const x = ((e.clientX - rect.left)/rect.width - 0.5) * 20; // scale to scene
            const y = 10 - ((e.clientY - rect.top) / rect.height) * 20;
            ball.moveTo(new THREE.Vector3(x, y, 0));
            ball.accelerateTo(new THREE.Vector3(0, 0, 0));
        }
    });

    const dt = 0.02;
    const graphCanvas = document.getElementById("graphCanvas");
    const graph = new Graph(graphCanvas, {
        maxPoints: 300,
        dt: dt,
        scaleY: 0.1
    });

    graph.addSeries("KE", "red");
    graph.addSeries("PE", "lime");
    graph.addSeries("E",  "cyan");
    graph.addSeries("Y",  "yellow");


    function force(kHorizontal = 100, damping = 1) { // horizontal spring constant
        const pos = ball.position();
        const vel = ball.velocity();

        const fx = -kHorizontal * pos.x - damping * vel.x;
        const fy = slinky.force() - ball.mass() * g - damping * vel.y;
        const fz = -kHorizontal * pos.z - damping * vel.z;

        return new THREE.Vector3(fx, fy, fz);
    }

    let time = 0;
    function animate() {
        requestAnimationFrame(animate);
        time += dt;

        if (!dragging) ball.semiImplicitEulerUpdate(force(), dt);

        slinky.updateAxis(ball.position().sub(suspensionPoint.clone()));
        slinky.update(time);

        const springExtension = slinky.displacement();
        const potentialSpring = 0.5 * slinky.k * springExtension ** 2;
        const potentialGravity = ball.mass() * g * ball.position().y;
        const kinetic = ball.kineticEnergy();

        graph.push({
            KE: kinetic,
            PE: potentialSpring + potentialGravity,
            E:  kinetic + potentialSpring + potentialGravity,
            Y:  (5 + ball.position().y) * 100
        });

        graph.draw();

        renderer.render(scene, camera);
    }


    animate();

    // --- interactive: spring hardening / softening ---
    window.addEventListener('keydown', e => {
        if(e.key==='ArrowUp') slinky.k +=20;
        if(e.key==='ArrowDown') slinky.k -=20;
        slinky.k = Math.max(20, slinky.k);
        console.log("k =", slinky.k);
    });
</script>

