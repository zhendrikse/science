<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<canvas id="myCanvas" width="600" height="600"></canvas>
<h1>Graph</h1>
<canvas id="graphCanvas" width="600" height="300" style="background-color: #131313"></canvas>

<script type="module">
    import * as THREE from "three";
    import { Ball, Spring } from 'https://www.hendrikse.name/science/js/three-js-extensions.js';

    // --- Scene setup ---
    const canvas = document.getElementById("myCanvas");
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x131313);

    const g = 9.8; // gravitational constant

    const camera = new THREE.PerspectiveCamera(45, canvas.clientWidth/canvas.clientHeight, 0.1, 100);
    camera.position.set(15, 15, 30);
    camera.lookAt(0, 5, 0);

    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);

    scene.add(new THREE.HemisphereLight(0xffffff,0x222222,0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);
    renderer.shadowMap.enabled = true;
    dirLight.castShadow = true;


    // --- Plafond ---
    // const ceilingSize = 50;
    // const ceilingGeometry = new THREE.PlaneGeometry(ceilingSize, ceilingSize);
    // const ceilingMaterial = new THREE.MeshStandardMaterial({
    //     color: 0x8a8a8a,
    //     metalness: 0.05,
    //     roughness: 0.95,
    //     side: THREE.DoubleSide
    // });
    // ceilingMaterial.bumpScale = 0.05;
    //
    // const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    //
    // // horizontal plane
    // ceiling.rotation.x = Math.PI / 2;
    // ceiling.position.y = start.y;
    //
    // scene.add(ceiling);
    // ceiling.receiveShadow = true;

    // Constants and parameters



    // Spring
    const suspensionPoint = new THREE.Vector3(0, 15, 0);
    const axis = new THREE.Vector3(0, -10, 0);
    const slinky = new Spring(scene, suspensionPoint, axis, {k:200, length:15, longitudinalOscillation: true});

    // Ball
    const ballPosition = new THREE.Vector3(
        (Math.random() - 0.5) * 0.5,  // ±0.25 in X
        0,
        (Math.random() - 0.5) * 0.5   // ±0.25 in Z
    );
    const ball = new Ball(scene, ballPosition, 10);
    slinky.updateAxis(ball.position());

    // --- Mouse click & drag ---
    let dragging = false;
    let mouseY = 0;
    canvas.addEventListener('mousedown', e => {
        const rect = canvas.getBoundingClientRect();
        mouseY = ((e.clientY - rect.top) / rect.height) * 2 - 1; // niet exact nodig voor nu
        dragging = true;
    });
    canvas.addEventListener('mouseup', e => dragging = false);
    canvas.addEventListener('mousemove', e => {
        if(dragging){
            const rect = canvas.getBoundingClientRect();
            const x = ((e.clientX - rect.left)/rect.width - 0.5) * 20; // scale to scene
            const y = 10 - ((e.clientY - rect.top) / rect.height) * 20;
            ball.shiftTo(new THREE.Vector3(x, y, 0));
        }
    });

    const graphCanvas = document.getElementById("graphCanvas");
    const graphContext = graphCanvas.getContext("2d");

    const maxPoints = 300;
    const KE = [], PE = [], E  = [], Y = []; // kinetic, potential, and total energy, and position

    function drawGraph() {
        graphContext.clearRect(0,0,graphCanvas.width,graphCanvas.height);

        const scaleY = 0.1;  // pas aan
        const offsetY = graphCanvas.height * 0.9;

        function drawLine(data, color) {
            graphContext.beginPath();
            graphContext.strokeStyle = color;
            data.forEach((v,i)=>{
                const x = i * graphCanvas.width / maxPoints;
                const y = offsetY - v * scaleY;
                if(i===0) graphContext.moveTo(x,y);
                else graphContext.lineTo(x,y);
            });
            graphContext.stroke();
        }

        drawLine(KE, "red");      // kinetisch
        drawLine(PE, "lime");     // potentieel
        drawLine(E,  "cyan");    // totaal
        drawLine(Y, "yellow");     // position
    }

    function force(kHorizontal = 100) { // horizontal spring constant
        const forceX = -kHorizontal * ball.position().x;
        const forceY = slinky.force() - ball.mass * g;
        const forceZ = -kHorizontal * ball.position().z;
        return new THREE.Vector3(forceX, forceY, forceZ);
    }

    function updateGraphData() {
        const springExtension = slinky.displacement();
        const potentialSpring = 0.5 * slinky.k * springExtension * springExtension;
        const potentialGravity = ball.mass * g * ball.position().y;
        KE.push(ball.kineticEnergy());
        PE.push(potentialSpring + potentialGravity);
        E.push(ball.kineticEnergy() + potentialSpring + potentialGravity);
        Y.push((5 + ball.position().y) * 100); // scale
    }

    function shiftGraph() {
        if (Y.length > maxPoints) Y.shift();
        if (KE.length > maxPoints) {
            KE.shift();
            PE.shift();
            E.shift();
        }
    }

    const dt = 0.02;
    let time = 0;
    function animate(){
        requestAnimationFrame(animate);
        time += dt;
        if (!dragging) ball.updateWith(force(), dt);
        slinky.updateAxis(ball.position().sub(suspensionPoint.clone()));
        slinky.update(time); // Time parameter needed when longitudinal oscillation = true
        renderer.render(scene, camera);
        updateGraphData();
        shiftGraph();
        drawGraph();
    }

    animate();

    // --- interactive: spring hardening / softening ---
    window.addEventListener('keydown', e => {
        if(e.key==='ArrowUp') slinky.k +=20;
        if(e.key==='ArrowDown') slinky.k -=20;
        slinky.k = Math.max(20, slinky.k);
        console.log("k =", slinky.k);
    });
</script>

