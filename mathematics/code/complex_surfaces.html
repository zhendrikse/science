<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<div class="equationDiv" id="surface-equation"></div>
<div class="canvasWrapper" id="complexPlotContainer">
    <canvas class="applicationCanvas" id="complexPlotCanvas"></canvas><br/>
</div>
<div id="gui-container"></div>

<script type="module">
    import { Scene, Color, Group } from "three";
    import { AxesController, Interval, ThreeJsUtils, Plot3DView, AxesParameters, MathWrapper, ComplexNumber }
        from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";
    import { ComplexSurfaceDefinition, ComplexSurfaceSpecification, ComplexSurfaceView, ComplexSurface }
        from 'https://www.hendrikse.name/science/js/3d-surface-components.js';

    const canvasContainer = document.getElementById("complexPlotContainer");
    const canvas = document.getElementById("complexPlotCanvas");

    const scene = new Scene();
    scene.background = new Color(0x131313);
    const worldGroup = new Group();
    scene.add(worldGroup);

    const math = new MathWrapper();
    const zSquaredPlusTwo = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.add(math.multiply(z, z), math.complex(2, 0)),
        new Interval(-2, 2),
        new Interval(-2, 2),
        "$$\\psi(z) = \\big(z^2 + 2\\big)$$",
        "z * z + 2"
    ));
    const zAbsSquared = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.multiply(z, new ComplexNumber(z.re, -z.im)),
        new Interval(-2, 2),
        new Interval(-2, 2),
        "$$\\psi(z) = z\\bar{z}$$",
        "z * z_bar"
    ));
    const zCubed = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.add(math.multiply(z, math.multiply(z, z)), new ComplexNumber(2, 0)),
        new Interval(-2, 2),
        new Interval(-2, 2),
        "$$\\psi(z) = \\big(z^3 + 2\\big)$$",
        "z * z * z + 2"
    ));
    const sqrtZ = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.sqrt(math.add(z, math.complex(0.0001, 0.0001))),
        new Interval(-1, 1),
        new Interval(-1, 1),
        "$$\\psi(z) = \\sqrt(z)$$",
        "sqrt(z)"
    ));
    const expZ = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.exp(math.multiply(z, z)),
        new Interval(-1, 1),
        new Interval(-1, 1),
        "$$\\psi(z) = \\exp(z * z)$$",
        "exp(z * z)"
    ));
    const logZ = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.log(math.add(z, math.complex(0.0001, 0.0001))),
        new Interval(-Math.PI, Math.PI),
        new Interval(-Math.PI, Math.PI),
        "$$\\psi(z) = \\log(z)$$",
        "log(z)"
    ));
    const sinZ = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.sin(z),
        new Interval(-Math.PI, Math.PI),
        new Interval(-Math.PI, Math.PI),
        "$$\\psi(z) = \\sin(z)$$",
        "sin(z)"
    ));
    const zPlusOneOverZMinusOne = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.divide(math.add(math.complex(1, 0), z), math.add(math.complex(-1, 0), z)),
        new Interval(-4, 4),
        new Interval(-4, 4),
        "$$\\psi(z) = \\bigg(\\dfrac{z + 1}{z - 1} \\bigg)$$",
        "(z + 1) / (z - 1)"
    ));
    const zPlusOneOverZ = new ComplexSurfaceDefinition(new ComplexSurfaceSpecification(
        (z) => math.add(z, math.divide(math.complex(1, 0), math.add(z, math.complex(0.01, 0)))),
        new Interval(-3, 3),
        new Interval(-3, 3),
        "$$\\psi(z) = z + \\bigg(\\dfrac{1}{z}\\bigg)$$",
        "z + 1 / z"
    ));
    const ComplexFunctions = Object.freeze({
        ZSquaredPlusTwo: zSquaredPlusTwo.specification.textString,
        ZAbsSquared: zAbsSquared.specification.textString,
        ZCubed: zCubed.specification.textString,
        SinZ: sinZ.specification.textString,
        logZ: logZ.specification.textString,
        expZ: expZ.specification.textString,
        sqrtZ: sqrtZ.specification.textString,
        ZPlusOneOverZMinusOne: zPlusOneOverZMinusOne.specification.textString,
        ZPlusOneOverZ: zPlusOneOverZ.specification.textString
    });

    class ControlsGui {
        constructor() {
            const gui = new GUI({width: "100%", autoPlace: false});
            gui.add(params, 'function', Object.values(ComplexFunctions))
                .name("F(z) = ")
                .onChange(value => {
                    switch (value) {
                        case zSquaredPlusTwo.specification.textString:
                            this.#updateSurface(zSquaredPlusTwo);
                            break;
                        case zAbsSquared.specification.textString:
                            this.#updateSurface(zAbsSquared);
                            break;
                        case zCubed.specification.textString:
                            this.#updateSurface(zCubed);
                            break;
                        case expZ.specification.textString:
                            this.#updateSurface(expZ);
                            break;
                        case logZ.specification.textString:
                            this.#updateSurface(logZ);
                            break;
                        case sqrtZ.specification.textString:
                            this.#updateSurface(sqrtZ);
                            break;
                        case sinZ.specification.textString:
                            this.#updateSurface(sinZ);
                            break;
                        case zPlusOneOverZMinusOne.specification.textString:
                            this.#updateSurface(zPlusOneOverZMinusOne);
                            break;
                        case zPlusOneOverZ.specification.textString:
                            this.#updateSurface(zPlusOneOverZ);
                            break;
                    }
                });

            this.#createAxesFolder(gui);
            this.#updateSurface(zCubed);
            document.getElementById("gui-container").appendChild(gui.domElement);
        }

        #createAxesFolder(parentFolder) {
            const axesFolder = parentFolder.addFolder("Axes");
            const dummyToggle = {gridPlanes: true};
            axesFolder.add(params.axesParameters, 'frame')
                .name("Frame").onChange(value => axesController.updateSettings());
            axesFolder.add(dummyToggle, 'gridPlanes')
                .name("Layout").onChange(value => {
                params.axesParameters.xyPlane = value;
                params.axesParameters.xzPlane = value;
                params.axesParameters.yzPlane = value;
                axesController.updateSettings();
            });
            axesFolder.add(params.axesParameters, 'annotations')
                .name("Annotations").onChange(value => axesController.updateSettings());
            axesFolder.close();
        }

        #updateSurface(definition) {
            surface.dispose();
            surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(definition));
            axesController.createFromBoundingBox(surface.boundingBox());
            plot3D.frame(surface.boundingBox());
        }
    }

    class SurfaceController {
        constructor({
                        parentGroup,
                        surfaceFactory   // (definition) => ComplexSurfaceView
                    }) {
            this._parentGroup = parentGroup;
            this._surfaceFactory = surfaceFactory;
            this._surface = null;
        }

        create(definition, options = {}) {
            this.dispose();

            this._surface = this._surfaceFactory(definition, options);
            this._parentGroup.add(this._surface);

            return this._surface;
        }

        get boundingBox() {
            return this._surface ? this._surface.boundingBox() : null;
        }

        get surface() {
            return this._surface;
        }

        dispose() {
            if (!this._surface) return;

            this._surface.dispose();
            this._parentGroup.remove(this._surface);
            this._surface = null;
        }
    }  // TODO
    // const surfaceController = new SurfaceController({
    //     parentGroup: worldGroup,
    //     surfaceFactory: (definition, options) =>
    //         new ComplexSurfaceView(worldGroup, new ComplexSurface(definition), options)
    // });
    // surfaceController.create(zCubed, { showWireframe: false });
    // surfaceController.create(definition, { showWireframe: false });
    //
    // axesController.createFromBoundingBox(
    //     surfaceController.boundingBox
    // );
    //
    // plot3D.frame(
    //     surfaceController.boundingBox
    // );
    // !! Niet in de controller stoppen ‚Äî dat is UI, geen scene-state.
    // const equationDiv = document.getElementById("surface-equation");
    // equationDiv.innerHTML = definition.specification.latexString;
    // if (window.MathJax) {
    //     MathJax.typesetPromise([equationDiv]);
    // }



    const params = {
        axesParameters: new AxesParameters({axisLabels: ["Re(z)", "log|z|", "Im(z)"]}),
        function: ComplexFunctions.ZCubed
    };

    const axesController = new AxesController({
        parentGroup: worldGroup,
        canvasContainer: canvasContainer,
        axesParameters: params.axesParameters,
        scene: scene
    });

    let surface = new ComplexSurfaceView(worldGroup, new ComplexSurface(zCubed), {showWireframe: false});

    const boundingBox = surface.boundingBox();
    axesController.createFromBoundingBox(boundingBox);

    const plot3D = new Plot3DView(scene, canvas, boundingBox);
    plot3D.frame(ThreeJsUtils.scaleBox3(boundingBox, .9));
    const gui = new ControlsGui();

    // Resizing for mobile devices
    function resize() {
        ThreeJsUtils.resizeRendererToCanvas(plot3D.renderer, plot3D.camera);
        axesController.resize();
    }
    window.addEventListener("resize", resize);
    resize();

    function animate() {
        requestAnimationFrame(animate);
        plot3D.render();
        axesController.render(plot3D.camera);
    }
    animate();
</script>

<!--
   -
   - POLEN AUTOMATISCH DETECTEREN
   -

Suggestie is van **simpel ‚Üí degelijk ‚Üí echt wiskundig correct**,
met concrete implementatie-idee√´n die passen bij deze code.

---

# 1Ô∏è‚É£ Praktisch & robuust: detecteer ‚Äúnumerieke explosie‚Äù

Dit is in de praktijk de **meest gebruikte methode** in visualisaties.

### Idee

Een pool herken je aan:

* |f(z)| wordt *extreem groot*
* of `NaN / Infinity`

### Implementatie (past 1-op-1 in `sample()`)

```js
const value = this._specification.func(z);

if (!Number.isFinite(value.re) ||
    !Number.isFinite(value.im)) {
    return { isPole: true };
}

const r = value.abs();
if (!Number.isFinite(r) || r > POLE_THRESHOLD) {
    return { isPole: true };
}
```

Of minimalistischer:

```js
const r = value.abs();
const isPole = !Number.isFinite(r) || r > 1e6;
```

### Wat je ermee doet

* geen vertex maken
* of hoogte afkappen
* of kleur satureren
* of gat maken

### ‚úîÔ∏è Voordelen

‚úîÔ∏è Simpel
‚úîÔ∏è Werkt voor *alle* functies
‚úîÔ∏è Geen kennis van formule nodig

### ‚ùå Nadelen

‚ùå Heuristisch
‚ùå Afhankelijk van schaal

‚û°Ô∏è **Voor jouw use-case: absoluut geschikt.**

---

# 2Ô∏è‚É£ Geometrisch: detecteer ‚Äúte grote gradi√´nt‚Äù

Polen zijn plekken waar de functie **heel snel verandert**.

### Idee

Vergelijk waarde met naburige samples:

```text
|f(z + Œ¥) - f(z)| >> |Œ¥|
```

### Implementatie (discreet)

Bijvoorbeeld in je grid:

```js
const r = value.abs();
const rRight = rightValue.abs();
const rUp    = upValue.abs();

const gradient =
    Math.max(
        Math.abs(r - rRight),
        Math.abs(r - rUp)
    );

const isPole = gradient > GRAD_THRESHOLD;
```

### ‚úîÔ∏è Voordelen

‚úîÔ∏è Schaallonafhankelijker
‚úîÔ∏è Detecteert ook ‚Äúbijna-polen‚Äù
‚úîÔ∏è Werkt goed voor `log`, `1/z`, `tan(z)`

### ‚ùå Nadelen

‚ùå Iets duurder
‚ùå Vereist naburige samples

üëâ Ideaal als **secundaire check**.

---

# 3Ô∏è‚É£ Wiskundig correct: analytische pooldetectie

Als je de functie **kent**, kun je het exact doen.

### Voorbeelden

#### `1 / f(z)`

Pool waar `f(z) = 0`

```js
if (Math.abs(denominator.abs()) < EPS) pole = true;
```

#### `log(f(z))`

Pool waar `f(z) = 0`

#### `tan(z)`

Polen waar `cos(z) = 0`

### Structuur die dit ondersteunt

```js
class ComplexSurfaceSpecification {
    constructor(func, reInterval, imInterval, poleTest=null) {
        this.func = func;
        this.poleTest = poleTest;
    }

    isPole(z) {
        return this.poleTest?.(z) ?? false;
    }
}
```

Gebruik:

```js
const spec = new ComplexSurfaceSpecification(
    z => math.log(z),
    reInterval,
    imInterval,
    z => z.abs() < 1e-3
);
```

### ‚úîÔ∏è Voordelen

‚úîÔ∏è Exact
‚úîÔ∏è Geen heuristiek
‚úîÔ∏è Wiskundig zuiver

### ‚ùå Nadelen

‚ùå Niet generiek
‚ùå Meer werk per functie

---

# 4Ô∏è‚É£ Topologisch correct: winding number / monodromie (geavanceerd)

Dit is *next level*, maar wel prachtig.

### Idee

Neem een klein kringetje rond een punt en kijk of:

```text
arg(f(z)) maakt een volledige winding
```

Dat betekent: **er zit een pool of nul binnen**.

### Discrete aanpak

```js
let winding = 0;
for (let k = 0; k < N; k++) {
    winding += phase[k+1] - phase[k];
}
const isPole = Math.abs(winding) > Math.PI;
```

üìå Dit gebruik je zelden realtime, maar:

* geweldig voor analyse
* geweldig voor automatische detectie

---

# üß© Hoe ik dit in jouw code zou integreren

### Stap 1 ‚Äî Breid `sample()` uit

```js
sample(u, v, target) {
    const z = ...
    const value = this.specification.func(z);
    const r = value.abs();

    const isPole =
        !Number.isFinite(r) ||
        r > this.specification.poleThreshold;

    return { value, isPole };
}
```

### Stap 2 ‚Äî Geometrie beslist

```js
if (sample.isPole) {
    target.set(NaN, NaN, NaN);
} else {
    target.set(re, heightMapper(r), im);
}
```

### Stap 3 ‚Äî Optioneel visueel accent

* rood
* transparant
* gat
* spike

---

# üèÅ Mijn concrete aanbeveling voor jou

Voor **jouw huidige project**:

ü•á **Numerieke explosie + log-height**

```js
const r = value.abs();
const isPole = !Number.isFinite(r) || r > 1e4;
const y = Math.log1p(Math.min(r, 1e4));
```

ü•à Optioneel: gradi√´ntcheck

ü•â Optioneel: analytische `poleTest` per functie

---

Als je wilt, kan ik:

* een `PoleDetector` class maken
* poolgebieden als heatmap tonen
* automatisch gaten *smooth* laten aflopen
* of poles in de GUI zichtbaar maken

Maar inhoudelijk:
üëâ **zo detecteer je polen robuust √©n verantwoord.**

-->