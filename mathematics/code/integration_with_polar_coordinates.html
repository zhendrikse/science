<div id="container" style="position: relative; width: 600px; height: 600px; border: none; display: inline-block;">
    <canvas id="myCanvas" width="600" height="600"></canvas>
</div>

<div id="ui" class="ui">
    <br/><div class="row" id="integral">Integral evaluates to: 0.00</div><br/>
    <div class="row">
        <label>θ_min <input id="thetaMin" type="range" min="0" max="3.1416" step="0.01" value="0"></label>
        <label><input id="thetaMax" type="range" min="0" max="3.1416" step="0.01" value="3.1416">&nbsp;θ_max</label>
    </div>
    <div class="row">
        <label>φ_min <input id="phiMin" type="range" min="0" max="6.2832" step="0.01" value="0"></label>
        <label><input id="phiMax" type="range" min="0" max="6.2832" step="0.01" value="6.2832">&nbsp;φ_max</label>
    </div>
    <br/><label>Opacity <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.35"></label><br/><br/>
    <label>Mesh <input type="checkbox" id="meshChk" checked></label>
    <label>Tick labels <input type="checkbox" id="tickChk" checked></label>
    <label>Axis labels <input type="checkbox" id="axisLabelCheck" checked></label>
</div>


<script type="module">
    import * as THREE from "https://cdn.skypack.dev/three@0.136.0";
    import { OrbitControls } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls";
    import { CSS2DRenderer, CSS2DObject } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/renderers/CSS2DRenderer";

    const container = document.getElementById("container");
    const canvas = document.getElementById("myCanvas");

    const width = canvas.width;
    const height = canvas.height;

    // --- SCENE ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x101010);

    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
    camera.position.set(4, 4, 4);

    // WebGL renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
    renderer.setSize(width, height);

    // CSS2DRenderer overlay
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(width, height);
    labelRenderer.domElement.style.position = "absolute";
    labelRenderer.domElement.style.top = "0";
    labelRenderer.domElement.style.left = "0";
    labelRenderer.domElement.style.pointerEvents = "none";
    container.appendChild(labelRenderer.domElement);

    const controls = new OrbitControls(camera, canvas);

    scene.add(new THREE.DirectionalLight(0xffffff, 1.2).position.set(10,10,10));
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));

    function createPlane(size, color) {
        return new THREE.Mesh(
            new THREE.PlaneGeometry(size, size),
            new THREE.MeshPhongMaterial({ color, transparent:true, opacity:0.1, side:THREE.DoubleSide })
        );
    }

    function xyPlane(size, divisions) {
        const grid = new THREE.GridHelper(size, divisions, 0x666666, 0x333333);
        const plane = createPlane(size, 0x4444ff);
        plane.rotateX(Math.PI/2);
        plane.position.set(1,0,1);
        grid.position.set(1,0,1);
        return [plane, grid];
    }
    function yzPlane(size, divisions) {
        const grid = new THREE.GridHelper(size, divisions, 0x666666, 0x333333);
        grid.rotateZ(Math.PI/2);
        const plane = createPlane(size, 0x44ff44);
        plane.rotateY(Math.PI/2);
        plane.position.set(0,1,1);
        grid.position.set(0,1,1);
        return [plane,grid];
    }
    function xzPlane(size, divisions) {
        const grid = new THREE.GridHelper(size, divisions, 0x666666, 0x333333);
        grid.rotateX(Math.PI/2);
        const plane = createPlane(size, 0xff4444);
        plane.rotateZ(Math.PI/2);
        plane.position.set(1,1,0);
        grid.position.set(1,1,0);
        return [plane,grid];
    }

    const gridSize = 2, gridDivisions = 10;
    const allGrids = [].concat(
        xyPlane(gridSize, gridDivisions),
        yzPlane(gridSize, gridDivisions),
        xzPlane(gridSize, gridDivisions)
    );
    allGrids.forEach(obj => scene.add(obj));

    function makeLabel(text, pos, color="yellow") {
        const div = document.createElement("div");
        div.style.color = color;
        div.style.fontSize = "15px";
        div.textContent = text;
        const label = new CSS2DObject(div);
        label.position.copy(pos);
        scene.add(label);
        return label;
    }

    function createTickLabels(size, divs) {
        const labels = [];
        const step = (2*size)/divs;
        const off = 0.1;

        for (let v = 0; v <= 2; v += step) {
            labels.push(makeLabel(v.toFixed(1), new THREE.Vector3(v,0,size+off)));
            labels.push(makeLabel(v.toFixed(1), new THREE.Vector3(0,v,size+off)));
            labels.push(makeLabel(v.toFixed(1), new THREE.Vector3(size+off,0,v)));
        }
        return labels;
    }
    const tickLabels = createTickLabels(gridSize, gridDivisions);

    function axisLabels(size) {
        const off = 0.3;
        return [
            makeLabel("X-axis", new THREE.Vector3(size+off,0,1),"white"),
            makeLabel("Y-axis", new THREE.Vector3(0,size+off,1),"white"),
            makeLabel("Z-axis", new THREE.Vector3(0,0,size+off),"white"),
        ];
    }
    const axisLabelsArr = axisLabels(gridSize);

    function toCartesian(R, t, p) {
        return new THREE.Vector3(
            1 + R*Math.sin(t)*Math.cos(p),
            1 + R*Math.sin(t)*Math.sin(p),
            1 + R*Math.cos(t)
        );
    }

    const R = 1, da = 0.05;
    function f(t,p){ return t*t*(p-Math.PI)*(p-Math.PI); }

    const cells = [];
    let values = [];

    for (let t=0; t<=Math.PI; t+=da)
        for (let p=0; p<=2*Math.PI; p+=da) {
            const val = f(t,p);
            values.push(val);

            const m = new THREE.Mesh(
                new THREE.BoxGeometry(da, da, da),
                new THREE.MeshPhongMaterial({ transparent:true, opacity:0.35 })
            );
            m.position.copy(toCartesian(R,t,p));
            m.userData = {theta:t, phi:p, val};
            scene.add(m);
            cells.push(m);
        }

    const minF = Math.min(...values), maxF = Math.max(...values);
    cells.forEach(c => {
        const t = (c.userData.val - minF) / (maxF - minF);
        c.material.color.setRGB(t,0,1-t);
    });

    // UI
    const θmin = document.getElementById("thetaMin");
    const θmax = document.getElementById("thetaMax");
    const φmin = document.getElementById("phiMin");
    const φmax = document.getElementById("phiMax");
    const opacity = document.getElementById("opacity");
    const meshChk = document.getElementById("meshChk");
    const tickChk = document.getElementById("tickChk");
    const axisChk = document.getElementById("axisLabelCheck");

    function updateVisibility() {
        const t0 = parseFloat(θmin.value),
            t1 = parseFloat(θmax.value),
            p0 = parseFloat(φmin.value),
            p1 = parseFloat(φmax.value);

        cells.forEach(c => {
            const t = c.userData.theta, p = c.userData.phi;
            c.visible = (t>=t0 && t<=t1 && p>=p0 && p<=p1);
        });
    }

    function integrate() {
        let sum = 0;
        cells.forEach(c => { if (c.visible) sum += c.userData.val * Math.sin(c.userData.theta); });
        return sum * R*R * da * da;
    }

    function updateIntegral() {
        document.getElementById("integral").textContent =
            "Integral evaluates to: " + integrate().toFixed(2);
    }

    // UI listeners
    [θmin,θmax,φmin,φmax].forEach(el =>
        el.addEventListener("input", () => { updateVisibility(); updateIntegral(); })
    );
    opacity.addEventListener("input", () => {
        cells.forEach(c => c.material.opacity = parseFloat(opacity.value));
    });
    meshChk.addEventListener("input", () => {
        allGrids.forEach(g => g.visible = meshChk.checked);
    });
    tickChk.addEventListener("input", () => {
        tickLabels.forEach(l => l.visible = tickChk.checked);
    });
    axisChk.addEventListener("input", () => {
        axisLabelsArr.forEach(l => l.visible = axisChk.checked);
    });

    // Init
    updateVisibility();
    updateIntegral();

    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene,camera);
        labelRenderer.render(scene,camera);
    }
    animate();

</script>

