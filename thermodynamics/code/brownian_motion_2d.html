<!--
  -- https://physics.bu.edu/~duffy/HTML5/brownian_motion.html
  -->
<link rel="stylesheet" href="https://unpkg.com/uplot/dist/uPlot.min.css">
<script src="https://unpkg.com/uplot/dist/uPlot.iife.min.js"></script>

<canvas class="applicationCanvas2D" id="brownianCanvas" width="500" height="500"></canvas>
<div class="buttonRow">
    <button id="play">Play</button>
    <button id="pause">Pause</button>
    <button id="reset">Reset</button>
</div>
<p style="clear: both;"></p>
<div class="buttonRow">Molecules:&nbsp;
    <button id="show">Show</button>
    <button id="hide">Hide</button>
    <button id="add">Add</button>
</div>
<p style="clear: both;"></p>
<div id="tempSlider">
    <label for="tempValue">
        Cold <input type="range" id="tempValue" min="0.01"
                                 max="1.0" value=".5" step="0.01" oninput="showTempValue(this.value)" onchange="showTempValue(this.value)"> Hot
    </label>
</div>
<div id="speedPlot" style="width:600px; height:300px;"></div>

<script>
    const brownianCanvas = document.getElementById("brownianCanvas");
    const context = brownianCanvas.getContext("2d");

    const simTitle = 'Brownian motion';
    const ballRadius = 5;
    const nBalls = 301;
    const boxHeight = 400;
    const boxWidth = 400;
    const centerX = brownianCanvas.clientWidth  * .5;
    const centerY = 250;
    const nPath = 500000;
    const dust = new Array(nPath);
    
    let index = -1;
    let runFlag = true;
    let time = 0;
    let numBalls = 200;
    let showMolecules = true;

    const playButton = document.getElementById("play");
    playButton.addEventListener("click", () => play());
    const pauseButton = document.getElementById("pause");
    pauseButton.addEventListener("click", () => pause());
    const resetButton = document.getElementById("reset");
    resetButton.addEventListener("click", () => reset());
    const showButton = document.getElementById("show");
    showButton.addEventListener("click", () => showMolecules = true);
    const hideButton = document.getElementById("hide");
    hideButton.addEventListener("click", () => showMolecules = false);
    const addButton = document.getElementById("add");
    addButton.addEventListener("click", () => addBalls());

    const showTempValue = (newTempValue) => speedFactor = Math.sqrt(Number(newTempValue));

    function play() {
        window.clearTimeout(timer);
        runFlag = true;
        animate();
    }

    function pause() {
        window.clearTimeout(timer);
        runFlag = false;
    }

    function addBalls() {
        numBalls = 250;
        for (let i = 200; i < 250; i++) {
            ball[i].x = (centerX + 0.48 * boxWidth - ballRadius);
            ball[i].y = (centerY + 0.48 * boxWidth - ballRadius);
        }
    }

    function reset() {
        window.clearTimeout(timer);
        index = -1;
        numBalls = 200;
        for (let i = 0; i < numBalls; i++)
            ball[i].reset();
        ball[0].velX = -1.0 + 2.0 * Math.random();
        ball[0].velY = -1.0 + 2.0 * Math.random();

        pushIndex = -1;
        runFlag = true;
    }

    class Ball {
        constructor(x, y, radius, color) {
            this.x = x;
            this.y = y;
            this.velX = -1.0 + 2.0 * Math.random();
            this.velY = -1.0 + 2.0 * Math.random();
            this.radius = radius;
            this.color = color;
        }

        distanceSquaredTo(otherBall) {
            const distX = otherBall.x - this.x;
            const distY = otherBall.y - this.y;
            return distX * distX + distY * distY;
        }

        distanceTo = (otherBall) => Math.sqrt(this.distanceSquaredTo(otherBall));

        limitTo(left, right, top, bottom) {
            if (this.x > right)  this.velX = -Math.abs(this.velX);
            if (this.x < left)   this.velX =  Math.abs(this.velX);
            if (this.y > top)    this.velY = -Math.abs(this.velY);
            if (this.y < bottom) this.velY =  Math.abs(this.velY);
        }

        collideWith(otherBall) {
            // relative velocities
            const dvx = otherBall.velX - this.velX;
            const dvy = otherBall.velY - this.velY;
            const dx = otherBall.x - this.x;
            const dy = otherBall.y - this.y;

            if (dvx * dx + dvy * dy >= 0) return;

            const vxi = this.velX;
            const vyi = this.velY;
            const vxj = otherBall.velX;
            const vyj = otherBall.velY;
            const distance = this.distanceTo(otherBall);
            const cosTheta = dy / distance;
            const sinTheta = dx / distance;
            this.velX = vxi + sinTheta * ( -vxi * sinTheta + vxj * sinTheta - vyi * cosTheta + vyj * cosTheta);
            this.velY = vyi + cosTheta * ( -vyi * cosTheta + vyj * cosTheta - vxi * sinTheta + vxj * sinTheta);
            otherBall.velX = vxj + vxi - this.velX;
            otherBall.velY = vyj + vyi - this.velY;
        }

        reset(x=centerX, y=centerY) {
            this.x = x;
            this.y = y;
        }

        draw(visible) {
            if (!visible) return;

            context.fillStyle = this.color;
            context.strokeStyle = this.color;
            context.beginPath();
            context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);
            context.fill();
        }

        move() {
            this.x += speedFactor * this.velX;
            this.y += speedFactor * this.velY;
            const left = centerX - 0.5 * boxWidth +  this.radius;
            const right = centerX + 0.5 * boxWidth -  this.radius
            const top = centerY + 0.5 * boxHeight - this.radius;
            const bottom = centerY - 0.5 * boxHeight + this.radius;
            this.limitTo(left, right, top, bottom);
        }

        isCollidingWith(otherBall) {
            const r = this.radius + otherBall.radius;
            return this.distanceSquaredTo(otherBall) < r * r;
        }

        speed = () => Math.sqrt(this.velX * this.velX + this.velY * this.velY);
    }

    let timer;
    let ball = new Array(nBalls + 1);
    for (let i = 0; i <= nBalls; i++)
        ball[i] = new Ball(centerX, centerY, ballRadius, "yellow");

    ball[0].color = "red";
    ball[0].radius = 20;
    for (let i = 200; i < 250; i++)
        ball[i].color = "cyan";
    
    let speedFactor = 1;
    let pushIndex = -1;
    
    for (let i = 0; i < nPath; i++)
        dust[i] = {
            x: centerX,
            y: centerY
        };

    function drawDustTrail() {
        if (pushIndex <= -1) return;

        dust[pushIndex].x = ball[0].x;
        dust[pushIndex].y = ball[0].y;
        context.beginPath();
        context.strokeStyle = "purple";
        context.moveTo(dust[0].x,dust[0].y);
        for (let i = 1; i <= pushIndex; i++)
            context.lineTo(dust[i].x,dust[i].y);
        context.stroke();
        pushIndex = pushIndex + 1;
    }

    function redrawCanvas() {
        context.clearRect(0, 0, brownianCanvas.clientWidth, brownianCanvas.clientHeight);

        // set background color for the entire thing
        context.fillStyle = "#232323";
        context.fillRect(0, 0, brownianCanvas.clientWidth, brownianCanvas.clientHeight);

        // set background color for the box of gas
        context.fillStyle = "#131313";
        context.fillRect(centerX - 0.5 * boxWidth, centerY - 0.5 * boxHeight, boxWidth, boxHeight);
        
        // graph title
        context.font = 'bold 18pt Calibri';
        context.fillStyle = 'green';
        context.textAlign = 'center';
        context.fillText(simTitle, (brownianCanvas.clientWidth) * .5, 30);
    }

    function updateGraph() {
        if (index % 5 !== 0)
            return;

        const { bins, meanV2 } = computeSpeedDistribution();
        const averaged = getAveragedHistogram(bins);
        const theory = computeTheoreticalCurve(meanV2, numBalls - 1);
        speedPlot.setData([binsX, averaged, theory]);
    }

    function redraw() {
        redrawCanvas();

        for (let i = 0; i < numBalls - 1; i++)
            ball[i].draw(showMolecules);
        ball[0].draw(true); // Make sure the big ball is always shown

        drawDustTrail();
        updateGraph();
    }

    function drawMotion() {
        if (time >= 50) runFlag = false;
        if (!runFlag) return;

        index++;
        if (index > 400 && pushIndex === -1) pushIndex = 0; // delay before start drawing trail

        for (let i = 0; i < numBalls - 1; i++)
            ball[i].move();

        for (let i = 0; i < numBalls - 1; i++)
            for (let j = i + 1; j < numBalls; j++)
                if (ball[i].isCollidingWith(ball[j]))
                    ball[i].collideWith(ball[j]);

        redraw();
    }

    const binCount = 30;
    const maxSpeed = 5;
    const averagingFrames = 100;
    let histogramBuffer = [];
    const binsX = Array.from({length: binCount}, (_, i) => i);
    function computeSpeedDistribution() {
        const bins = new Array(binCount).fill(0);
        const binSize = maxSpeed / binCount;

        let sumV2 = 0;
        for (let i = 1; i < numBalls; i++) {
            const v = ball[i].speed();
            sumV2 += v * v;
            const index = Math.min(Math.floor(v / binSize), binCount - 1);
            bins[index]++;
        }

        const meanV2 = sumV2 / (numBalls - 1);
        return { bins, meanV2 };
    }

    function getAveragedHistogram(newBins) {
        histogramBuffer.push(newBins);

        if (histogramBuffer.length > averagingFrames)
            histogramBuffer.shift();

        const average = new Array(binCount).fill(0);
        for (let frame of histogramBuffer)
            for (let i = 0; i < binCount; i++)
                average[i] += frame[i];

        for (let i = 0; i < binCount; i++)
            average[i] /= histogramBuffer.length;

        return average;
    }

    function computeTheoreticalCurve(meanV2, totalParticles) {
        const binSize = maxSpeed / binCount;
        const T = meanV2 / 2;   // effective temperature

        const theory = [];
        for (let i = 0; i < binCount; i++) {
            const v = (i + 0.5) * binSize;
            const value = (v / T) * Math.exp(-v * v / (2 * T));
            theory.push(value);
        }

        // normaliseren zodat oppervlak gelijk is aan histogram
        const sumTheory = theory.reduce((a, b) => a + b, 0);
        const scale = totalParticles / sumTheory;

        return theory.map(v => v * scale);
    }

    const speedPlot = new uPlot({
            title: "Speed Distribution (averaged)",
            width: 600,
            height: 300,
            scales: {
                x: { time: false },
                y: { auto: false, range: [0, 50] }
            },
            series: [
                {},
                {
                    label: "Simulation",
                    stroke: "cyan",
                    fill: "rgba(0,255,255,0.2)"
                },
                {
                    label: "Maxwell (2D)",
                    stroke: "orange",
                    width: 2
                }
            ]
        }, [binsX, new Array(binCount).fill(0), new Array(binCount).fill(0)],
        document.getElementById("speedPlot"));



    function animate() {
        if (!runFlag) return;
        for (let i = 0; i < 5; i++)
            drawMotion();
        requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
</script>
