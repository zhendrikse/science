<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.175.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.175.0/examples/jsm/"
      }
    }
</script>

<canvas id="dnaCanvas" width="600" height="600" style="border: none;"></canvas>
<script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    const vector = THREE.Vector3;
    const color = THREE.Color;

    const scene = new THREE.Scene();
    scene.background = new color(0x191919);

    const canvas = document.getElementById('dnaCanvas');
    canvas.focus();
    const canvasWidth = canvas.getAttribute('width');
    const canvasHeight = canvas.getAttribute('height');

    const camera = new THREE.PerspectiveCamera(75, canvasWidth/canvasHeight, 0.1, 1000);
    camera.position.z = 35;

    const renderer = new THREE.WebGLRenderer( {antialias: true, canvas: canvas} );
    renderer.setSize( canvasWidth, canvasHeight );
    renderer.shadowMap.enabled = true;

    const light1 = new THREE.DirectionalLight(0xffffff, 1);
    light1.position.set(12, 12, 12);
    light1.castShadow = true;
    scene.add(light1);
    const light2 = new THREE.DirectionalLight(0xffffff, 1);
    light2.position.set(-12, 12, -12);
    light2.castShadow = true;
    scene.add(light2);

    const controls = new OrbitControls(camera, canvas);
    controls.target.set(0, 0, 0);
    controls.update();

    function createTextLabel(text, position) {
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.font = '28px Arial';
        ctx.fillStyle = '#ffffff';
        ctx.textAlign = 'center';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2 + 10);

        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(4, 2, 1);
        sprite.position.copy(position.clone().add(new vector(0, 0.5, 2))); // above base and to the front

        return sprite;
    }

    class Dna {
        static bondGeometry = new THREE.CylinderGeometry(0.3, 0.3, 10, 32);

        constructor() {
            this.dna = new THREE.Object3D();
            let lastLeftPosition = null;
            let lastRightPosition = null;
            for (let i = 0; i <= 20; i++)
                [lastLeftPosition, lastRightPosition] = this.createNucleotidePair(i, lastLeftPosition, lastRightPosition);
            this.dna.position.y = -20;
            scene.add(this.dna);
        }

        createNucleotidePair(i, lastLeftPosition, lastRightPosition) {
            const cylinder = new THREE.Mesh(Dna.bondGeometry, Dna.bondMaterial);
            cylinder.rotation.z = 90 * Math.PI / 180;
            cylinder.position.x = 0;
            let {ballRight, ballLeft} = this.nucleotides(i);

            const bondBetweenBalls = this.createBondBetween(ballLeft.position, ballRight.position, new color(0x2e50ac));
            const row = this.addBondToDna(bondBetweenBalls, ballRight, ballLeft, i);

            const {
                currentLeftPosition,
                currentRightPosition
            } = this.createPhosphateBackboneBonds(row, ballLeft, ballRight, lastLeftPosition, lastRightPosition);

            return [currentLeftPosition, currentRightPosition];
        }

        addBondToDna(bondBetweenBalls, ballRight, ballLeft, rowIndex) {
            const row = new THREE.Object3D();
            row.add(bondBetweenBalls);
            row.add(ballRight);
            row.add(ballLeft);

            this.putInHelixSpiral(rowIndex, row);
            this.addBasePairLabels(rowIndex, ballLeft, ballRight, row);
            this.dna.add(row);

            return row;
        }

        addBasePairLabels(rowIndex, ballLeft, ballRight, row) {
            const labels = ["A-T", "G-C", "T-A", "C-G"];
            const labelText = labels[rowIndex % labels.length];
            const labelLeft = createTextLabel(labelText.charAt(0), ballLeft.position);
            const labelRight = createTextLabel(labelText.charAt(2), ballRight.position);
            row.add(labelLeft);
            row.add(labelRight);
        }

        putInHelixSpiral(rowIndex, row) {
            const radius = 5;
            const angle = rowIndex * 0.4;
            const height = rowIndex * 1.8;

            row.position.x = Math.sin(angle) * radius;
            row.position.z = Math.cos(angle) * radius;
            row.position.y = height;

            row.rotation.y = angle;
        }

        createPhosphateBackboneBonds(row, ballLeft, ballRight, lastLeftWorld, lastRightWorld) {
            row.updateMatrixWorld(true);
            const currentLeftWorld = new vector();
            const currentRightWorld = new vector();
            ballLeft.getWorldPosition(currentLeftWorld);
            ballRight.getWorldPosition(currentRightWorld);

            if (lastLeftWorld && lastRightWorld) {
                const leftBackbone = this.createBondBetween(lastLeftWorld, currentLeftWorld, new color(0xff00ff), 0.15);
                const rightBackbone = this.createBondBetween(lastRightWorld, currentRightWorld, new color(0x00ffff), 0.15);
                this.dna.add(leftBackbone);
                this.dna.add(rightBackbone);
            }
            return {currentLeftWorld, currentRightWorld};
        }

        createBall(position, colour, radius=1.2, metallic=false) {
            const colouredMaterial = new THREE.MeshPhysicalMaterial({
                color: colour,
                metalness: metallic ? 0.8 : 0.1,
                roughness: metallic ? 0.2 : 0.7,
                clearcoat: metallic ? 0.8 : 0.3,
                clearcoatRoughness: 0.2,
                envMapIntensity: 1.0,
                wireframe: false
            });
            const moleculeGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const mesh = new THREE.Mesh(moleculeGeometry, colouredMaterial);
            mesh.position.set(position.x, position.y, position.z);
            return mesh;
        }

        nucleotides(i) {
            let ballRight, ballLeft;
            if (i % 4 === 0) {
                ballLeft = this.createBall(new vector(-5, 0, 0), new color(0x0000ff));
                ballRight = this.createBall(new vector(6, 0, 0), new color(0xffff00));
            } else if (i % 4 === 1) {
                ballLeft = this.createBall(new vector(-5, 0, 0), new color(0xff0000));
                ballRight = this.createBall(new vector(6, 0, 0), new color(0x00ff00));
            } else if (i % 4 === 2) {
                ballLeft = this.createBall(new vector(-5, 0, 0), new color(0xffff00));
                ballRight = this.createBall(new vector(6, 0, 0), new color(0x0000ff));
            } else {
                ballLeft = this.createBall(new vector(-5, 0, 0), new color(0x00ff00));
                ballRight = this.createBall(new vector(6, 0, 0), new color(0xff0000));
            }
            return {ballRight, ballLeft};
        }

        createBondBetween(pointA, pointB, colour, radius=0.2) {
            const direction = new vector().subVectors(pointB, pointA);
            const length = direction.length();
            const midPoint = new vector().addVectors(pointA, pointB).multiplyScalar(0.5);
            const bondGeometry = new THREE.CylinderGeometry(radius, radius, length, 16);
            const bondMaterial = new THREE.MeshLambertMaterial({
                color: colour,
                emissive: colour,
                emissiveIntensity: 0.4
            });
            const bond = new THREE.Mesh(bondGeometry, bondMaterial);

            // Orient the bond to face between the points
            bond.position.copy(midPoint);
            bond.quaternion.setFromUnitVectors(
                new vector(0, 1, 0), // default cylinder orientation
                direction.clone().normalize()
            );

            return bond;
        }

        rotateY() {
            this.dna.rotation.y += 0.01;
        }
    }

    const dna = new Dna();
    function render() {
        requestAnimationFrame(render);
        dna.rotateY();
        renderer.render(scene, camera);
    }

    render();
</script>