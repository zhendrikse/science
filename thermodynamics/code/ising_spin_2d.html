<div id="isingSpingCanvasWrapper" class="canvasWrapper2D">
    <canvas id="2dIsingCanvas" class="applicationCanvas2D"></canvas>
</div>

<div style="margin-top: 10px; text-align:center;">
    <label for="tempSlider">
        Temperature = <output id="tempReadout" for="tempSlider">2.27</output>
    </label>

    <input id="tempSlider" type="range" min="0.01" max="9.99" step="0.01" value="2.27"/>
    <button id="pauseButton">Start</button>
</div>

<script type="module">
    const canvas = document.getElementById('2dIsingCanvas');
    const wrapper = document.getElementById("isingSpingCanvasWrapper");
    const size = wrapper.clientWidth;
    const squareWidth = 2;
    let stepsPerFrame = 10000;
    let running = false;                        // will be true when running
    const tempSlider  = document.getElementById('tempSlider');
    const tempReadout = document.getElementById('tempReadout');

    const updateTemperature =() => tempReadout.textContent = Number(tempSlider.value).toFixed(2);
    tempSlider.addEventListener("input", updateTemperature);
    updateTemperature(); // initial sync

    const display = canvas.getContext('2d');
    const startButton = document.getElementById("pauseButton");
    startButton.addEventListener("click", startStop);

    function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;

        canvas.width  = Math.floor(size * dpr);
        canvas.height = Math.floor(size * dpr);

        canvas.style.width  = size + "px";
        canvas.style.height = size + "px";
    }

    window.addEventListener("resize", () => {
        resizeCanvas();
    });

    // Create the 2D array of dipoles, initially random (1 for up, -1 for down):
    const s = new Array(size);
    for (let i = 0; i < size; i++) {
        s[i] = new Array(size);             // a 2D array is just an array of arrays
        for (let j = 0; j < size; j++) {
            if (Math.random() < 0.5) s[i][j] = 1; else s[i][j] = -1;
            drawSquareAt(i, j, colorAt(i, j));
        }
    }

    function iterate() {
        const T = Number(tempSlider.value);
        for (let step=0; step<stepsPerFrame; step++) {
            const i = Math.floor(Math.random()*size);         // choose a random site
            const j = Math.floor(Math.random()*size);
            const eDiff = deltaU(i, j);
            if ((eDiff <=0) || (Math.random() < Math.exp(-eDiff/T))) {  // Metropolis algorithm
                s[i][j] *= -1;
                drawSquareAt(i, j, colorAt(i, j));
            }
        }
    }

    // Given a lattice site, compute energy change from hypothetical flip;
    function deltaU(i, j) {
        let leftS, rightS, topS, bottomS;  // values of neighboring spins
        if (i === 0) leftS = s[size-1][j];   else leftS = s[i-1][j];
        if (i === size - 1) rightS = s[0][j];  else rightS = s[i+1][j];
        if (j === 0) topS = s[i][size-1];    else topS = s[i][j-1];
        if (j === size - 1) bottomS = s[i][0]; else bottomS = s[i][j+1];
        return 2.0 * s[i][j] * (leftS + rightS + topS + bottomS);
    }

    function colorAt(i, j) { return s[i][j] === 1 ? '#8000ff' : '#1a1a1a'; }

    function drawSquareAt(x, y, color, width=squareWidth) {
        display.fillStyle = color;
        display.fillRect(x * width, y * width, width, width);
    }

    function startStop() {
        running = !running;
        startButton.textContent = running ? " Pause " : "Resume";

        if (running) {
            lastTime = performance.now();
            requestAnimationFrame(animate);
        }
    }

    let lastTime = 0;
    const updatesPerSecond = 60;
    function animate(now) {
        if (!running) return;

        const dt = (now - lastTime) / 1000;   // seconds
        lastTime = now;

        const batches = dt * updatesPerSecond; // How many Monte Carlo batches this frame?

        for (let i = 0; i < batches; i++)
            iterate();

        requestAnimationFrame(animate);
    }

</script>
