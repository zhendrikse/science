<style>
    .canvas-wrapper {
        position: relative;
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        aspect-ratio: 1 / 1;
    }

    .game-of-life-canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
    }
    table {
        width: 100%;
        border: none;
        max-width: 800px;
        margin: 0 auto;
    }
    td {
        white-space: nowrap;
        border: none;
    }
</style>
<div class="canvas-wrapper" id="canvas-wrapper">
    <canvas class="game-of-life-canvas" id="gameOfLifeCanvas"></canvas>
</div>

<script type="module">
    import { Pixel, PixelImage, Colors } from 'https://www.hendrikse.name/science/js/pixel-image.js';

    const canvas = document.getElementById("gameOfLifeCanvas");
    const display = canvas.getContext("2d");

    window.addEventListener("resize", () => {
        resizeCanvas();
        initGameOfLife();
    });

    canvas.focus();

    function resizeCanvas() {
        const wrapper = document.getElementById("canvas-wrapper");
        const size = wrapper.clientWidth;
        const dpr = window.devicePixelRatio || 1;

        canvas.width  = Math.floor(size * dpr);
        canvas.height = Math.floor(size * dpr);

        canvas.style.width  = size + "px";
        canvas.style.height = size + "px";
    }

    class Game {
        constructor(cells) {
            this._cells = cells;
        }

        next_generation() {
            let new_cells = [];
            for (let row = 0; row < this.height(); row++)
                new_cells.push(this.next_row_generation(row));
            return new Game(new_cells);
        }

        next_row_generation(row) {
            let result = [];
            for (let i = 0; i < this.width(); i++)
                result.push(
                    this.cell_at(row, i)
                        .next_generation(this.neighbours_for(row, i))
                );
            return result;
        }

        neighbours_for(row, column) {
            let neighbours = [
                this.cell_at(row - 1, column - 1),
                this.cell_at(row - 1, column),
                this.cell_at(row - 1, column + 1),
                this.cell_at(row,     column - 1),
                this.cell_at(row,     column + 1),
                this.cell_at(row + 1, column - 1),
                this.cell_at(row + 1, column),
                this.cell_at(row + 1, column + 1),
            ];
            return without_nones(neighbours);
        }

        cell_at(row, column) {
            if (column < 0) return null;
            if (column >= this.width()) return null;
            if (row < 0) return null;
            if (row >= this.height()) return null;
            return this._cells[row][column];
        }

        width() {
            return this._cells[0].length;
        }

        height() {
            return this._cells.length;
        }
    }


    function without_nones(list_) {
        let filtered_list = [];
        for (let item of list_)
            if (item !== null)
                filtered_list.push(item);

        return filtered_list;
    }


    class Cell {
        constructor(alive) {
            this._alive = alive;
        }

        next_generation(neighbours) {
            if (this.is_alive())
                return this._next_generation_when_alive(neighbours);
            return this._next_generation_when_dead(neighbours);
        }

        _next_generation_when_dead(neighbours) {
            return living(neighbours).length === 3
                ? living_cell()
                : dead_cell();
        }

        _next_generation_when_alive(neighbours) {
            const n = living(neighbours).length;
            return (n === 2 || n === 3)
                ? living_cell()
                : dead_cell();
        }

        is_alive() {
            return this._alive;
        }
    }


    function living(neighbours) {
        let living_neighbours = [];
        for (let neighbour of neighbours)
            if (neighbour.is_alive())
                living_neighbours.push(neighbour);
        return living_neighbours;
    }

    function dead_cell() {
        return new Cell(false);
    }

    function living_cell() {
        return new Cell(true);
    }

    function place_pattern(cells, pattern, offsetX, offsetY) {
        for (let [dx, dy] of pattern) {
            const x = offsetX + dx;
            const y = offsetY + dy;
            if (x >= 0 && x < cells.length && y >= 0 && y < cells[0].length)
                cells[x][y] = living_cell();
        }
    }

    const GLIDER = [
        [1, 0],
        [2, 1],
        [0, 2],
        [1, 2],
        [2, 2],
    ];

    const LWSS = [ // Lightweight spaceship
        [1,0],[2,0],[3,0],[4,0],
        [0,1],[4,1],
        [4,2],
        [0,3],[3,3]
    ];

    const PULSAR = [
        [2,0],[3,0],[4,0],[8,0],[9,0],[10,0],
        [0,2],[5,2],[7,2],[12,2],
        [0,3],[5,3],[7,3],[12,3],
        [0,4],[5,4],[7,4],[12,4],
        [2,5],[3,5],[4,5],[8,5],[9,5],[10,5],

        [2,7],[3,7],[4,7],[8,7],[9,7],[10,7],
        [0,8],[5,8],[7,8],[12,8],
        [0,9],[5,9],[7,9],[12,9],
        [0,10],[5,10],[7,10],[12,10],
        [2,12],[3,12],[4,12],[8,12],[9,12],[10,12],
    ];

    let dimension_x;
    let dimension_y;
    let game;
    let image;
    const cellSize = 4;

    function initGameOfLife() {
        const pixelSize = 1;

        dimension_x = Math.floor(canvas.width  / cellSize);
        dimension_y = Math.floor(canvas.height / cellSize);

        let cells = [];
        for (let x = 0; x < dimension_x; x++) {
            let row = [];
            for (let y = 0; y < dimension_y; y++)
                row.push(Math.random() < 0.5 ? dead_cell() : living_cell());
                //row.push(dead_cell());
            cells.push(row);
        }

        // const offsetX = Math.floor(dimension_x / 2);
        // const offsetY = Math.floor(dimension_y / 2);
        // place_pattern(cells, PULSAR, offsetX, offsetY);
        // place_pattern(cells, LWSS, Math.floor(offsetX * .5), offsetY);

        game = new Game(cells);
        image = new PixelImage(
            canvas.width,
            canvas.height,
            pixelSize,
            Colors.BLACK
        );
    }

    function render_game(game, image) {
        for (let cx = 0; cx < dimension_x; cx++)
            for (let cy = 0; cy < dimension_y; cy++) {
                const alive = game.cell_at(cx, cy).is_alive();
                const color = alive ? Colors.GREEN : Colors.BLACK;

                const px0 = cx * cellSize;
                const py0 = cy * cellSize;

                for (let dx = 0; dx < cellSize; dx++)
                    for (let dy = 0; dy < cellSize; dy++)
                        image.setColour(new Pixel(px0 + dx, py0 + dy, color));
            }
    }


    const frame_rate = 10; // generations per second
    let lastTime = 0;
    resizeCanvas();
    initGameOfLife();

    function loop(timestamp) {
        if (timestamp - lastTime > 1000 / frame_rate) {
            game = game.next_generation();
            render_game(game, image);
            image.render(display);
            lastTime = timestamp;
        }
        requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);



</script>

