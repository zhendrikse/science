<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<div class="canvasWrapper" id="polarContainer">
    <canvas class="applicationCanvas" id="polarCanvas"></canvas><br/>
</div>
<div class="gui-container" id="gui-container"></div>

<script type="module">
    import * as THREE from "three";
    import { Axes, Arrow, MatlabAxesLayout, MatlabAnnotations, Vector }
        from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import { Plot3D }
        from 'https://www.hendrikse.name/science/js/3d-surface-components.js';
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";

    const canvasContainer = document.getElementById("polarContainer");
    const canvas = document.getElementById("polarCanvas");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x131313);
    const worldGroup = new THREE.Group();
    scene.add(worldGroup);

    const axes = new Axes();
    worldGroup.add(axes);
    const axesLayout = new MatlabAxesLayout(2, 10);
    const annotations = new MatlabAnnotations(canvasContainer, 2, 10);
    axes.setLayout(axesLayout);
    axes.setAnnotations(annotations);
    worldGroup.add(annotations);
    annotations.visible = false;

    const plot3D = new Plot3D(canvas, scene, axes);
    const bbox = new THREE.Box3();
    bbox.setFromObject( worldGroup );
    plot3D.fitToBoundingBox(bbox, {padding: 1.1, translationY: -3});

    function vectorField1(x, y, z) {
        const u = Math.sin(Math.PI * x) * Math.cos(Math.PI * y) * Math.cos(Math.PI * z);
        const v = -Math.cos(Math.PI * x) * Math.sin(Math.PI * y) * Math.cos(Math.PI * z);
        const w = Math.sqrt(2.0 / 3.0) * Math.cos(Math.PI * x) * Math.cos(Math.PI * y) * Math.sin(Math.PI * z);
        return new Vector(u, w, v);
    }

    function vectorField2(x, y, z) {
        return new Vector(x, y, z);
    }

    const arrows = [];
    const initialPositions = [];
    const scaleFactor = 0.2;
    const hue = 0.5;
    for (let x = -0.8; x < 1; x += .2)
        for (let y = -0.8; y < 1; y += .2)
            for (let z = -0.8; z < 1; z += .4) {
                const axis = vectorField1(x, z, y).multiplyScalar(scaleFactor);
                const color = new THREE.Color().setHSL(hue + z, 1.0, 0.5);
                const initialPosition = new Vector(x, z, y);
                const arrow = new Arrow(initialPosition, axis, {color: color});
                if (axis.length() < 1e-3) continue;//arrow.visible = false;
                worldGroup.add(arrow);
                arrows.push(arrow);
                initialPositions.push(initialPosition);
            }

    const tmpAxis = new Vector();
    const tmpPos  = new Vector();
    function update(dt) {
        arrows.forEach(arrow => {
            const position = arrow.position;

            tmpAxis.copy(vectorField1(position.x, position.y, position.z)).multiplyScalar(scaleFactor);
            tmpPos.copy(position).addScaledVector(tmpAxis, dt);

            arrow.moveTo(tmpPos);
            tmpAxis.copy(vectorField1(tmpPos.x, tmpPos.y, tmpPos.z)).multiplyScalar(scaleFactor);
            arrow.updateAxis(tmpAxis);
        });
    }

    let numSteps = 0;
    const maxSteps = 100;
    function animate() {
        requestAnimationFrame(animate);
        update(0.02);
        numSteps++;
        if (numSteps > maxSteps) {
            numSteps = 0;
            arrows.forEach((arrow, index) => { arrow.moveTo(initialPositions[index])});
        }
        plot3D.render();
    }
    animate();
</script>
