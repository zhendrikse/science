<style>

    .applicationCanvas {
        display: block;
        background-color: #131313;
        width: 100%;
        max-width: 800px;
        aspect-ratio: 4 / 3;
        margin: auto;
    }


</style>
<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<canvas class="applicationCanvas" id="quiverCanvas"></canvas><br/>

<script type="module">
    import * as THREE from "three";
    import { VectorField, Arrow, Vector, Ball}
        from 'https://www.hendrikse.name/science/js/three-js-extensions.js';

    const canvas = document.getElementById("quiverCanvas");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x131313);
    const worldGroup = new THREE.Group();
    scene.add(worldGroup);

    const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true
    });
    renderer.setPixelRatio(window.devicePixelRatio);

    const aspect = canvas.clientWidth / canvas.clientHeight;

    const x_max = 2,
        x_min = -x_max,
        y_max = 0.75 * x_max,
        y_min = -y_max;

    const camera = new THREE.OrthographicCamera(
        x_min, x_max,
        y_max, y_min,
        -10, 10
    );

    camera.position.set(0, 0, 5);
    camera.lookAt(0, 0, 0);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(3, 5, 4);
    scene.add(dir);

    function updateCamera() {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        const aspect = w / h;

        const viewHeight = y_max - y_min;
        const viewWidth  = viewHeight * aspect;

        camera.top    =  viewHeight / 2;
        camera.bottom = -viewHeight / 2;
        camera.right  =  viewWidth / 2;
        camera.left   = -viewWidth / 2;

        camera.updateProjectionMatrix();
    }

    class DemoVectorField extends VectorField {
        constructor(source, sink, curl=null) {
            super();
            this.source = source; // Ball object
            this.sink = sink;     // Ball object
            this.curl = curl;     // Ball object or null
        }

        sample(position) {
            let vector = new Vector(0, 0, 0);

            // Source: repelling
            const radiusToSource = position.clone().sub(this.source.position());
            const distanceToSource = Math.max(radiusToSource.length(), 0.05);
            vector.add(radiusToSource.multiplyScalar(1 / (distanceToSource * distanceToSource)));

            // Sink: attracting
            const radiusToSink = this.sink.position().clone().sub(position);
            const distanceToSink = Math.max(radiusToSink.length(), 0.05);
            vector.add(radiusToSink.multiplyScalar(1 / (distanceToSink * distanceToSink)));

            // Curl effect (optional)
            if (this.curl) {
                const radiusToCurl = position.clone().sub(this.curl.position());
                const curlV =
                    new Vector(-radiusToCurl.y, radiusToCurl.x, 0).multiplyScalar(0.3 / (radiusToCurl.length() + 0.1));
                vector.add(curlV);
            }

            // Limit velocity
            const maxLen = 2;
            if (vector.length() > maxLen) vector.multiplyScalar(maxLen / vector.length());

            return vector;
        }
    }

    class OriginalDemoVectorField extends VectorField {
        constructor(source, sink, curl=null) {
            super();
            this.source = source; // Ball object
            this.sink = sink;     // Ball object
            this.curl = curl;     // Ball object or null
        }

        sample(position, radius=.75, a=new Vector(1, .5, 0), b=new Vector(-1, -.5, 0), c=new Vector(-1, .5, 0)) {
            if (a.x - radius <= position.x &&
                position.x <= a.x + radius &&
                a.y - radius <= position.y &&
                position.y <= a.y + radius)
            {
                const theta = Math.atan2((position.y - a.y), (position.x - a.x));
                return new Vector(-Math.sin(theta), Math.cos(theta), 0);
            } else if (b.x - radius <= position.x &&
                position.x <= b.x + radius &&
                b.y - radius <= position.y &&
                position.y <= b.y + radius)
            {
                const theta = Math.atan2((position.y - b.y), (position.x - b.x));
                return new Vector(-Math.cos(theta), -Math.sin(theta), 0);
            } else if (c.x - radius <= position.x &&
                position.x <= c.x + radius &&
                c.y - radius <= position.y &&
                position.y <= c.y + radius)
            {
                const theta = Math.atan2((position.y - c.y), (position.x - c.x));
                return new Vector(Math.cos(theta), Math.sin(theta), 0);
            } else if ((x_max - position.x <= 0.2 || position.x - x_min <= 0.2) &&
                (y_max - position.y <= 0.2 || position.y - y_min <= 0.2))
            {
                const vx = (x_max - position.x <= 0.2) ? -1 : 1;
                const vy = (y_max - position.y <= 0.2) ? -1 : 1;
                return new Vector(vx, vy, 0)
            } else if (x_max - position.x <= 0.2)
                return new Vector(0, 1, 0);
            else if (position.x - x_min <= 0.2)
                return new Vector(0, -1, 0);
            else if (y_max - position.y <= 0.2)
                return new Vector(-1, 0, 0);
            else if (position.y - y_min <= 0.2)
                return new Vector(1, 0, 0);
            else
                return new Vector(0.5, 1.5, 0);
        }
    }


    const source = new Ball(worldGroup, new Vector(-1, 0.5, 0), {radius: 0.25, opacity: 0.4, color: "red"});
    const sink = new Ball(worldGroup, new Vector(-1, -0.5, 0), {radius: 0.25, opacity: 0.4, color: "green"});
    const curl = new Ball(worldGroup, new Vector(1, 0.5, 0), {radius: 0.25, opacity: 0.4, color: "cyan"});
    curl.sphere.visible = false;

    const vectorField = new OriginalDemoVectorField(source, sink, curl);

    const particles = [];
    for (let x = x_min; x <= x_max; x += 0.25)
        for (let y = y_min; y <= y_max; y += 0.25)
            particles.push(new Ball(worldGroup, new Vector(x, y, 0), {radius: 0.05, color: "orange"}));


    function onResize() {
        const rect = canvas.getBoundingClientRect();

        const width  = Math.round(rect.width);
        const height = Math.round(rect.height);

        renderer.setSize(width, height, true); // <-- true is cruciaal

        const aspect = width / height;
        const viewHeight = y_max - y_min;
        const viewWidth  = viewHeight * aspect;

        camera.top    =  viewHeight / 1.75;
        camera.bottom = -viewHeight / 1.75;
        camera.right  =  viewWidth / 1.75;
        camera.left   = -viewWidth / 1.75;

        camera.updateProjectionMatrix();
    }


    window.addEventListener("resize", onResize);
    onResize();

    const arrows = [];
    for (let x = x_min; x <= x_max; x += 0.25)
        for (let y = y_min; y <= y_max; y += 0.25) {
            const axis = vectorField.sample(new Vector(x, y, 0)).multiplyScalar(.2),
                shift = axis.clone().multiplyScalar(-0.1),
                position = new Vector(x, y, 0).add(shift),
                arrow = new Arrow(position, axis, {color: "yellow", opacity: 0, round: true, shaftWidth: 0.05});
            arrows.push(arrow);
            worldGroup.add(arrow);
        }

    let time = 0;
    let opacity = 0;
    const dt = 0.005;
    const d_o = 0.005;

    function animate() {
        requestAnimationFrame(animate);

        time += dt;

        // Update deeltjes
        for (const particle of particles) {
            const pos = particle.position();
            const vel = vectorField.sample(pos);
            pos.addScaledVector(vel, dt);
            particle.shiftTo(pos);
        }

        // Fading effect voor arrows
        if (opacity < 1 && time > 0.1) {
            opacity += d_o;
            for (const arrow of arrows) {
                arrow.shaft.material.opacity = opacity;
                arrow.shaft.material.transparent = true;
                arrow.head.material.opacity = opacity;
                arrow.head.material.transparent = true;
            }
        }

        renderer.render(scene, camera);
    }


    animate();
</script>
