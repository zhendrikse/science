<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<div class="canvasWrapper" id="orbitalsContainer">
    <canvas class="applicationCanvas" id="orbitalsCanvas"></canvas><br/>
</div>
<div id="gui-container"></div>

<script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.0/lib/browser/math.js" type="text/javascript"></script>

<script type="module">
    import { Scene, Color, Group } from "three";
    import { AxesController, ThreeJsUtils, Plot3DView, AxesParameters }
        from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";
    import {  Utils, SignedOpacityColorMapper, ViewParameters, ContourType, TangentFrameParameters, ContourParameters,
        SurfaceSpecification, LiteralStringBasedSurfaceDefinition, StandardSurfaceView, Surface, SurfaceController,
        IsoparametricContoursView, CurvatureContoursView }
        from 'https://www.hendrikse.name/science/js/3d-surface-components.js';

    const canvasContainer = document.getElementById("orbitalsContainer");
    const canvas = document.getElementById("orbitalsCanvas");

    const scene = new Scene();
    scene.background = new Color(0x131313);
    const worldGroup = new Group();
    scene.add(worldGroup);

    const surfaceData = [{
        meta: { name: "1s" },
        parametrization: {
            xFn: "sin(u)*cos(v)",
            yFn: "cos(u)",
            zFn: "sin(u)*sin(v)"
        },
        signedField: { field: "1" },
        intervals: [["-pi","pi"],["0","pi"]]
    }, {
        meta: { name: "2pₓ" },
        parametrization: {
            xFn: "abs(sin(u)*cos(v))*sin(u)*cos(v)",
            yFn: "abs(sin(u)*cos(v))*cos(u)",
            zFn: "abs(sin(u)*cos(v))*sin(u)*sin(v)"
        },
        signedField: { field: "sin(u)*cos(v)" },
        intervals: [["-pi","pi"],["0","pi"]]
    },{
        meta: { name: "2pᵧ" },
        parametrization: {
            xFn: "abs(cos(u))*sin(u)*cos(v)",
            yFn: "abs(cos(u))*cos(u)",
            zFn: "abs(cos(u))*sin(u)*sin(v)"
        },
        signedField: { field: "cos(u)" },
        intervals: [["-pi","pi"],["0","pi"]]
    }, {
        meta: { name: "2p_z" },
        parametrization: {
            xFn: "abs(sin(u)*sin(v))*sin(u)*cos(v)",
            yFn: "abs(sin(u)*sin(v))*cos(u)",
            zFn: "abs(sin(u)*sin(v))*sin(u)*sin(v)"
        },
        signedField: { field: "sin(u)*sin(v)" },
        intervals: [["-pi","pi"],["0","pi"]]
    }, {
        meta: { name: "3d_z²" },
        parametrization: {
            xFn: "abs(3*cos(u)^2-1)*sin(u)*cos(v)",
            yFn: "abs(3*cos(u)^2-1)*cos(u)",
            zFn: "abs(3*cos(u)^2-1)*sin(u)*sin(v)"
        },
        signedField: { field: "3*cos(u)^2-1" },
        intervals: [["-pi","pi"],["0","pi"]]
    }, {
        meta: { name: "3d_xz" },
        parametrization: {
            xFn: "abs(sin(u)*cos(u)*cos(v))*sin(u)*cos(v)",
            yFn: "abs(sin(u)*cos(u)*cos(v))*cos(u)",
            zFn: "abs(sin(u)*cos(u)*cos(v))*sin(u)*sin(v)"
        },
        signedField: { field: "sin(u)*cos(u)*cos(v)" },
        intervals: [["-pi","pi"],["0","pi"]]
    }, {
        meta: { name: "3d_yz" },
        parametrization: {
            xFn: "abs(sin(u)*cos(u)*sin(v))*sin(u)*cos(v)",
            yFn: "abs(sin(u)*cos(u)*sin(v))*cos(u)",
            zFn: "abs(sin(u)*cos(u)*sin(v))*sin(u)*sin(v)"
        },
        signedField: { field: "sin(u)*cos(u)*sin(v)" },
        intervals: [["-pi","pi"],["0","pi"]]
    }, {
        meta: { name: "3d_x²₋z²" },
        parametrization: {
            xFn: "abs(sin(u)^2*cos(2*v))*sin(u)*cos(v)",
            yFn: "abs(sin(u)^2*cos(2*v))*cos(u)",
            zFn: "abs(sin(u)^2*cos(2*v))*sin(u)*sin(v)"
        },
        signedField: { field: "sin(u)^2*cos(2*v)" },
        intervals: [["-pi","pi"],["0","pi"]]
    }, {
        meta: { name: "3d_xy" },
        parametrization: {
            xFn: "abs(sin(u)^2*sin(2*v))*sin(u)*cos(v)",
            yFn: "abs(sin(u)^2*sin(2*v))*cos(u)",
            zFn: "abs(sin(u)^2*sin(2*v))*sin(u)*sin(v)"
        },
        signedField: { field: "sin(u)^2*sin(2*v)" },
        intervals: [["-pi","pi"],["0","pi"]]
    }, {
        meta: { name: "4f_z³" },
        parametrization: {
            xFn: "abs(5*cos(u)^3-3*cos(u))*sin(u)*cos(v)",
            yFn: "abs(5*cos(u)^3-3*cos(u))*cos(u)",
            zFn: "abs(5*cos(u)^3-3*cos(u))*sin(u)*sin(v)"
        },
        signedField: { field: "5*cos(u)^3-3*cos(u)" },
        intervals: [["-pi","pi"],["0","pi"]]
    }, {
        meta: { name: "4f_xyz" },
        parametrization: {
            xFn: "abs(sin(u)^2*cos(u)*sin(2*v))*sin(u)*cos(v)",
            yFn: "abs(sin(u)^2*cos(u)*sin(2*v))*cos(u)",
            zFn: "abs(sin(u)^2*cos(u)*sin(2*v))*sin(u)*sin(v)"
        },
        signedField: { field: "sin(u)^2*cos(u)*sin(2*v)" },
        intervals: [["-pi","pi"],["0","pi"]]
    }, {
        meta: { name: "4f_x(x²−3z²)" },
        parametrization: {
            xFn: "abs(sin(u)^3*cos(3*v))*sin(u)*cos(v)",
            yFn: "abs(sin(u)^3*cos(3*v))*cos(u)",
            zFn: "abs(sin(u)^3*cos(3*v))*sin(u)*sin(v)"
        },
        signedField: { field: "sin(u)^3*cos(3*v)" },
        intervals: [["-pi","pi"],["0","pi"]]
    }, {
        meta: { name: "4f_z(x²−z²)" },
        parametrization: {
            xFn: "abs(sin(u)^3*sin(3*v))*sin(u)*cos(v)",
            yFn: "abs(sin(u)^3*sin(3*v))*cos(u)",
            zFn: "abs(sin(u)^3*sin(3*v))*sin(u)*sin(v)"
        },
        signedField: { field: "sin(u)^3*sin(3*v)" },
        intervals: [["-pi","pi"],["0","pi"]]
    }];

    class OrbitalSurfaceSpecification extends SurfaceSpecification {
        constructor({ meta, parametrization, intervals, signedField }) {
            super({meta, parametrization, intervals});
            this._signedField = signedField;
            Object.freeze(this);
        }

        get signedFieldFunction() { return Utils.functionFrom(this._signedField.field); }

        withParametrization(patch) {
            return new OrbitalSurfaceSpecification({
                meta: this._meta,
                intervals: this._intervals,
                signedField: this._signedField,
                parametrization: {
                    ...this._parametrization,
                    ...patch
                }
            });
        }
    }

    class ControlsGui {
        constructor(surfaceController, axesController, plot3d) {
            const gui = new GUI({width: "100%", autoPlace: false});

            const OrbitalPresets = Object.fromEntries(surfaceData.map((surface, index) => [surface.meta.name, index]));

            this._axesController = axesController;
            this._surfaceController = surfaceController;
            this._plot3d = plot3d;
            this._surfaceCoordinates = {
                x: surfaceController.surface.definition().specification().parametrization.xFn,
                y: surfaceController.surface.definition().specification().parametrization.yFn,
                z: surfaceController.surface.definition().specification().parametrization.zFn
            }

            gui.add(params, "surfacePreset", OrbitalPresets)
                .name("Orbital")
                .onChange(index => {
                    const data = surfaceData[index];
                    const spec = new OrbitalSurfaceSpecification(data);
                    this.#updateSurface(spec);
                });


            this.#createContourFolder(gui);
            this.#createAxesFolder(gui);
            this.#createMathFolder(gui);
            document.getElementById("gui-container").appendChild(gui.domElement);
        }

        #isValidColor() {
            const style = new Option().style;
            style.color = surfaceParams.baseColor;
            return style.color !== '';
        }

        #createAxesFolder(parentFolder) {
            const axesFolder = parentFolder.addFolder("Axes");
            const dummyToggle = {gridPlanes: true};
            axesFolder.add(params.axesParameters, 'frame')
                .name("Frame").onChange(value => axesController.updateSettings());
            axesFolder.add(dummyToggle, 'gridPlanes')
                .name("Layout").onChange(value => {
                params.axesParameters.xyPlane = value;
                params.axesParameters.xzPlane = value;
                params.axesParameters.yzPlane = value;
                axesController.updateSettings();
            });
            axesFolder.add(params.axesParameters, 'annotations')
                .name("Annotations").onChange(value => axesController.updateSettings());
            axesFolder.close();
        }

        #createContourFolder(folder) {
            const contourFolder = folder.addFolder("Contours");
            contourFolder.add(surfaceParams.contourParameters, "contourType", Object.values(ContourType))
                .name("Contour type")
                .onChange(value => {
                    const surface = this._surfaceController.surface;
                    const contourParams = surfaceParams.contourParameters;
                    switch (value) {
                        case ContourType.NONE:
                            this._surfaceController.updateContoursView(null, contourParams);
                            break;
                        case ContourType.CURVATURE:
                            this._surfaceController.updateContoursView(new CurvatureContoursView(surface.group, surface), contourParams);
                            break;
                        case ContourType.ISO_PARAMETRIC:
                            this._surfaceController.updateContoursView(new IsoparametricContoursView(surface.group, surface), contourParams);
                            break;
                    }
                    this._surfaceController.updateContours(surfaceParams.contourParameters)
                });
            contourFolder.add(surfaceParams.contourParameters, 'color')
                .name("Color")
                .onChange(() => {if (this.#isValidColor()) this._surfaceController.updateContours(surfaceParams.contourParameters);});
            contourFolder.add(surfaceParams.contourParameters, "uCount", 1, 50, 1)
                .name("U contours")
                .onFinishChange(value => this._surfaceController.updateContours(surfaceParams.contourParameters));
            contourFolder.add(surfaceParams.contourParameters, "vCount", 1, 50, 1)
                .name("V contours")
                .onFinishChange(value => this._surfaceController.updateContours(surfaceParams.contourParameters));
            contourFolder.close();
        }

        #createMathFolder(folder) {
            const mathFolder = folder.addFolder("Math");

            this._xFunction = mathFolder.add(this._surfaceCoordinates, "x").name("Fx(u,v) =")
                .onFinishChange(expr => {
                    const surfaceSpecification = this._surfaceController.surface
                        .definition().specification().withParametrization({xFn: expr});
                    this.#updateSurface(surfaceSpecification);
                });

            this._yFunction = mathFolder.add(this._surfaceCoordinates, "y").name("Fy(u,v) =")
                .onFinishChange(expr => {
                    const surfaceSpecification = this._surfaceController.surface
                        .definition().specification().withParametrization({yFn: expr});
                    this.#updateSurface(surfaceSpecification);
                });

            this._zFunction = mathFolder.add(this._surfaceCoordinates, "z").name("Fz(u,v) =")
                .onFinishChange(expr => {
                    const surfaceSpecification = this._surfaceController.surface
                        .definition().specification().withParametrization({zFn: expr});
                    this.#updateSurface(surfaceSpecification);
                });

            mathFolder.close();
        }

        #updateSurface(surfaceSpecification) {
            const surfaceDef = new LiteralStringBasedSurfaceDefinition(surfaceSpecification);
            const newSurface = new StandardSurfaceView(
                worldGroup,
                new Surface(surfaceDef),
                surfaceParams,
                new SignedOpacityColorMapper(surfaceSpecification.signedFieldFunction));
            this._surfaceController.changeSurface(newSurface, surfaceParams);
            this._axesController.createFromBoundingBox(surfaceController.surfaceBoundingBox());
            this._plot3d.frame(ThreeJsUtils.scaleBox3(surfaceController.surfaceBoundingBox(), .9),{translationY: -1.5});
            this._xFunction.setValue(surfaceSpecification.parametrization.xFn);
            this._yFunction.setValue(surfaceSpecification.parametrization.yFn);
            this._zFunction.setValue(surfaceSpecification.parametrization.zFn);
        }
    }

    const surfaceParams = new ViewParameters({
        contourParameters: new ContourParameters({
            contourType: ContourType.NONE
        }),
        tangentFrameParameters: new TangentFrameParameters({
            visible: false
        }),
        opacity: 0.95,
        resolution: 125
    });

    const params = {
        axesParameters: new AxesParameters({annotations: false}),
        surfacePreset: "1s"
    };
    const axesController = new AxesController({
        parentGroup: worldGroup,
        canvasContainer: canvasContainer,
        axesParameters: params.axesParameters,
        scene: scene
    });

    const defaultSurfaceSpec = new OrbitalSurfaceSpecification(surfaceData[0]);
    const defaultSurfaceDef = new LiteralStringBasedSurfaceDefinition(defaultSurfaceSpec);
    const defaultSurface = new StandardSurfaceView(
        worldGroup,
        new Surface(defaultSurfaceDef),
        surfaceParams,
        new SignedOpacityColorMapper(defaultSurfaceSpec.signedFieldFunction));
    const surfaceController = new SurfaceController(worldGroup, defaultSurface, surfaceParams);

    // Scale scene according to current surface
    axesController.createFromBoundingBox(surfaceController.surfaceBoundingBox());
    const plot3D = new Plot3DView(scene, canvas, surfaceController.surfaceBoundingBox());
    plot3D.frame(ThreeJsUtils.scaleBox3(surfaceController.surfaceBoundingBox(), .9), {translationY: -1.5});
    const gui = new ControlsGui(surfaceController, axesController, plot3D);

    // Resizing for mobile devices
    function resize() {
        ThreeJsUtils.resizeRendererToCanvas(plot3D.renderer, plot3D.camera);
        axesController.resize();
    }
    window.addEventListener("resize", resize);
    resize();

    function animate() {
        requestAnimationFrame(animate);
        plot3D.render();
        axesController.render(plot3D.camera);
    }
    animate();
</script>
