<style>

    .applicationCanvas {
        display: block;
        background-color: #131313;
        width: 100%;
        max-width: 800px;
        aspect-ratio: 4 / 3;
        margin: auto;
    }

    .canvasWrapper {
        position: relative;
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        aspect-ratio: 4 / 3;
    }

    .guiContainer {
        margin-top: 0.5em;
        background: #1a1a1a;
    }

</style>
<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<div class="titleDiv" id="vectorFieldTitle"></div>
<div class="canvasWrapper" id="quiverContainer">
    <canvas class="applicationCanvas" id="quiverCanvas"></canvas><br/>
</div>
<div class="guiContainer" id="gui-container"></div>

<script type="module">
    import * as THREE from "three";
    import { Axes, AxesParameters, Arrow, MatlabAxesLayout, MatlabAnnotations, Vector, UnitVectorE2 }
        from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import { Plot3D }
        from 'https://www.hendrikse.name/science/js/3d-surface-components.js';
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";

    const canvasContainer = document.getElementById("quiverContainer");
    const canvas = document.getElementById("quiverCanvas");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x131313);
    const worldGroup = new THREE.Group();
    scene.add(worldGroup);

    const axes = new Axes();
    worldGroup.add(axes);
    const axesLayout = new MatlabAxesLayout(2, 10);
    const annotations = new MatlabAnnotations(canvasContainer, 2, 10);
    axes.setLayout(axesLayout);
    axes.setAnnotations(annotations);
    worldGroup.add(annotations);
    annotations.visible = false;

    const plot3D = new Plot3D(canvas, scene, axes);
    const bbox = new THREE.Box3();
    bbox.setFromObject( worldGroup );
    plot3D.fitToBoundingBox(bbox, {padding: 1.1, translationY: -3});

    const VectorFields = Object.freeze({
        FIELD_1: "Vector field 1",
        FIELD_2: "Vector field 2"
    });

    const params = {
        animate: false,
        vectorField: VectorFields.FIELD_1,
        axesParameters: new AxesParameters({xyPlane: false, yzPlane: false, axesLabels: false})
    };

    class ControlsGui {
        constructor(axesLayout, annotations) {
            const gui = new GUI({width: 300, autoPlace: false});

            gui.add(params, 'vectorField', Object.values(VectorFields))
                .name("Field type")
                .onChange(value => this.#changeVectorFieldTo(value));
            gui.add(params, "animate").name("Animate");

            const axesFolder = gui.addFolder("Axes");
            axesFolder.add(params.axesParameters, 'axesLines')
                .name("Axes").onChange(value => value ? axesLayout.showAxes() : axesLayout.hideAxes());
            axesFolder.add(params.axesParameters, 'axesLabels')
                .name("Axes labels").onChange(value => annotations.visible = value);
            axesFolder.add(params.axesParameters, 'xyPlane')
                .name("XY plane").onChange(value => value ? axesLayout.showXY() : axesLayout.hideXY());
            axesFolder.add(params.axesParameters, 'xzPlane')
                .name("XZ plane").onChange(value => value ? axesLayout.showXZ() : axesLayout.hideXZ());
            axesFolder.add(params.axesParameters, 'yzPlane')
                .name("YZ plane").onChange(value => value ? axesLayout.showYZ() : axesLayout.hideYZ());
            axesFolder.close();

            document
                .getElementById("gui-container")
                .appendChild(gui.domElement);
        }

        #doChangeVectorField(vectorField) {
            let { positions: newPositions, arrows: newArrows } =
                initializeQuiverPlotFrom(initialPositions, vectorField);

            positions = newPositions;
            arrows = newArrows;
        }

        #changeVectorFieldTo(vectorField) {
            arrows.forEach(arrow => {worldGroup.remove(arrow);});
            switch (vectorField) {
                case VectorFields.FIELD_1:
                    equationDiv.innerHTML = titleField1;
                    this.#doChangeVectorField(vectorField1);
                    break;
                case VectorFields.FIELD_2:
                    equationDiv.innerHTML = titleField2;
                    this.#doChangeVectorField(vectorField2);
                    break;
            }
            if (window.MathJax) MathJax.typesetPromise([equationDiv]);
        }
    }

    const gui = new ControlsGui(axesLayout, annotations);

    const titleField1 = "$$\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} \\sin(\\pi x)\\cos(\\pi y)\\cos(\\pi z) \\\\ -\\cos(\\pi  x)\\sin(\\pi y)\\cos(\\pi z) \\\\ (\\sqrt{(2 / 3)} \\cos(\\pi x)\\cos(\\pi y)\\sin(\\pi z)) \\end{pmatrix}$$";
    function vectorField1(x, y, z) {
        const u = Math.sin(Math.PI * x) * Math.cos(Math.PI * y) * Math.cos(Math.PI * z);
        const v = -Math.cos(Math.PI * x) * Math.sin(Math.PI * y) * Math.cos(Math.PI * z);
        const w = Math.sqrt(2.0 / 3.0) * Math.cos(Math.PI * x) * Math.cos(Math.PI * y) * Math.sin(Math.PI * z);
        return new Vector(u, w, v);
    }

    const titleField2 = "$$\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}$$";
    function vectorField2(x, y, z) {
        return new Vector(x, y, z);
    }

    const equationDiv = document.getElementById("vectorFieldTitle");
    equationDiv.innerHTML = titleField1;
    if (window.MathJax) MathJax.typesetPromise([equationDiv]);

    const initialPositions = [];
    for (let x = -0.8; x < 1; x += .2)
        for (let y = -0.8; y < 1; y += .2)
            for (let z = -0.8; z < 1; z += .4)
                initialPositions.push(new Vector(x, z, y));

    function initializeQuiverPlotFrom(positions, field, scaleFactor=0.2, hue=0.5) {
        const arrows = [];
        const arrowPositions = [];
        positions.forEach(position => {
            const axis = field(position.x, position.y, position.z).multiplyScalar(scaleFactor);
            if (axis.length() > 1e-3) {
                const color = new THREE.Color().setHSL(hue + position.y, 1.0, 0.5);
                const arrow = new Arrow(position.clone().add(UnitVectorE2), axis, {color: color});
                worldGroup.add(arrow);
                arrows.push(arrow);
                arrowPositions.push(position);
            }
        });
        return {positions, arrows};
    }

    let {positions, arrows} = initializeQuiverPlotFrom(initialPositions, vectorField1);
    const tmpAxis = new Vector();
    const tmpPos  = new Vector();

    function update(dt, scaleFactor=0.2) {
        const vectorField = params.vectorField === VectorFields.FIELD_1 ? vectorField1 : vectorField2;

        arrows.forEach(arrow => {
            const position = arrow.position.clone().sub(UnitVectorE2);

            tmpAxis.copy(arrow.axis);
            tmpPos.copy(position).addScaledVector(tmpAxis, dt); // Euler

            tmpAxis.copy(vectorField(tmpPos.x, tmpPos.y, tmpPos.z)).multiplyScalar(scaleFactor);
            arrow.moveTo(tmpPos.clone().add(UnitVectorE2));
            arrow.updateAxis(tmpAxis);
        });
    }

    let numSteps = 0;
    const maxSteps = 100;
    function animate() {
        requestAnimationFrame(animate);
        plot3D.render();
        if (!params.animate) return;

        update(0.02);
        numSteps++;
        if (numSteps > maxSteps) {
            numSteps = 0;
            arrows.forEach((arrow, index) => arrow.moveTo(positions[index].clone().add(UnitVectorE2)));
        }
    }
    animate();
</script>
