<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<canvas id="myCanvas" width="600" height="600"></canvas>
<h1>Graph</h1>
<canvas id="graphCanvas" width="600" height="300" style="background-color: #131313"></canvas>

<script type="module">
    import * as THREE from "three";

    class Ball {
        constructor(parent, position, mass=10, color=0xffff00) {
            const massRadius = 1;
            const massMaterial = new THREE.MeshStandardMaterial({color: color, metalness:0.7, roughness:0.2});
            this.sphere = new THREE.Mesh(new THREE.SphereGeometry(massRadius,24,24), massMaterial);
            this.sphere.position.copy(position);
            this.sphere.castShadow = true;
            this.mass = mass;
            this.velocity = new THREE.Vector3(0, 0, 0);
            parent.add(this.sphere);
        }

        // updateWith(force, dt) {
        //     this.velocity += force / this.mass * dt;
        //     this.velocity *= .999; // damping
        //     this.sphere.position.y += this.velocity * dt;
        // }

        updateWith(force, dt) {
            this.velocity.addScaledVector(force, dt / this.mass);
            this.velocity.multiplyScalar(0.998); // damping
            this.sphere.position.addScaledVector(this.velocity, dt);
        }

        damp = () => this.velocity.multiplyScalar(0.998);
        position = () => this.sphere.position.clone();
        shiftTo(newPosition) {
            this.sphere.position.copy(newPosition);
            this.velocity = new THREE.Vector3(0, 0, 0);
        }

        kineticEnergy = () => 0.5 * ball.mass * this.velocity.y * this.velocity.y;
    }

    // --- Curve for slinky spring ---
    class SpringCurve extends THREE.Curve {
        constructor(start, end, coils=25, radius=0.4, waveAmp=0.05, wavePhase=0){
            super();
            this.start = start.clone();
            this.end = end.clone();
            this.coils = coils;
            this.radius = radius;
            this.waveAmp = waveAmp;
            this.wavePhase = wavePhase;
        }

        getPoint(t){
            const axis = new THREE.Vector3().subVectors(this.end, this.start);
            const length = axis.length();
            axis.normalize();

            const angle = t * this.coils * Math.PI * 2;
            const x = Math.cos(angle) * this.radius;
            const y = Math.sin(angle) * this.radius;

            // Longitudinal wave across spring
            const z = t * length + this.waveAmp * Math.sin(Math.PI * t) * Math.sin(2 * Math.PI * t * 3 - this.wavePhase);

            const point = new THREE.Vector3(x, y, z);
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), axis);
            point.applyQuaternion(quaternion);

            return point.add(this.start);
        }
    }

    class SlinkySpring {
        constructor(parent, start, end, {
            k=200,
            length=15,
            color=0x00ffff,
            coils=30,
            longitudinalOscillation=false,
            tubularSegments=400,
            radialSegments=12,
            radius=0.5,
            coilRadius=0.075
        } = {}) {
            this.longtudinalOscillation = longitudinalOscillation;
            this.radius = radius;
            this.curve = new SpringCurve(start, end, coils, radius);
            this.tubularSegments = tubularSegments;
            this.radialSegments = radialSegments;
            this.coilRadius = coilRadius;
            this.length = length;
            this.k = k;
            this.startPosition = start;

            this.geometry = new THREE.TubeGeometry(this.curve, tubularSegments, coilRadius, radialSegments, false);
            const material = new THREE.MeshStandardMaterial({color: color, metalness:0.3, roughness:0.4});
            this.spring = new THREE.Mesh(this.geometry, material);
            scene.add(this.spring);
        }

        #regenerateTube() {
            this.spring.geometry.dispose();
            this.spring.geometry = new THREE.TubeGeometry(
                this.curve, this.tubularSegments, this.coilRadius, this.radialSegments, false
            );
        }

        updateTo(newPosition, time) {
            this.longtudinalOscillation ?
                this.#updateWithLongitudinal(newPosition, time) :
                this.#updateWithoutLongitudinal(newPosition, time);
        }

        #updateWithoutLongitudinal(newPosition, time) {
            this.curve.end.copy(newPosition);
            this.#regenerateTube();
        }

        #updateWithLongitudinal(newPosition, time) {
            this.curve.end.copy(newPosition);
            // Longitudinal wave amplitude coupled to spring elongation
            const displacement = newPosition.y - this.curve.start.y;
            this.curve.waveAmp = Math.min(Math.abs(displacement)/10, 0.3); // max amplitude 0.3
            this.curve.wavePhase = time * 4;
            this.#regenerateTube();
        }

        extensionGiven = (positionY) => positionY - (this.startPosition.y - this.length);
    }

    // --- Scene setup ---
    const canvas = document.getElementById("myCanvas");
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x131313);

    const camera = new THREE.PerspectiveCamera(45, canvas.clientWidth/canvas.clientHeight, 0.1, 100);
    camera.position.set(15, 15, 30);
    camera.lookAt(0, 5, 0);

    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);

    scene.add(new THREE.HemisphereLight(0xffffff,0x222222,0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);
    renderer.shadowMap.enabled = true;
    dirLight.castShadow = true;

    // --- Plafond ---
    // const ceilingSize = 50;
    // const ceilingGeometry = new THREE.PlaneGeometry(ceilingSize, ceilingSize);
    // const ceilingMaterial = new THREE.MeshStandardMaterial({
    //     color: 0x8a8a8a,
    //     metalness: 0.05,
    //     roughness: 0.95,
    //     side: THREE.DoubleSide
    // });
    // ceilingMaterial.bumpScale = 0.05;
    //
    // const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    //
    // // horizontal plane
    // ceiling.rotation.x = Math.PI / 2;
    // ceiling.position.y = start.y;
    //
    // scene.add(ceiling);
    // ceiling.receiveShadow = true;

    // Constants and parameters
    const start = new THREE.Vector3(0, 15, 0);
    const initialEnd = new THREE.Vector3(
        (Math.random() - 0.5) * 0.5,  // ±0.25 in X
        5,
        (Math.random() - 0.5) * 0.5   // ±0.25 in Z
    );
    const g = 9.8;
    const dt = 0.02;
    let time = 0;
    let dragging = false;
    let mouseY = 0;

    // Spring ball system
    const ball = new Ball(scene, initialEnd, 10);
    const slinky = new SlinkySpring(scene, start, ball.position(), {k:200, length:15, longitudinalOscillation: true});

    // --- Mouse click & drag ---
    canvas.addEventListener('mousedown', e => {
        const rect = canvas.getBoundingClientRect();
        mouseY = ((e.clientY - rect.top) / rect.height) * 2 - 1; // niet exact nodig voor nu
        dragging = true;
    });
    canvas.addEventListener('mouseup', e => dragging = false);
    canvas.addEventListener('mousemove', e => {
        if(dragging){
            const rect = canvas.getBoundingClientRect();
            const x = ((e.clientX - rect.left)/rect.width - 0.5) * 20; // scale to scene
            const y = 10 - ((e.clientY - rect.top) / rect.height) * 20;
            ball.shiftTo(new THREE.Vector3(x, y, 0));
        }
    });

    const graphCanvas = document.getElementById("graphCanvas");
    const graphContext = graphCanvas.getContext("2d");

    const maxPoints = 300;
    const KE = [];
    const PE = [];
    const E  = [];
    const Y = [];

    function drawGraph() {
        graphContext.clearRect(0,0,graphCanvas.width,graphCanvas.height);

        const scaleY = 0.1;  // pas aan
        const offsetY = graphCanvas.height * 0.9;

        function drawLine(data, color) {
            graphContext.beginPath();
            graphContext.strokeStyle = color;
            data.forEach((v,i)=>{
                const x = i * graphCanvas.width / maxPoints;
                const y = offsetY - v * scaleY;
                if(i===0) graphContext.moveTo(x,y);
                else graphContext.lineTo(x,y);
            });
            graphContext.stroke();
        }

        drawLine(KE, "red");      // kinetisch
        drawLine(PE, "lime");     // potentieel
        drawLine(E,  "cyan");    // totaal
        drawLine(Y, "yellow");     // position
    }


    function force(kHorizontal = 100) { // horizontal spring constant
        const forceX = -kHorizontal * ball.position().x;
        const forceY = -slinky.k    * slinky.extensionGiven(ball.position().y) - ball.mass * g;
        const forceZ = -kHorizontal * ball.position().z;
        return new THREE.Vector3(forceX, forceY, forceZ);
    }

    function updateGraphData() {
        const springExtension = slinky.extensionGiven(ball.position().y)
        const potentialSpring = 0.5 * slinky.k * springExtension * springExtension;
        const potentialGravity = ball.mass * g * ball.position().y;
        KE.push(ball.kineticEnergy());
        PE.push(potentialSpring + potentialGravity);
        E.push(ball.kineticEnergy() + potentialSpring + potentialGravity);
        Y.push((5 + ball.position().y) * 100); // scale
    }

    function shiftGraph() {
        if (Y.length > maxPoints) Y.shift();
        if (KE.length > maxPoints) {
            KE.shift();
            PE.shift();
            E.shift();
        }
    }

    function animate(){
        requestAnimationFrame(animate);
        time += dt;
        if (!dragging) ball.updateWith(force(), dt);
        slinky.updateTo(ball.position(), time);
        renderer.render(scene, camera);
        updateGraphData();
        shiftGraph();
        drawGraph();
    }

    animate();

    // --- interactive: spring hardening / softening ---
    window.addEventListener('keydown', e => {
        if(e.key==='ArrowUp') slinky.k +=20;
        if(e.key==='ArrowDown') slinky.k -=20;
        slinky.k = Math.max(20, slinky.k);
        console.log("k =", slinky.k);
    });
</script>

