<style>
    canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
    }

    #container {
        position: relative;
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        aspect-ratio: 4 / 5;
    }

    #gui-container {
        margin-top: 0.5em;
        background: #1a1a1a;
    }

    #surface-equation {
        position: absolute;
        margin-top: 10px;
        width: 100%;
        max-width: 100%;
        font-size: 13px;
        color: yellow;
        text-align: center;
        z-index: 10;
    }

    #surface-equation .mjx-chtml {
        font-size: clamp(12px, 3.5vw, 10px);
        display: block;                 /* make MathJax fill the div */
        max-width: 100%;
        margin: 0 auto;
    }
</style>

<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.0/lib/browser/math.js" type="text/javascript"></script>

<div id="surface-equation"></div>
<div id="container">
    <canvas id="myCanvas"></canvas><br/>
</div>
<div id="gui-container"></div>

<script type="module">
    import * as THREE from "three";
    import { ThreeJsUtils } from 'https://www.hendrikse.name/science/js/three-js-utils.js';
    import { Axes, Plot3D, StandardAxesAnnotations, MatlabAxesLayout, ColorMode, ContourType, Interval,
        Surface, StandardSurfaceView, ViewParameters, LiteralStringBasedSurfaceDefinition }
        from 'https://www.hendrikse.name/science/js/components-library.js';
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm";

    const canvasContainer = document.getElementById("container");
    const canvas = document.getElementById("myCanvas");
    const functionParameters = { userFunction: "3 * (1 - 2 * (u*u + v*v))*exp(-1.5 * (u*u + v*v))" };

    function displayedSurface(surfaceData, visualizationParameters, scenery, axes) {
        const surfaceInAxes = new StandardSurfaceView(worldGroup, new Surface(surfaceData), visualizationParameters);
        surfaceInAxes.resetTransform();
        ThreeJsUtils.fitGroupToBox(
            surfaceInAxes.group,
            surfaceInAxes.boundingBox(),
            axes.boundingBox(),
            { alignY: "min", padding: 1.1 }
        );
        return surfaceInAxes;
    }

    class ControlsGui {
        constructor(scenery, surface, axes, annotations, viewParameters=new ViewParameters()) {
            this.viewParameters = viewParameters;
            this.surface = surface;
            const controls = new GUI({width: 300, autoPlace: false});
            document.getElementById("gui-container").appendChild(controls.domElement);

            controls.add(functionParameters, "userFunction").name("f(u,v) =")
                .onFinishChange(expr => {
                    const surfaceDefinition = {
                        parametrization: {xFn: "u", yFn: expr, zFn: "v"},
                        intervals: [["-2", "2"], ["-2", "2"]]
                    };

                    this.surface.dispose();
                    this.surface = displayedSurface(surfaceDefinition, this.viewParameters, scenery, axes)
                    // scenery.fitToBoundingBox(surface.getBoundingBox());
                    // scenery.updateTitle(expr);
                });

            this.#createAppearanceFolder(controls, axes, annotations);
            this.#createContourFolder(controls);
        }

        #createContourFolder(folder) {
            const contourFolder = folder.addFolder("Contours");
            contourFolder.add(this.viewParameters.contourParameters, "contourType", Object.values(ContourType))
                .name("Contour type")
                .onChange(value => this.surface.modifyContours({mode: value}));
            contourFolder.add(this.viewParameters.contourParameters, 'color')
                .name("Color")
                .onChange(() => {if (this.#isValidColor()) this.surface.modifyContours(this.viewParameters.contourParameters);});
            contourFolder.add(this.viewParameters.contourParameters, "uCount", 1, 50, 1)
                .name("U contours")
                .onChange(() => this.surface.modifyContours(this.viewParameters.contourParameters));
            contourFolder.add(this.viewParameters.contourParameters, "vCount", 1, 50, 1)
                .name("V contours")
                .onChange(() => this.surface.modifyContours(this.viewParameters.contourParameters));
            contourFolder.close();
        }

        #createSurfaceFolder(folder) {
            const surfaceFolder = folder.addFolder("Surface");
            surfaceFolder.add(this.viewParameters, "colorMode", Object.values(ColorMode))
                .name("Color Mode")
                .onChange(() => this.surface.changeColorModeTo(this.viewParameters.colorMode));
            surfaceFolder.add(this.viewParameters, 'baseColor')
                .name("Base color")
                .onChange(() => {if (this.#isValidColor()) this.surface.changeBaseColorTo(this.viewParameters.baseColor);});
            surfaceFolder.add(this.viewParameters, "opacity", 0, 1, .01)
                .name("Opacity")
                .onChange(value => this.surface.changeOpacityTo(value));
            surfaceFolder.add(this.viewParameters, "resolution", 10, 200, 1)
                .name("Resolution")
                .onFinishChange(resolution => this.surface.resampleWith(resolution));
            surfaceFolder.close();
        }

        #createOptionsFolder(folder, axes, annotations) {
            const optionsFolder = folder.addFolder("Options");
            optionsFolder.add(this.viewParameters.axesParameters, 'showAxes')
                .name("Axes").onChange(value => value ? axes.show() : axes.hide());
            optionsFolder.add(this.viewParameters.axesParameters, 'showAxesLabels')
                .name("Axes labels").onChange(value => value ? annotations.show() : annotations.hide());
            optionsFolder.add(this.viewParameters, 'wireframe')
                .name("Wireframe")
                .onChange(value => this.surface.toggleWireframe(value));
            optionsFolder.add(this.viewParameters, 'normals')
                .name('Show Normals')
                .onChange(value => this.#showNormals(this.surface, value));
            optionsFolder.add(this.viewParameters, 'autoRotate').name('Auto rotate');
            optionsFolder.close();
        }

        #createAppearanceFolder(controls, axes, annotations) {
            const appearanceFolder = controls.addFolder("Appearance");
            this.#createSurfaceFolder(appearanceFolder);
            this.#createOptionsFolder(appearanceFolder, axes, annotations);
            this.#createContourFolder(appearanceFolder);

            appearanceFolder.add({reset: () =>
                    scenery.fitToBoundingBox(this.surface.boundingBox(), {padding: 1.2, translationY: -0.5})}, "reset")
                .name("Reset Camera");
            appearanceFolder.close();
        }

        #isValidColor() {
            const style = new Option().style;
            style.color = this.viewParameters.baseColor;
            return style.color !== '';
        }

        #showNormals(surface, show) {
            if (show) {
                surface.addNormalsWith({});
                surface.changeOpacityTo(0.3);
            } else {
                surface.clearNormals();
                surface.changeOpacityTo(this.viewParameters.opacity);
            }
        }

        render() {
            if (this.viewParameters.autoRotate)
                this.surface.rotateBy(0.005);
        }
    }

    function updateSurfaceData(surfaceData) {
        const equationDiv = document.getElementById("surface-equation");
        equationDiv.innerHTML = "$$\\begin{pmatrix}" +
            surfaceData.parametrization.xFn + " \\\\" +
            surfaceData.parametrization.yFn + " \\\\" +
            surfaceData.parametrization.zFn + "\\end{pmatrix}\\text{, } \\begin{cases} u \\in [" +
            surfaceData.intervals[0][0] + ", " +
            surfaceData.intervals[0][1] + "] \\\\ v \\in [" +
            surfaceData.intervals[1][0] + ", " +
            surfaceData.intervals[1][1] + "] \\end{cases}$$";
        if (window.MathJax) MathJax.typesetPromise([equationDiv]);
    }

    const scene = new THREE.Scene();
    const worldGroup = new THREE.Group();
    scene.add(worldGroup);

    const axes = new Axes(worldGroup);
    axes.setLayout(new MatlabAxesLayout(4.1, 10));
    //axes.setLayout(new ClassicalAxesLayout(4, 10));
    const annotations = new StandardAxesAnnotations(canvasContainer, 4.1, 10, false);
    axes.setAnnotations(annotations);
    annotations.hide();

    const plot3D = new Plot3D(canvas, scene, axes);
    const bbox = new THREE.Box3();
    bbox.setFromObject( worldGroup );
    plot3D.fitToBoundingBox(bbox, {padding: 1.1, translationY: -1.0});

    const surfaceDefinition = {
        parametrization: {
            xFn: "u",
            yFn: functionParameters.userFunction,
            zFn: "v"
        },
        intervals: [["-2", "2"], ["-2", "2"]]
    }
    const visualizationParameters = new ViewParameters();
    visualizationParameters.opacity = 0.95;
    let surfaceInAxes = displayedSurface(surfaceDefinition, visualizationParameters, plot3D, axes);
    updateSurfaceData(surfaceDefinition);

    // Interaction
    const controlsGui = new ControlsGui(worldGroup, surfaceInAxes, axes, annotations, visualizationParameters);

    function animate() {
        requestAnimationFrame(animate);
        plot3D.render();
        controlsGui.render();
    }
    animate();
</script>
