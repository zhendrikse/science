<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<canvas class="applicationCanvas" id="simulationCanvas"></canvas><br/>
<p style="clear: both;"></p>
<div class="buttonRow">
    <button id="pauseButton">&nbsp;Pause&nbsp;</button>
    <button id="bondTypeButton">Bonds as springs</button>
</div>

<script type="module">
    import { Scene, Vector3, PerspectiveCamera, WebGLRenderer, DirectionalLight, AmbientLight }  from "three";
    import { Ball, Spring, Bond } from "https://www.hendrikse.name/science/js/three-js-extensions.js";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    console.clear( );
    const scene = new Scene();

    const canvas = document.getElementById('simulationCanvas');
    canvas.focus();
    const canvasWidth = canvas.clientWidth;
    const canvasHeight = canvas.clientHeight;

    const camera = new PerspectiveCamera(60, canvasWidth/canvasHeight, 0.1, 1000);
    camera.position.set(1.1, 2, 2.1);
    camera.updateProjectionMatrix();

    const renderer = new WebGLRenderer( {antialias: true, canvas: canvas, alpha: true} );
    renderer.setSize( canvasWidth, canvasHeight );
    renderer.setAnimationLoop( animationLoop );

    const controls = new OrbitControls( camera, canvas );
    controls.enableDamping = true;

    const light = new DirectionalLight(0xffffff, 1);
    light.position.set(0, 4, 0);
    scene.add(light);
    scene.add(new AmbientLight(0xffffff, .75));

    class Atom {
        constructor(parent, position, {
            radius = 0.175,
            color = 0xffcc11,
            visible = false,
            mass = 1
        } = {}) {

            this._ball = new Ball(parent, {
                position: position.clone(),
                radius: radius,
                mass: mass,
                color: color,
                opacity: visible ? 1 : 0,
            });

            this._visible = visible;
            this._force = new Vector3();
            this._neighbors = [];
        }

        appendNeighbor(atom) { this._neighbors.push(atom); }

        updateForce() {
            this._force.set(0, 0, 0);
            const k = 1000;
            const leq = 1;

            for (const atom of this._neighbors) {
                const delta = atom.position.clone().sub(this.position);
                const stretch = delta.length() - leq;
                this._force.add(delta.normalize().multiplyScalar(k * stretch));
            }
        }

        update(dt) {
            if (!this._visible) return;
            this._ball.semiImplicitEulerUpdate(this._force, dt);
        }

        shiftBy(displacement) { this._ball.moveTo(this.position.clone().add(displacement)); }
        get visible() { return this._visible; }
        get position() { return this._ball.position; }
    }

    class Lattice {
        constructor(parent, nrows = 2) {
            this._atoms = [];
            this._bonds = [];

            nrows += 2;
            const half = Math.floor(nrows / 2);

            this.#createLattice(parent, half);
            this.#determineNeighbors(parent);
        }

        #createAtom(parent, x, y, z, half) {
            const visible =
                Math.abs(x) !== half &&
                Math.abs(y) !== half &&
                Math.abs(z) !== half;

            const atom = new Atom(parent, new Vector3(x, y, z), { visible });
            this._atoms.push(atom);
        }

        #createLattice(parent, half) {
            for (let z = -half; z < half; z++)
                for (let y = -half; y < half; y++)
                    for (let x = -half; x < half; x++)
                        this.#createAtom(parent, x, y, z, half);
        }

        #isNeighbor(atom, other) {
            const delta = atom.position.clone().sub(other.position);
            return delta.equals(new Vector3(1, 0, 0)) ||
                delta.equals(new Vector3(-1, 0, 0)) ||
                delta.equals(new Vector3( 0, 1, 0)) ||
                delta.equals(new Vector3(0, -1, 0)) ||
                delta.equals(new Vector3( 0, 0, 1)) ||
                delta.equals(new Vector3(0, 0, -1));
        }

        #createBond(parent, atom, other) {
            this._bonds.push(new Bond(parent, atom, other, {
                k: 1000,
                color: "white",
                radius: 0.175,
                coils: 25,
                type: Bond.Type.CYLINDER,
                coilRadius: 0.1 * 0.05 // TODO atomA.ball._sphere.radius * 0.5
            }));
        }

        #determineNeighbors(parent) {
            for (const atom of this._atoms)
                for (const other of this._atoms)
                    if (this.#isNeighbor(atom, other)) {
                        atom.appendNeighbor(other);
                        if (atom.visible && other.visible)
                            this.#createBond(parent, atom, other);
                    }
        }

        update(dt, time) {
            for (const atom of this._atoms)
                atom.updateForce();

            for (const atom of this._atoms)
                atom.update(dt);

            for (const bond of this._bonds)
                bond.update(time);
        }

        changeBondType(type) {
            for (let bond of this._bonds)
                bond.changeBondType(type);
            this.update(0, 0);
        }

        moveAtom(index, displacement) {
            this._atoms[index].shiftBy(displacement);
        }
    }

    let running = true;
    const toggleButton = document.getElementById("pauseButton");
    toggleButton.onclick = () => {
        running = !running;
        toggleButton.innerHTML = running ? "&nbsp;Pause&nbsp;" : "Resume";
    }
    let bondType = Bond.Type.CYLINDER;
    const bondTypeButton = document.getElementById("bondTypeButton");
    bondTypeButton.onclick = () => {
        bondType = bondType === Bond.Type.CYLINDER ? Bond.Type.SPRING : Bond.Type.CYLINDER;
        bondTypeButton.innerHTML = bondType === Bond.Type.SPRING ? "&nbsp;Bonds as rods&nbsp;" : "Bonds as springs";
        lattice.changeBondType(bondType);
    }

    const lattice = new Lattice(scene);
    lattice.moveAtom(26, new Vector3(0, 0, 0.2));
    const dt = 0.01;
    function animationLoop(time) {
        if (running)
            lattice.update(dt, time * 0.001);
        renderer.render(scene, camera);
    }

</script>