<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.175.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.175.0/examples/jsm/"
      }
    }
</script>

<canvas id="myCanvas" width="600" height="600" style="border: none;"></canvas>
<script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    const vector = THREE.Vector3;
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x191919);

    const canvas = document.getElementById('myCanvas');
    canvas.focus();
    const canvasWidth = canvas.getAttribute('width');
    const canvasHeight = canvas.getAttribute('height');

    const camera = new THREE.PerspectiveCamera(75, canvasWidth/canvasHeight, 0.1, 1000);
    camera.position.z = 35;

    const renderer = new THREE.WebGLRenderer( {antialias: true, canvas: canvas} );
    renderer.setSize( canvasWidth, canvasHeight );

    const light1 = new THREE.DirectionalLight(0xffffff, 1);
    light1.position.set(12, 12, 12);
    scene.add(light1);
    const light2 = new THREE.DirectionalLight(0xffffff, 1);
    light2.position.set(-12, 12, -12);
    scene.add(light2);

    const controls = new OrbitControls(camera, canvas);
    controls.target.set(0, 0, 0);
    controls.update();

    class Dna {
        static bondMaterial = new THREE.MeshLambertMaterial({
            color: 0x2e50ac,
            emissive: 0x2e50ac,
            emissiveIntensity: 0.4
        });
        static redMaterial = new THREE.MeshLambertMaterial({
            color: new THREE.Color(0xff0000),
            emissive: 0xff0000,
            emissiveIntensity: 0.1
        });
        static blueMaterial = new THREE.MeshLambertMaterial({
            color: new THREE.Color(0x0000ff),
            emissive: 0x0000ff,
            emissiveIntensity: 0.1
        });
        static greenMaterial = new THREE.MeshLambertMaterial({
            color: new THREE.Color(0x00ff00),
            emissive: 0x00ff00,
            emissiveIntensity: 0.1
        });
        static yellowMaterial = new THREE.MeshLambertMaterial({
            color: new THREE.Color(0xffff00),
            emissive: 0xffff00,
            emissiveIntensity: 0.1
        });

        static leftPhosphateBackboneMaterial = new THREE.MeshLambertMaterial({
            color: 0xff00ff,
            emissive: 0xff00ff,
            emissiveIntensity: 0.4
        });
        static rightPhosphateBackboneMaterial = new THREE.MeshLambertMaterial({
            color: 0x00ffff,
            emissive: 0x00ffff,
            emissiveIntensity: 0.4
        });

        constructor() {
            const bondGeometry = new THREE.CylinderGeometry(0.3, 0.3, 10, 32);
            const moleculeGeometry = new THREE.SphereGeometry(1.2, 32, 32);

            this.dna = new THREE.Object3D();
            let lastLeftWorld = null;
            let lastRightWorld = null;
            for (let i = 0; i <= 20; i++) {
                const lastPositions = this.createNucleotidePair(bondGeometry, i, moleculeGeometry, lastLeftWorld, lastRightWorld);
                lastLeftWorld = lastPositions[0];
                lastRightWorld = lastPositions[1];
            }
            this.dna.position.y = -20;
            scene.add(this.dna);
        }

        createNucleotidePair(bondGeometry, i, moleculeGeometry, lastLeftWorld, lastRightWorld) {
            const cylinder = new THREE.Mesh(bondGeometry, Dna.bondMaterial);
            cylinder.rotation.z = 90 * Math.PI / 180;
            cylinder.position.x = 0;
            let {ballRight, ballLeft} = this.nucleotides(i, moleculeGeometry);

            ballRight.position.x = 6;
            ballLeft.position.x = -5;

            const bondBetweenBalls = this.createBondBetween(ballLeft.position, ballRight.position, Dna.bondMaterial);
            const row = this.addBondToDna(bondBetweenBalls, ballRight, ballLeft, i);

            const {
                currentLeftWorld,
                currentRightWorld
            } = this.createPhosphateBackboneBonds(row, ballLeft, ballRight, lastLeftWorld, lastRightWorld);

            return [currentLeftWorld, currentRightWorld];
        }

        addBondToDna(bondBetweenBalls, ballRight, ballLeft, i) {
            const row = new THREE.Object3D();
            row.add(bondBetweenBalls);
            row.add(ballRight);
            row.add(ballLeft);
            row.position.y = i * 2;
            row.rotation.y = 30 * i * Math.PI / 180;
            this.dna.add(row);
            return row;
        }

        createPhosphateBackboneBonds(row, ballLeft, ballRight, lastLeftWorld, lastRightWorld) {
            row.updateMatrixWorld(true);
            const currentLeftWorld = new vector();
            const currentRightWorld = new vector();
            ballLeft.getWorldPosition(currentLeftWorld);
            ballRight.getWorldPosition(currentRightWorld);

            if (lastLeftWorld && lastRightWorld) {
                const leftBackbone = this.createBondBetween(lastLeftWorld, currentLeftWorld, Dna.leftPhosphateBackboneMaterial, 0.15);
                const rightBackbone = this.createBondBetween(lastRightWorld, currentRightWorld, Dna.rightPhosphateBackboneMaterial, 0.15);
                this.dna.add(leftBackbone);
                this.dna.add(rightBackbone);
            }
            return {currentLeftWorld, currentRightWorld};
        }

        nucleotides(i, moleculeGeometry) {
            let ballRight, ballLeft;
            if (i % 4 === 0) {
                ballRight = new THREE.Mesh(moleculeGeometry, Dna.yellowMaterial);
                ballLeft = new THREE.Mesh(moleculeGeometry, Dna.blueMaterial);
            } else if (i % 4 === 1) {
                ballRight = new THREE.Mesh(moleculeGeometry, Dna.greenMaterial);
                ballLeft = new THREE.Mesh(moleculeGeometry, Dna.redMaterial);
            } else if (i % 4 === 2) {
                ballRight = new THREE.Mesh(moleculeGeometry, Dna.blueMaterial);
                ballLeft = new THREE.Mesh(moleculeGeometry, Dna.yellowMaterial);
            } else {
                ballRight = new THREE.Mesh(moleculeGeometry, Dna.redMaterial);
                ballLeft = new THREE.Mesh(moleculeGeometry, Dna.greenMaterial);
            }
            return {ballRight, ballLeft};
        }

        createBondBetween(pointA, pointB, material, radius = 0.2) {
            const direction = new vector().subVectors(pointB, pointA);
            const length = direction.length();
            const midPoint = new vector().addVectors(pointA, pointB).multiplyScalar(0.5);
            const bondGeometry = new THREE.CylinderGeometry(radius, radius, length, 16);
            const bond = new THREE.Mesh(bondGeometry, material);

            // Orient the bond to face between the points
            bond.position.copy(midPoint);
            bond.quaternion.setFromUnitVectors(
                new vector(0, 1, 0), // default cylinder orientation
                direction.clone().normalize()
            );

            return bond;
        }

        rotateY() {
            this.dna.rotation.y += 0.01;
        }
    }

    const dna = new Dna();
    function render() {
        requestAnimationFrame(render);
        dna.rotateY();
        renderer.render(scene, camera);
    }

    render();
</script>