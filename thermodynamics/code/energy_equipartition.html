<!-- https://discourse.threejs.org/t/how-to-update-the-endpoints-of-a-cylinder/49853/2 -->
<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<link href="https://unpkg.com/uplot/dist/uPlot.min.css" rel="stylesheet">
<script src="https://unpkg.com/uplot/dist/uPlot.iife.min.js"></script>


<canvas class="applicationCanvas" id="simulationCanvas"></canvas><br/>
<div id="energyPlot" style="margin:auto;"></div>
<p style="clear: both;"></p>
<div class="buttonRow">
    <label for="temperatureSlider">Temperatuur (K): </label>
    <input type="range" id="temperatureSlider" min="100" max="1000" value="298" step="1">
    <span id="temperatureValue">298</span> K
</div>

<script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // Simulation constants
    const SCALE = 1e10; // For display
    const MOLECULES_COUNT = 20;
    const one_third = 1. / 3.;
    const L = ((24.4E-3 / 6E23) * MOLECULES_COUNT) ** one_third / 50; // 2L is the length of the cubic container box

    console.clear( );
    const scene = new THREE.Scene();
    const vector = THREE.Vector3;

    const canvas = document.getElementById('simulationCanvas');
    canvas.focus();
    const canvasWidth = canvas.clientWidth;
    const canvasHeight = canvas.clientHeight;

    const camera = new THREE.PerspectiveCamera(60, canvasWidth/canvasHeight, 0.1, 1000);
    camera.position.set(2 * L * SCALE, 2 * L * SCALE, 2 * L * SCALE);
    camera.updateProjectionMatrix();

    const renderer = new THREE.WebGLRenderer( {antialias: true, canvas: canvas, alpha: true} );
    renderer.setSize( canvasWidth, canvasHeight );
    renderer.setAnimationLoop( animationLoop );

    const controls = new OrbitControls( camera, canvas );
    controls.enableDamping = true;

    let light = new THREE.DirectionalLight(0xffffff, .75);
    light.position.set(1, 2, 3).setLength(1);
    scene.add(light, new THREE.AmbientLight(0xffffff, .5));

    // --- Box ---
    const geometry = new THREE.BoxGeometry(2 * L * SCALE, 2 * L * SCALE, 2 * L * SCALE);
    const material = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0, .78, .78),
        transparent: true,
        opacity: 0.35,
        depthWrite: false
    });
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    class Atom {
        constructor(parent, position, initialSpeed, mass, radius=0.1, colour=new THREE.Color(0xffffff), opacity=1) {
            this._velocity = new vector().random().multiplyScalar(initialSpeed);
            this._position = position;
            this._mass = mass;
            this._radius = radius;

            const geometry = new THREE.SphereGeometry(radius * SCALE);
            const material = new THREE.MeshStandardMaterial({ color: colour, opacity: opacity });
            this._mesh = new THREE.Mesh(geometry, material);
            this._mesh.position.copy(position).multiplyScalar(SCALE);
            parent.add(this._mesh);
        }

        check_box_bounce(boxLength) {
            ["x","y","z"].forEach(axis => {
                if (Math.abs(this.position[axis]) >= boxLength - this.radius && this.position[axis] * this.velocity[axis] >= 0)
                    this._velocity[axis] = -this.velocity[axis];
            });
        }

        time_lapse(bond_force, dt) {
            const acceleration = bond_force.clone().divideScalar(this.mass);
            this._velocity.addScaledVector(acceleration, dt);
            this._position.addScaledVector(this._velocity, dt);
            this._mesh.position
                .copy(this._position)
                .multiplyScalar(SCALE);
        }

        resolveCollision(otherAtom) {
            const delta = otherAtom.position.clone().sub(this.position);
            const dist = delta.length();
            const minDist = this.radius + otherAtom.radius;

            if (dist >= minDist) return;

            const normal = delta.clone().divideScalar(dist);

            // ---- Position-correction (prevents sticking)
            const overlap = minDist - dist;
            const totalMass = this.mass + otherAtom.mass;

            this._position.addScaledVector(normal, -overlap * (otherAtom.mass / totalMass));
            otherAtom._position.addScaledVector(normal,  overlap * (this.mass / totalMass));

            // ---- Relative velocity
            const relVel = otherAtom.velocity.clone().sub(this.velocity);
            const velAlongNormal = relVel.dot(normal);

            if (velAlongNormal > 0) return; // moving away from each other

            // ---- Elastic collision
            const restitution = 1.0; // perfect elastic

            const impulseMag = -(1 + restitution) * velAlongNormal / (1 / this.mass + 1 / otherAtom.mass);
            const impulse = normal.clone().multiplyScalar(impulseMag);

            this._velocity.addScaledVector(impulse, -1 / this.mass);
            otherAtom._velocity.addScaledVector(impulse,  1 / otherAtom.mass);
        }

        scaleVelocityWith(scaleFactor) { this._velocity.multiplyScalar(scaleFactor); }
        momentum() { return this.mass * this.velocity }
        moveTo(newPosition) { this._position.copy(newPosition); }
        get mass() { return this._mass; }
        get radius() { return this._radius; }
        get position() { return this._position; }
        get velocity() { return this._velocity; }
        positionVectorTo(other) { return other.position.clone().sub(this.position); }
        distanceToSquared(other) { return this.position.distanceToSquared(other.position); }
        distanceTo(other) { return this.position.distanceTo(other.position); }
    }

    class Bond {
        constructor(parent, atom1, atom2, colour=new THREE.Color(0xface8d), k_bond=18600.0) {
            this._atom1 = atom1;
            this._atom2 = atom2;
            this._bondConstant = k_bond;

            const geometry = new THREE.CylinderGeometry(
                atom1.radius * .5 * SCALE,
                atom2.radius * .5 * SCALE,
                1
            );
            const material = new THREE.MeshLambertMaterial({color: colour});
            this._mesh = new THREE.Mesh(geometry, material);
            this.update();
            parent.add(this._mesh);
        }

        get bondConstant() { return this._bondConstant; }

        update() {
            const p1 = this._atom1.position.clone();
            const p2 = this._atom2.position.clone();

            const mid = p1.clone().add(p2).multiplyScalar(0.5);
            const direction = p2.clone().sub(p1);
            const length = direction.length();

            this._mesh.position.copy(mid).multiplyScalar(SCALE); // Update position
            this._mesh.scale.set(1, length * SCALE, 1); // Cylinder/bond length (is one high by default)

            // orientation: rotate Y-axes to bond vector
            const axis = new THREE.Vector3(0, 1, 0);
            this._mesh.quaternion.setFromUnitVectors(axis, direction.clone().normalize());
        }
    }

    class CarbonMonoxide extends THREE.Group {
        constructor(pos, initialSpeed) {
            super();
            const radius = 31E-12;
            const distance = 2.5 * radius;
            const axis = new vector(distance, 0, 0);
            const oxygenMass=16E-23, carbonMass=12E-23;
            this._oxygen = new Atom(this, pos, initialSpeed, oxygenMass, radius, new THREE.Color(0xff0000));
            this._carbon = new Atom(this, axis.add(pos), initialSpeed, carbonMass, radius, new THREE.Color(0x0000ff));
            this._bond = new Bond(this, this._oxygen, this._carbon);
            this._restLength = 2.5 * radius;
        }

        update(startPosition, endPosition) {
            this._oxygen.moveTo(startPosition);
            this._carbon.moveTo(endPosition);
            this._bond.update();
        }

        timeLapse(dt) {
            const forceOnOxygen = this.bondForceOnOxygen();
            const forceOnCarbon = forceOnOxygen.clone().negate();

            this._oxygen.time_lapse(forceOnOxygen, dt);
            this._carbon.time_lapse(forceOnCarbon, dt);

            this._bond.update();
        }

        checkBoxBounce(boxLength) {
            this._oxygen.check_box_bounce(boxLength);
            this._carbon.check_box_bounce(boxLength);
        }

        bondForceOnOxygen() {
            const axis = this._carbon.position.clone().sub(this._oxygen.position);
            const length = axis.length();
            const stretch = length - this._restLength;
            return axis.normalize().multiplyScalar(this._bond.bondConstant * stretch);
        }

        resolveCollisionWith(otherMolecule) {
            this._oxygen.resolveCollision(otherMolecule._oxygen);
            this._oxygen.resolveCollision(otherMolecule._carbon);
            this._carbon.resolveCollision(otherMolecule._oxygen);
            this._carbon.resolveCollision(otherMolecule._carbon);
        }

        translationalKE() {
            return 0.5 * this.mass * this.comVelocity().lengthSq();
        }

        vibrationalKE() {
            // Project velocities along the bond axis
            const bondAxis = this._carbon.position.clone().sub(this._oxygen.position).normalize();
            const comVel = this.comVelocity();

            const velocityCarbon = this._carbon.velocity.clone().sub(comVel);
            const velocityOxygen = this._oxygen.velocity.clone().sub(comVel);

            const velocityCarbon_along = velocityCarbon.dot(bondAxis);
            const velocityOxygen_along = velocityOxygen.dot(bondAxis);

            return 0.5 * this._carbon.mass * velocityCarbon_along ** 2 + 0.5 * this._oxygen.mass * velocityOxygen_along ** 2;
        }

        vibrationalPE() {
            const length = this._carbon.position.clone().sub(this._oxygen.position).length();
            const stretch = length - this._restLength;
            return 0.5 * this._bond.bondConstant * stretch * stretch;
        }

        rotationalKE() {
            // Rotation around the center of mass
            const comVel = this.comVelocity();
            const bondAxis = this._carbon.position.clone().sub(this._oxygen.position);

            const velocityCarbon_perp = this._carbon.velocity.clone()
                .sub(comVel).clone()
                .sub(bondAxis.clone()
                    .normalize()
                    .multiplyScalar(
                        this._carbon.velocity.clone()
                            .sub(comVel)
                            .dot(bondAxis.clone().normalize())
                    )
                );

            const velocityOxygen_perp = this._oxygen.velocity.clone()
                .sub(comVel).clone()
                .sub(bondAxis.clone()
                    .normalize()
                    .multiplyScalar(
                        this._oxygen.velocity.clone()
                            .sub(comVel)
                            .dot(bondAxis.clone().normalize())
                    )
                );

            return 0.5 * this._carbon.mass * velocityCarbon_perp.lengthSq() + 0.5 * this._oxygen.mass * velocityOxygen_perp.lengthSq();
        }

        comVelocity() {
            return this._carbon.velocity.clone()
                .multiplyScalar(this._carbon.mass)
                .add(this._oxygen.velocity.clone().multiplyScalar(this._oxygen.mass))
                .divideScalar(this.mass);
        }

        scaleVelocityWith(scaleFactor) {
            this._carbon.scaleVelocityWith(scaleFactor);
            this._oxygen.scaleVelocityWith(scaleFactor);
        }

        get mass() { return this._carbon.mass + this._oxygen.mass; }
    }

    class CarbonMonoxideGas extends THREE.Group {
        constructor(moleculeCount=MOLECULES_COUNT, temperature=298, boxSize=L) {
            super();
            this._molecules = [];
            this._boxSize = boxSize;
            this._temperature = temperature;
            const mass = 14E-3 / 6E23; // Average mass of Oxygen and Carbon
            const k = 1.38E-23; // Boltzmann constant
            for (let i = 0; i < moleculeCount; i++) {
                const pos = new vector(Math.random() -.5, Math.random() -.5, Math.random() -.5).multiplyScalar(boxSize);
                const molecule = new CarbonMonoxide(pos, Math.sqrt(3 * k * temperature / mass));
                this._molecules.push(molecule);
                this.add(molecule);
            }
        }

        update(dt) {
            for (let molecule of this._molecules) {
                molecule.timeLapse(dt);
                molecule.checkBoxBounce(this._boxSize);
            }

            for (let i = 0; i < this._molecules.length; i++)
                for (let j = i + 1; j < this._molecules.length; j++)
                    this._molecules[i].resolveCollisionWith(this._molecules[j]);
        }

        updateToNewTemperature(newTemperature) {
            // Modify the speed of all molecules according to equipartition: v ~ sqrt(T)
            const scaleFactor = Math.sqrt(newTemperature / this._temperature); // ratio new temp / old temp
            for (let molecule of this._molecules)
                molecule.scaleVelocityWith(scaleFactor);
            this._temperature = newTemperature;
        }

        translationalKE() { return this._molecules.reduce((sum, m) => sum + m.translationalKE(), 0); }
        vibrationalKE() { return this._molecules.reduce((sum, m) => sum + m.vibrationalKE(), 0); }
        vibrationalPE() { return this._molecules.reduce((sum, m) => sum + m.vibrationalPE(), 0); }
        rotationalKE() { return this._molecules.reduce((sum, m) => sum + m.rotationalKE(), 0); }
    }

    const opts = {
        title: "Kinetic Energy vs Time",
        width: canvas.clientWidth,
        height: canvas.clientHeight * .5,
        bg: "transparent",
        scales: { x: { auto: true }, y: { auto: true } },
        axes: [
            {
                stroke: "#ff0",
                font: "12px Arial",
                grid: {stroke: "rgba(255, 255, 255, 0.2)", width: 1},
                label: "Time [ps]", values: (u, values) => values.map(value=> value.toFixed(2))
            },
            {
                stroke: "#ff0",
                font: "12px Arial",
                grid: {stroke: "rgba(255, 255, 255, 0.2)", width: 1},
                label: "KE [J]", values: (u, values) => values.map(value => value.toExponential(2))
            }
        ],
        series: [
            { label: "t" },
            { label: "Translational KE", stroke: "green" },
            { label: "Vibrational PE", stroke: "red" },
            { label: "Vibrational KE", stroke: "cyan" },
            { label: "Rotational KE", stroke: "yellow" }
        ]
    };

    const gas = new CarbonMonoxideGas();
    scene.add(gas);
    const energyData = { time: [], translational: [], vPE: [], vKE: [], rotational: [] };
    const uplotChart = new uPlot(opts, [energyData.time, energyData.translational, energyData.vPE, energyData.vKE, energyData.rotational], document.getElementById("energyPlot"));

    const tempSlider = document.getElementById("temperatureSlider");
    const tempValueLabel = document.getElementById("temperatureValue");
    tempSlider.addEventListener("input", () => {
        const newTemperature = parseFloat(tempSlider.value) + "";
        tempValueLabel.textContent = newTemperature;
        gas.updateToNewTemperature(newTemperature);
    });

    const dt = 5e-16;
    let t = 0,
        steps = 0,
        totalTranslational = 0,
        totalVibrationalKE = 0,
        totalVibrationalPE = 0,
        totalRotational = 0;

    function animationLoop() {
        for (let i = 0; i < 12; i++) {
            gas.update(dt);
            t += dt;

            totalTranslational += gas.translationalKE();
            totalVibrationalKE += gas.vibrationalKE();
            totalVibrationalPE += gas.vibrationalPE();
            totalRotational += gas.rotationalKE();
            steps++;
        }

        renderer.render(scene, camera);
        controls.update();

        if (steps % 120 === 0) {
            energyData.time.push(t * SCALE);
            energyData.translational.push(totalTranslational / steps);
            energyData.vPE.push(totalVibrationalPE / steps);
            energyData.vKE.push(totalVibrationalKE / steps);
            energyData.rotational.push(totalRotational / steps);
            uplotChart.setData([energyData.time, energyData.translational, energyData.vPE, energyData.vKE, energyData.rotational]);
        }
    }


</script>