<style>

    #canvas-wrapper {
        position: relative;
        width: 600px;
        height: 700px;
    }

    #myCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
    }

    #gui-container {
        position: absolute;
        bottom: 10px;      /* distance from the bottom of the canvas */
        left: 10px;          /* center horizontally */
        z-index: 20;
    }

    #surface-title {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        font-size: 24px;
        font-family: sans-serif;
        color: yellow;
        z-index: 10;  /* above canvas */
        pointer-events: none;
        font-weight: bold;
        text-shadow: 0 0 8px black;
    }

    #surface-equation {
        position: absolute;
        top: 50px;
        font-size: 14px;
        color: yellow;
        margin-left: 5px;
        margin-right: 10px;
        text-align: left;
        width: 600px;
        z-index: 10;  /* above canvas */
    }

    #surface-equation .mjx-chtml {
        display: block;                 /* make MathJax fill the div */
        max-width: 100%;
    }
</style>

<div id="canvas-wrapper">
    <div id="gui-container"></div>
    <div id="surface-title"></div>
    <div id="surface-equation"></div>
    <canvas id="myCanvas" width="600" height="700"></canvas>
</div>


<script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.0/lib/browser/math.js" type="text/javascript"></script>
<script type="module">
    import * as THREE from "https://cdn.skypack.dev/three@0.136.0";
    import { ParametricGeometry } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/geometries/ParametricGeometry";
    import { OrbitControls } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls";
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm";
    import { VertexNormalsHelper } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/helpers/VertexNormalsHelper.js";
    import { parse } from "https://cdn.jsdelivr.net/npm/mathjs@11.11.0/+esm";

    const canvas = document.getElementById("myCanvas"),
        width = canvas.width,
        height = canvas.height;

    const Category = Object.freeze({
        TOROID: "Toroid",
        BASIC: "Basic",
        SPIRAL: "Spiral",
        MISC: "Miscellaneous"
    });

    const ColorModes = {
        HEIGHT: "Height",
        BASE: "Base",
        CURVATURE_1: "Curvature 1",
        CURVATURE_2: "Curvature 2"
    }

    const params = {
        frequency: 0.5,
        baseColor: "#4f6",
        colorMode: ColorModes.HEIGHT,
        wireframe: false,
        axes: true,
        normals: false,
        animate: false,
        resolution: 75,
        opacity: 0.9,
        category: Category.TOROID
    }

    const surfaceDefinitions = [{
        meta: {name: "Bow curve", category: Category.TOROID},
        definition: {
            xFn: "(1 * sin(x) + 2) * sin(y)",
            yFn: "(1 * sin(x) + 2) * cos(y)",
            zFn: "1 * cos(x) + 2 * cos(1/2 * y)"
        },
        intervals: [["0", "2 * pi"], ["4 * pi", "0"]]
    }, {
        meta: {name: "Elliptic torus", category: Category.TOROID},
        definition: {
            xFn: "(1 * cos(y) + 3) * cos(x)",
            yFn: "1 * (cos(y) + sin(y))",
            zFn: "(1 * cos(y) + 3) * sin(x)"
        },
        intervals: [["0", "2 * pi"], ["2 * pi", "0"]]
    }, {
        meta: {name: "Cosine", category: Category.MISC},
        definition: {
            xFn: "cos(x)",
            yFn: "cos(y)",
            zFn: "cos(x + y)"
        },
        intervals: [["0", "2 * pi"], ["2 * pi", "0"]]
    }, {
        meta: {name: "Sine", category: Category.MISC},
        definition: {
            xFn: "sin(x)",
            yFn: "sin(y)",
            zFn: "sin(x + y)"
        },
        intervals: [["0", "2 * pi"], ["2 * pi", "0"]]
    }, {
        meta: {name: "Torus", category: Category.TOROID},
        definition: {
            xFn: "cos(x) * (3 + 1.5 * cos(y))",
            yFn: "1.5 * sin(y)",
            zFn: "sin(x) * (3 + 1.5 * cos(y))"
        },
        intervals: [["0", "2 * pi"], ["2 * pi", "0"]]
    }, {
        meta: {name: "Trefoil knot", category: Category.TOROID},
        definition: {
            xFn: "(4 * (1 + 1/4 * sin(3 * y)) + cos(x)) * cos(2 * y)",
            yFn: "(4 * (1 + 1/4 * sin(3 * y)) + cos(x)) * sin(2 * y)",
            zFn: "sin(x) + 2 * cos(3 * y)"
        },
        intervals: [["0", "2 * pi"], ["2 * pi", "0"]]
    },{
        meta: {name: "Twisted torus", category: Category.TOROID},
        definition: {
            xFn: "(2 + sin(y) + cos(x)) * cos(2 * y)",
            yFn: "(2 + sin(y) + cos(x)) * sin(2 * y)",
            zFn: "sin(x) + 3 * cos(y)"
        },
        intervals: [["0", "2 * pi"], ["2 * pi", "0"]]
    }];

    function functionFrom(xyFunctionString) {
        try {
            return (x, y) => math.compile(xyFunctionString).evaluate({ x, y });
        } catch (err) {
            alert("Math.js parse error: " + err.message);
            return null;
        }
    }

    class Scenery {
        constructor(scene, worldGroup) {
            this.camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100);
            this.renderer = this.#createRenderer();
            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.scene = scene;

            this.controls.enableDamping = true;
            this.camera.position.set(6, 3, 6);
            this.scene.background = new THREE.Color(0x131313);

            this.scene.add(worldGroup);
            this.scene.add(this.#createDirectionalLight());
            this.scene.add(this.#createHemisphereLight());
        }

        #createHemisphereLight =
            (skyColour=0x87ceeb, groundColour=0x444444) => new THREE.HemisphereLight(skyColour, groundColour, 0.8);

        #createDirectionalLight() {
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 10, 7.5); // kind of "sunlight"
            directionalLight.castShadow = true; // Enable shadows
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            return directionalLight;
        }

        #createRenderer() {
            const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
            renderer.setSize(width, height);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            return renderer;
        }

        setSize(width, height) {
            this.renderer.setSize(width, height);
            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();
        }

        fitToBoundingBox(boundingBox, {
            padding = 1.5,
            minDistance = 2
        } = {}) {
            const size = new THREE.Vector3();
            let center = new THREE.Vector3();

            boundingBox.getSize(size);
            boundingBox.getCenter(center);

            const maxDim = Math.max(size.x, size.y, size.z);
            const verticalFieldOfView = THREE.MathUtils.degToRad(this.camera.fov);

            // distance so that bounding box is always in view
            let distance = maxDim / Math.tan(verticalFieldOfView / 2);
            distance = Math.max(distance * padding, minDistance);
            const direction = new THREE.Vector3(1, 1, 1).normalize(); // Matlab-like camera setting

            this.camera.position
                .copy(center)
                .addScaledVector(direction, distance);

            this.camera.near = distance / 100;
            this.camera.far  = distance * 10;
            this.camera.updateProjectionMatrix();

            // Smooth camera transitions
            // this.camera.position.lerp(targetPosition, 0.15);
            // this.controls.target.lerp(center, 0.15);

            this.controls.target.copy(center);
            this.controls.update();
        }

        render() {
            this.controls.update();
            this.renderer.render(this.scene, this.camera);
        }
    }

    class ControlsGui {
        constructor(scenery, surface, axes) {
            const controls = new GUI({width: 275, autoPlace: false});
            document.getElementById("gui-container").appendChild(controls.domElement);

            controls.add(params, 'category', Object.values(Category))
                .name("Category")
                .onChange(() => ring.changeActiveCategoryTo(params.category));

            const appearanceFolder = controls.addFolder("Appearance");
            appearanceFolder.add(params, "colorMode", Object.values(ColorModes)).name("Color Mode")
                .onChange(() => surface.requestColorUpdate());
            appearanceFolder.add(params, 'baseColor').name("Color").onChange(() => surface.requestColorUpdate());
            appearanceFolder.add(params, "resolution", 10, 200, 1).name("Resolution").onChange(resolution => {
                surface.rebuild(resolution)
            });

            appearanceFolder.add(params, "opacity", 0, 1, .01).name("Opacity").onChange(value => surface.setOpacity(value));
            appearanceFolder.add(params, 'wireframe').name("Wireframe").onChange(value => surface.toggleWireframe(value));
            appearanceFolder.add(params, 'axes').name("Axes").onChange(value => axes.show(value));
            appearanceFolder.add(params, 'normals').name('Show Normals').onChange(value => {
                surface.normalsVisible = value;
                if (surface.normalsHelper) surface.normalsHelper.visible = value;
            });
            appearanceFolder.add({reset: () => scenery.fitToBoundingBox(surface.getBoundingBox())}, "reset").name("Reset Camera");

            const animationFolder = controls.addFolder("Animation Controls");
            animationFolder.add(params, 'frequency', 0, 2).step(0.01).name("Frequency");
            animationFolder.add(params, 'animate').name("Animate");

            animationFolder.close();
            appearanceFolder.close();
        }
    }

    class MatlabAxes {
        constructor(parentGroup, axesSize=4, gridDivisions=10) {
            this.group = new THREE.Group();

            this.#createGrids(axesSize, gridDivisions);
            this.#createPlanes(axesSize);
            this.group.add(this.#createAxes(axesSize));

            // Group all helpers for easy visibility toggle
            parentGroup.add(this.group);
        }

        #createGrids(axesSize, gridDivisions) {
            const gridXZ = new THREE.GridHelper(axesSize, gridDivisions, 0x444444, 0x444444);
            gridXZ.rotation.x = Math.PI / 2;
            gridXZ.position.set(0, .5 * axesSize, -0.5 * axesSize);
            this.group.add(gridXZ);

            const gridYZ = new THREE.GridHelper(axesSize, gridDivisions, 0x444444, 0x444444);
            gridYZ.rotation.z = Math.PI / 2;
            gridYZ.position.set(-0.5 * axesSize, .5 * axesSize, 0);
            this.group.add(gridYZ);

            const gridXY = new THREE.GridHelper(axesSize, gridDivisions, 0x444444, 0x444444);
            this.group.add(gridXY);
        }

        #createPlanes(axesSize) {
            const planeXZ = this.#createPlane(axesSize, 0, 0, 0);
            planeXZ.rotation.x = -Math.PI / 2;

            const planeYZ = this.#createPlane(axesSize, -0.5, 0.5, 0);
            planeYZ.rotation.y = -Math.PI / 2;

            this.#createPlane(axesSize, 0, 0.5, -0.5);
        }

        #createAxes(axesSize) {
            const eps = .025
            const axesHelper = new THREE.AxesHelper(axesSize);
            axesHelper.position.set(-.5 * axesSize + eps, eps, -.5 * axesSize +eps);
            return axesHelper;
        }

        #createPlane(size, x, y, z, opacity=0.2, color=0x888888) {
            const material = new THREE.MeshPhongMaterial({
                color: color,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: opacity,
                depthWrite: false // ensures grid lines appear on top
            });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(size, size), material);
            mesh.position.set(x * size, y * size, z * size);
            this.group.add(mesh);
            return mesh;
        }

        show = (value) => this.group.visible = value;

        // repositionToSurface(surface) {
        //     const box = surface.getBoundingBox();
        //     const size = new THREE.Vector3();
        //     box.getSize(size);
        //     const center = new THREE.Vector3();
        //     box.getCenter(center);
        //
        //     // Shift axes so bottom of surface is at y = 0
        //     this.group.position.set(0, center.y - size.y / 2, 0);
        // }

        // rebuildFrom(boundingBox, marginFactor=1.15) {
        //     this.group.clear();
        //
        //     const size = new THREE.Vector3();
        //     boundingBox.getSize(size);
        //
        //     const max = Math.max(size.x, size.y, size.z);
        //     const axesSize = max * marginFactor; // axes just a fraction bigger than the object
        //
        //     this.#createGrids(axesSize, 10);
        //     this.#createPlanes(axesSize);
        //     this.group.add(this.#createAxes(axesSize));
        // }
    }

    class Interval {
        constructor(from=-Infinity, to=Infinity) {
            this.from = from;
            this.to = to;
        }

        shrinkTo(value) {
            if (this.from < value) this.from = value;
            if (this.to > value) this.to = value;
        }

        scaleValue = (value) => this.to !== this.from ? (value - this.from) / this.range() : 0;
        range = () => (this.from === Infinity || this.to === Infinity) ? Infinity : this.to - this.from;
        scaleParameter = (a) => this.range() * (a + this.from / this.range());
    }

    class SurfaceDefinition {
        sample(u, v, target) {
            throw new Error("sample() not implemented");
        }

        heightComponent(targetVec) { return targetVec.y; }
        usesGroundLifting() { return true; }
    }

    class Surface {
        constructor(parentGroup, {
            resolution = 75,
            showWireframe = false,
            definition    // must be a SurfaceDefinition instance
        }) {
            this.definition = definition;       // GraphSurfaceDefinition or TorusDefinition
            this.parentGroup = parentGroup;
            this.time = 0;
            this.normalsHelper = null;
            this.geometry = null;
            this.mesh = null;
            this.normalsVisible = false;
            this.colorsDirty = true;
            this.geometryScale = 1;

            this.surfaceFunction = (u, v, target) => this.definition.sample(u, v, target);
            this.#buildGeometry(resolution, showWireframe);

            if (this.definition.usesGroundLifting()) this.#liftSurfaceAboveGroundLevel();
        }

        #liftSurfaceAboveGroundLevel() {
            const position = this.geometry.attributes.position;
            const yMin = this.getBoundingBox().min.y;
            for (let i = 0; i < position.count; i++)
                position.setY(i, position.getY(i) - yMin);

            position.needsUpdate = true;
            this.geometry.computeVertexNormals();
            if (this.normalsHelper && this.normalsHelper.visible) this.normalsHelper.update();
        }

        #magnitudeOfNormalChange = (nx, ny, nz) => Math.sqrt(nx*nx + ny*ny + nz*nz);

        #deviationFromYAxis = (nx, ny, nz) => 1 - Math.abs(ny);

        #computeCurvature(curvatureAlgorithm) {
            const posAttr = this.geometry.attributes.position;
            const normAttr = this.geometry.attributes.normal;
            const curvatures = new Float32Array(posAttr.count);

            for (let i = 0; i < posAttr.count; i++)
                curvatures[i] = curvatureAlgorithm(normAttr.getX(i), normAttr.getY(i), normAttr.getZ(i));

            return curvatures;
        }

        #buildGeometry(resolution, showWireframe) {
            this.geometry = new ParametricGeometry(
                (u, v, target) => this.surfaceFunction(u, v, target),
                resolution, resolution
            );

            const colors = new Float32Array(this.geometry.attributes.position.count * 3);
            this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            if (this.mesh) {
                this.parentGroup.remove(this.mesh);
                this.#removeNormalsHelper();
                this.geometry.dispose();
            }

            this.mesh = new THREE.Mesh(this.geometry, this.#material(showWireframe));
            this.parentGroup.add(this.mesh);

            this.#addNormalsHelper();
            this.#updateColors();
        }

        #addNormalsHelper() {
            this.normalsHelper = new VertexNormalsHelper(this.mesh, 0.25, 0x770000);
            this.normalsHelper.visible = this.normalsVisible;
            this.parentGroup.add(this.normalsHelper);
        }

        #removeNormalsHelper() {
            if (this.normalsHelper) {
                this.parentGroup.remove(this.normalsHelper);
                this.normalsHelper.geometry.dispose();
                this.normalsHelper.material.dispose();
                this.normalsHelper = null;
            }
        }

        #updateGeometry() {
            const posAttr = this.geometry.attributes.position;
            const uvAttr  = this.geometry.attributes.uv;
            this._tempVec ??= new THREE.Vector3();
            const temp = this._tempVec;

            const scale = this.geometryScale;
            const amplitude = this.#amplitudeModulation(this.time);
            for (let i = 0; i < posAttr.count; i++) {
                const u = uvAttr.getX(i);
                const v = uvAttr.getY(i);

                this.surfaceFunction(u, v, temp);
                posAttr.setXYZ(i, scale * temp.x, scale * temp.y * amplitude, scale * temp.z);
            }

            posAttr.needsUpdate = true;
            this.geometry.computeVertexNormals();

            if (this.normalsHelper) this.normalsHelper.update();
        }

        #amplitudeModulation = (t) => (1.01 - Math.cos(t * params.frequency + Math.PI)) * .5

        #material(showWireframe) {
            return new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                wireframe: showWireframe,
                transparent: true,
                opacity: params.opacity,
            });
        }

        #yMinMax() {
            const yRange = new Interval();
            const posAttr = this.geometry.attributes.position;
            const vec = new THREE.Vector3();

            for (let i = 0; i < posAttr.count; i++) {
                vec.x = posAttr.getX(i);
                vec.y = posAttr.getY(i);
                vec.z = posAttr.getZ(i);
                yRange.shrinkTo(this.definition.heightComponent(vec));
            }

            return yRange;
        }

        #updateColors() {
            const posAttr = this.geometry.attributes.position;
            const colors = this.geometry.attributes.color.array;
            const yRange = (params.colorMode === ColorModes.HEIGHT || params.colorMode === ColorModes.BASE)
                ? this.#yMinMax()
                : null;

            let curvature = null;
            if (params.colorMode === ColorModes.CURVATURE_1)
                curvature = this.#computeCurvature(this.#deviationFromYAxis);
            else if (params.colorMode === ColorModes.CURVATURE_2)
                curvature = this.#computeCurvature(this.#magnitudeOfNormalChange);

            for (let i = 0; i < posAttr.count; i++) {
                let color;
                const y = posAttr.getY(i);

                switch (params.colorMode) {
                    case ColorModes.HEIGHT:
                        color = this.#colorFromHeight(y, yRange);
                        break;
                    case ColorModes.BASE:
                        color = this.#colorFromHeight(y, yRange, true);
                        break;
                    case ColorModes.CURVATURE_1:
                    case ColorModes.CURVATURE_2:
                        color = this.#colorFromCurvature(curvature[i]);
                        break;
                }

                colors[3*i] = color.r;
                colors[3*i+1] = color.g;
                colors[3*i+2] = color.b;
            }

            this.geometry.attributes.color.needsUpdate = true;
        }

        #colorFromHeight(y, yRange, useBaseColor=false) {
            const t = yRange.scaleValue(y);
            const color = new THREE.Color();
            const hsl = {};

            if (useBaseColor && this.#isValidColor(params.baseColor)) {
                color.setStyle(params.baseColor);
                color.getHSL(hsl);
                hsl.l = 0.4 + 0.3 * (1 - t);
            } else {
                hsl.h = t * 0.5 - 0.025;
                hsl.s = 0.9;
                hsl.l = 0.4 + 0.2 * (1 - t);
            }

            color.setHSL(hsl.h, hsl.s, hsl.l);
            return color;
        }

        #colorFromCurvature(k) {
            const color = new THREE.Color();
            const t = THREE.MathUtils.clamp(k * 500, 0, 1); // zichtbare schaal

            if (params.baseColor && this.#isValidColor(params.baseColor)) {
                color.setStyle(params.baseColor);
                const hsl = {};
                color.getHSL(hsl);
                hsl.l = 0.4 + 0.4 * (1 - t);
                hsl.s = 0.5 + 0.5 * (1 - t);
                color.setHSL(hsl.h, hsl.s, hsl.l);
            } else
                color.setHSL(0.6 - 0.6*t, 0.9, 0.5);

            return color;
        }

        #isValidColor(str) {
            const s = new Option().style;
            s.color = str;
            return s.color !== '';
        }

        #updateColorsIfNeeded() {
            if (!this.colorsDirty) return;
            this.#updateColors();
            this.colorsDirty = false;
        }

        computeNormalizeScale(targetSize = 4) { // TODO magic number
            const box = this.getBoundingBox();
            const size = new THREE.Vector3();
            box.getSize(size);

            const maxDim = Math.max(size.x, size.y, size.z);
            this.geometryScale = targetSize / maxDim;
        }

        toggleWireframe = (value) => this.mesh.material.wireframe = value;

        setOpacity(opacity) {
            this.mesh.material.opacity = opacity;
            this.geometry.attributes.position.needsUpdate = true;
        }

        rebuild(resolution) {
            this.#buildGeometry(resolution, this.mesh.material.wireframe);
            if (this.definition.usesGroundLifting()) this.#liftSurfaceAboveGroundLevel();
            this.requestColorUpdate();
        }

        update(deltaTime) {
            this.#updateColorsIfNeeded();
            if (!params.animate) return;

            this.time += deltaTime;
            this.#updateGeometry();
            if (this.definition.usesGroundLifting()) this.#liftSurfaceAboveGroundLevel();
        }

        getBoundingBox() {
            this.geometry.computeBoundingBox();
            return this.geometry.boundingBox.clone();
        }

        getBoundingSphere() {
            this.geometry.computeBoundingSphere();
            return this.geometry.boundingSphere.clone();
        }

        updateToNew(surfaceUpdate = {}) {
            this.definition = surfaceUpdate;
            this.time = 0;
            this.surfaceFunction = (u, v, target) => this.definition.sample(u, v, target);
            this.rebuild(params.resolution);

            if (this.definition.usesGroundLifting()) this.#liftSurfaceAboveGroundLevel();
            this.requestColorUpdate();
        }

        normalizeToFit(size = 4) {
            const box = this.getBoundingBox();

            const boxSize = new THREE.Vector3();
            box.getSize(boxSize);

            const maxDim = Math.max(boxSize.x, boxSize.y, boxSize.z);
            const scale = size / maxDim;

            const pos = this.geometry.attributes.position;
            for (let i = 0; i < pos.count; i++)
                pos.setXYZ(i, pos.getX(i) * scale, pos.getY(i) * scale, pos.getZ(i) * scale);

            pos.needsUpdate = true;
            this.geometry.computeVertexNormals();

            if (this.normalsHelper) this.normalsHelper.update();
        }

        requestColorUpdate = () => this.colorsDirty = true;
        show = () => this.mesh.material.visible = true;
        hide = () => this.mesh.material.visible = false;
        rotateBy = (delta) => this.mesh.rotation.y += delta;
        moveTo = (positionAsVector) => this.mesh.position.copy(positionAsVector);
    }

    class SurfaceTemplate extends SurfaceDefinition {
        constructor(surfaceFunctions, xInterval, yInterval) {
            super();
            this.surfaceFunctions = surfaceFunctions;
            this.xInterval = xInterval;
            this.yInterval = yInterval;

            this.xFnCompiled = functionFrom(surfaceFunctions.xFn);
            this.yFnCompiled = functionFrom(surfaceFunctions.yFn);
            this.zFnCompiled = functionFrom(surfaceFunctions.zFn);

            this.xInterval = new Interval(this.#evaluateConstant(xInterval[0]), this.#evaluateConstant(xInterval[1]));
            this.yInterval = new Interval(this.#evaluateConstant(yInterval[0]), this.#evaluateConstant(yInterval[1]));
        }

        #evaluateConstant = (exprString) => functionFrom(exprString)(0, 0);

        surfaceFunctionsAsString = () => this.surfaceFunctions;
        xIntervalAsString = () => this.xInterval;
        yIntervalAsString = () => this.yInterval;

        sample(u, v, target) {
            const θ = this.xInterval.scaleParameter(u);
            const φ = this.yInterval.scaleParameter(v);

            target.set(
                this.xFnCompiled(θ, φ),
                this.yFnCompiled(θ, φ),
                this.zFnCompiled(θ, φ)
            );
        }
    }


    class Ring {
        constructor(activeSurface, ringRadius=2, ringRotationSpeed=0.01, selectionLerp=0.08) {
            this.surfaceDisplayedInAxes = activeSurface
            this.ring = new THREE.Group();
            this.surfaces = [];
            this.ringRadius = ringRadius;
            this.ringRotationSpeed = ringRotationSpeed;
            this.selectionLerp = selectionLerp;
            this.ringTargetRotation = null;
            this.selectedSurface = null;
            this.activeCategory = Category.TOROID;
            scene.add(this.ring);
        }

        #rotationToTargetSurfaceIsNeeded = () => this.ringTargetRotation !== null;

        #rotate() {
            const delta = this.ringTargetRotation - this.ring.rotation.y;
            const shortest = ((delta + Math.PI) % (2 * Math.PI)) - Math.PI;
            this.ring.rotation.y += shortest * this.selectionLerp;

            if (Math.abs(shortest) < 0.001) {
                this.ring.rotation.y = this.ringTargetRotation;
                this.ringTargetRotation = null;
            }
        }

        #setTargetRotation() {
            const local = this.selectedSurface.mesh.position.clone();
            const angle = Math.atan2(local.x, local.z);
            this.ringTargetRotation = -angle + Math.PI * .3;
        }

        #placeAndShowSurface = (surface, index) => {
            const angle = 2 * Math.PI * index / this.visibleRingItems().length;
            const position = new THREE.Vector3(this.ringRadius * Math.cos(angle), -3, this.ringRadius * Math.sin(angle));
            surface.normalizeToFit(1);
            surface.moveTo(position);
            surface.show();
        };

        #displayEquation(surface, equationDiv) {
            const equation = "$$\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix}" +
                surface.mesh.userData.definition.xFn + " \\\\" +
                surface.mesh.userData.definition.yFn + " \\\\" +
                surface.mesh.userData.definition.zFn + "\\end{pmatrix}\\text{, } \\begin{cases} x \\in [" +
                surface.mesh.userData.intervals[0][0] + ", " +
                surface.mesh.userData.intervals[0][1] + "] \\\\ y \\in [" +
                surface.mesh.userData.intervals[1][0] + ", " +
                surface.mesh.userData.intervals[1][1] + "] \\end{cases}$$";

            equationDiv.innerHTML = surface ? equation : "Equation not found";
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, equationDiv]);
            //MathJax.typesetPromise([eqDiv]);
        }

        #updateSurfaceName() {
            const nameDiv = document.getElementById("surface-title");
            const equationDiv = document.getElementById('surface-equation');

            const surface = this.surfaces.find(surface => surface.mesh === this.selectedSurface.mesh);
            nameDiv.textContent = surface ? surface.mesh.userData.category + ": " + surface.mesh.userData.name: "Surface not found";
            this.#displayEquation(surface, equationDiv);
        }

        #highlightSelected(surface) {
            surface.mesh.material.emissive.set(0x111111);
            surface.mesh.material.wireframe = false;

            if (this.selectedSurface) {
                this.selectedSurface.mesh.material.emissive.set(0x000000);
                this.selectedSurface.mesh.material.wireframe = true;
            }
        }

        #storeSurfaceDataInMesh(surface, surfaceData) {
            surface.mesh.userData.name = surfaceData.meta.name;
            surface.mesh.userData.category = surfaceData.meta.category;
            surface.mesh.userData.definition = surfaceData.definition;
            surface.mesh.userData.intervals = surfaceData.intervals;
        }

        #addSurface(surface, surfaceDef) {
            this.ring.add(surface.mesh);
            this.surfaces.push(surface);
            this.#storeSurfaceDataInMesh(surface, surfaceDef);
        }

        setSelectedSurface = (surface) => {
            this.selectedSurface = surface;
            this.surfaceDisplayedInAxes.updateToNew(surface.definition);
            this.surfaceDisplayedInAxes.computeNormalizeScale(4); // TODO hard coded number
            this.surfaceDisplayedInAxes.normalizeToFit();

            this.#highlightSelected(surface);
            this.#setTargetRotation();
            this.#updateSurfaceName();
        }

        changeActiveCategoryTo(category) {
            this.activeCategory = category;
            this.redistribute();

            // Auto-select the first surface in the new category, if any
            const firstItem = this.visibleRingItems()[0];
            if (firstItem)
                this.setSelectedSurface(firstItem);
            else {
                this.selectedSurface = null;
                this.ringTargetRotation = null;
            }
        }

        add(surfaceDef) {
            const surfaceShape = new Surface(worldGroup, {
                resolution: 20,
                showWireframe: true,
                definition: new SurfaceTemplate(surfaceDef.definition, surfaceDef.intervals[0], surfaceDef.intervals[1])
            });
            this.#addSurface(surfaceShape, surfaceDef);
        }

        redistribute() {
            this.surfaces.forEach(surface => surface.hide());
            this.visibleRingItems().forEach((surface, index) => this.#placeAndShowSurface(surface, index));
        }

        findSurfaceByMesh = (mesh) => this.surfaces.find(surface => surface.mesh === mesh);
        getPickableMeshes = () => this.visibleRingItems().map(surface => surface.mesh);
        rotateRingToSelectedSurface = () => { if (this.#rotationToTargetSurfaceIsNeeded()) this.#rotate(); };
        visibleRingItems = () => this.surfaces.filter(surface => surface.mesh.userData.category === this.activeCategory);
        rotateSurfaces = () => this.visibleRingItems().forEach(surface => surface.rotateBy(this.ringRotationSpeed));
    }

    window.addEventListener("resize", () => {
        const w = canvas.clientWidth || width;
        const h = canvas.clientHeight || height;
        scenery.setSize(w, h);
    });

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    canvas.addEventListener("pointerdown", event => {
        mouse.x = (event.offsetX / canvas.clientWidth) * 2 - 1;
        mouse.y = -(event.offsetY / canvas.clientHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, scenery.camera);

        const hits = raycaster.intersectObjects(
            ring.getPickableMeshes(),
            false // IMPORTANT: no recursion
        );

        if (!hits.length) return;

        const mesh = hits[0].object;
        const surface = ring.findSurfaceByMesh(mesh);
        ring.setSelectedSurface(surface);
    });

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x131313);

    const worldGroup = new THREE.Group();
    scene.add(worldGroup);
    const scenery = new Scenery(scene, worldGroup);


    const firstSurface = surfaceDefinitions[0];
    const parametricSurface = new Surface(worldGroup, {
        resolution: 20,
        showWireframe: false,
        definition: new SurfaceTemplate(firstSurface.definition, firstSurface.intervals[0], firstSurface.intervals[1])
    });
    const size = new THREE.Vector3();
    parametricSurface.getBoundingBox().getSize(size);
    const axes = new MatlabAxes(worldGroup, Math.max(size.x, size.y, size.z) * 0.75);

    const ring = new Ring(parametricSurface);
    surfaceDefinitions.forEach(surface => ring.add(surface));
    ring.redistribute();

    // Auto-select first surface in the initial category
    const firstItem = ring.visibleRingItems()[0];
    if (firstItem) ring.setSelectedSurface(firstItem);

    scenery.fitToBoundingBox(parametricSurface.getBoundingBox());
    new ControlsGui(scenery, parametricSurface, axes);

    let lastTime = performance.now();
    function animate() {
        requestAnimationFrame(animate);

        const now = performance.now();
        const deltaTime = params.animate ? (now - lastTime) * 0.001 : 0;
        lastTime = now;

        parametricSurface.update(deltaTime);
        ring.rotateRingToSelectedSurface();
        ring.rotateSurfaces();
        scenery.render();
    }
    animate();

</script>
